---
title: 十大经典排序算法
createTime: 2024/11/25 15:02:09
tags:
  - 算法
  - 排序
---
# 十大排序算法（Java实现）

## 0、评价维度

**运行效率:** 排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）

**就地性:**  顾名思义，原地排序通过在原数组上直接操作实现排序，无需借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。

**稳定性:** 稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。

> 自适应性排序：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。
>
> 非自适应排序：指那些时间复杂度不随输入数据的变化而变化的排序算法。这类算法的时间复杂度是固定的，不会因为输入数据的不同而有所变化。常见的非自适应排序算法包括选择排序和冒泡排序。

## 1、选择排序

**选择排序（selection sort）** 的工作原理非常简单，开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。

**代码实现：**

```java
/**
 * 方法描述：选择排序算法演示函数
 *
 * @param arr 待排序数组
 * @date 2024-11-13 22:59:20
 */
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    int len = arr.length;
    // 外层循环控制未排序区间
    for (int i = 0; i < len - 1; i++) {
        // 内层循环找出未排序区间最小元素索引
        int minIndex = i;
        for (int j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 记录最小元素索引
            }
        }
        // 交换最小元素和未排序区间第一个元素
        if (minIndex != i) {
            swap(arr, i, minIndex);
        }
    }
}
```

> swap函数为交换数组指定索引的两个函数的辅助函数（后续都省略），如下：
>
> ```java
> /**
>  * 方法描述：元素交换辅助函数
>  *
>  * @param arr 待交换数组
>  * @param i   交换元素索引1
>  * @param j   交换元素索引2
>  * @date 2024-11-14 17:20:34
>  */
> private static void swap(int[] arr, int i, int j) {
>     int temp = arr[i];
>     arr[i] = arr[j];
>     arr[j] = temp;
> }
> ```

**算法特性：**

* 时间复杂度为 $O(n^2)$、非自适应排序：外循环共`n-1`轮，第一轮的未排序区间长度为`n`，最后一轮的未排序区间长度为2，即各轮外循环分别包含`n`、`n-1`……3、2轮内循环，等差数列求和得 $\frac{(n-1)(n+2)}{2}$，函数的渐进上界为 $n^2$，即时间复杂度为 $O(n^2)$。
* 空间复杂度为$O(1)$、原地排序：只占用两层循环的指针空间，所以空间复杂度为常数，所以空间复杂度为$O(1)$。
* 非稳定排序：有多个相等的元素且元素后面还有比元素小的元素时，相等元素的顺序会发生变化。

## 2、冒泡排序

**冒泡排序（bubble sort）** 通过连续地比较与交换相邻元素实现排序。整个过程就像是气泡从底部升到顶部一样，因此得名冒泡排序。

**代码实现：**

```java
/**
 * 方法描述：冒泡排序算法演示函数
 *
 * @param arr 待排序数组
 * @date 2024-11-14 09:17:52
 */
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 外循环：未排序区间为[0, i]
    for (int i = arr.length - 1; i > 0; i--) {
        boolean flag = false; // 初始化标志位（用以确定是否已经提前完成排序，本轮循环如果没有发生交换，说明已经有序，可以提前结束）
        // 内循环：将未排序区间[0, i]中的最大元素交换至该区间的最右端
        for (int j = 0; j < i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, i, minIndex);
                flag = true; // 发生交换，标志位置为true
            }
        }
        if (!flag) {
            break; // 未发生交换，说明已经有序，可以提前结束
        }
    }
}
```

**算法特性：**

* 时间复杂度为 $O(n^2)$、自适应排序：各轮“冒泡”遍历的数组长度一次为`n-1`、`n-2`……2、1，总和为 $\frac{(n-1) · n}{2}$。在引入flag优化后，最佳时间复杂度可达到 $O(n)$。
* 空间复杂度为$O(1)$、原地排序：只占用两层循环的指针空间，所以空间复杂度为常数，所以空间复杂度为$O(1)$。
* 稳定排序，在“冒泡”中遇到相等元素不交换。

## 3、插入排序

**插入排序（insertion sort）** 是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。

初始状态下，数组第一个元素已完成排序，选取第2个元素为基准（base），然后将其与前面已排序区间中的元素作对比放到合适的位置，如此往复即可完成整个数组的排序。

**代码实现：**

```java
/**
 * 方法描述：插入排序算法演示函数
 *
 * @param arr 待排序数组
 * @date 2024-11-14 16:38:23
 */
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 外循环：已排序区间为[0, i-1]
    for (int i = 1; i < arr.length; i++) {
        int base = arr[i]; // 基准
        int j = i - 1; // 已排序区间右端索引
        // 内循环：将基准插入已排序区间
        while (j >= 0 && arr[j] > base) {
            arr[j + 1] = arr[j]; // 右移元素
            j--;
        }
        arr[j + 1] = arr[j]; // 将基准插入正确位置
    }
}
```

**算法特性：**

* 时间复杂度为$O(n^2)$、自适应排序，在最差情况下，每次插入操作分别需要循环`n-1`、`n-2`……2、1次，求和得到$frec{(n-1) · n}{2}$，因此时间复杂度为$O(n^2)$。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序是，插入排序达到最佳时间复杂度$O(n)$。
* 空间复杂度为$O(1)$、原地排序：只占用两层循环的指针空间，所以空间复杂度为常数，所以空间复杂度为$O(1)$。
* 稳定排序，在插入操作过程中，会将元素插入到相等元素右侧，不会改变它们的顺序。

> **插入排序的优势分析：**
>
> 插入排序的时间复杂度为$O(n^2)$，而快速排序的时间复杂度为$O(n·logn)$。尽管插入排序的时间复杂度更高，**但在数量较小的情况下，插入排序通常更快**。
>
> 快速排序这类$O(n·logn)$的算法属于基于分治策略的排序算法，往往包含更多单元计算操作。而在数据量较小时，$n^2$和$n·logn$的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用。
>
> 实际上，许多编程语言（例如Java）的内置排序函数采用了插入排序，大致思路为：对于常数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。
>
> 虽然冒泡排序、选择排序和插入排序的时间复杂度都为$O(n^2)$，但实际情况中，**插入排序的使用频率显著高于冒泡和选择排序**，主要有以下原因：
>
> * 冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及3个单元操作；插入排序基于元素赋值实现，进需1个单元操作。因此，**冒泡排序的计算开销通常比插入排序更高**。
> * 选择排序在任何情况下时间复杂度都为$O(n^2)$。**如果给定一组部分有序的数据，插入排序通常比选择排序效率更高。**
> * 选择排序不稳定，无法应用于多级排序。

## 4、希尔排序

**希尔排序（shell sort）** 也称递减增量排序算法，是插入排序的一种更高效的改进版本，希尔排序基于插入排序的以下两点性质提出改进方法：

* 插入排序在堆几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率。
* 插入排序是低效的，因为插入排序每次智能将数据移动一位。

希尔排序的基本思想是：先将整个待排序的数组分成若干个子数组，子数组分别进行插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序（使用分治的思想优化选择排序）。

算法流程：

1. 选择一个分组间隔k（通常初始间隔为序列长度的一半），轮番以0~step之间的数作为起始索引，每间隔k取一个元素组成序列，每轮组成一个子序列。
2. 分别对每个子序列进行插入排序。
3. 没排序完一轮将间隔减半，重复上述的分组和插入排序过程，直到间隔step=1，再进行最后一次插入排序。

**代码实现：**

```java
/**
 * 方法描述：希尔排序算法演示函数
 *
 * @param arr 待排序数组
 * @date 2024-11-15 12:26:29
 */
public static void shellSort(int[] arr) {
    int length = arr.length;
    // 外层循环：通过循环结构获取递减间隔（增量）step
    for (int step = length / 2; step >= 1; step /= 2) {
        // 内层循环：通过步长（增量）step，将数组元素分组，进行插入排序
        // 当前for循环，每循环一次，就对增量为setp的所有子数组第i个元素进行了插入排序，随着循环的逐步推进完成同增量所有子序列的排序
        for (int i = step; i < length; i++) {
            int base = arr[i]; // 基准
            int j = i - step; // 获取起始索引，也算是已排序区间右端索引，因为每轮都是从第一个元素开始
            while (j >= 0 && arr[j] > base) {
                // 按照间隔（步长）为step右移元素，直到遇到小于或等于基准数的元素
                arr[j + step] = arr[j];
                j -= step;
            }
            arr[j + step] = base; // 将基准插入正确位置
        }
    }
}
```

**算法特性：**

* 时间复杂度根据增量序列的不同，其最终效率也不同（减半的那个增量序列不是效率最高的）、自适应排序，平均时间复杂度为 $O(n^{1.3})$，最好时间复杂度 $O(n)$，最差时间复杂度 $O(n^2)$，目前尚未研究出最优的增量序列。
* 空间复杂度为 $O(1)$，只额外使用了几个辅助变量。
* 非稳定排序，由于进行了分组，原先相等且相邻的元素可能会由于分组被交换原先顺序。

## 5、快速排序

**快速排序（quick sort）** 是一种基于分治策略的排序算法，运行高效，应用广泛。

快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的摸个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。哨兵划分完成后，原数组被划分为三个部分：左子数组、基准数、右子数组，且满足“左子数组任意元素≤基准数≤右子数组任意元素”。因此，只需要对这两个子数组分别进行排序即可。

> 快速排序的分治策略
>
> 哨兵划分的实质是将一个较长数组的排序问题简化为两个较短数组的排序问题。

**代码实现：**

```java
/**
 * 方法描述：快速排序算法核心辅助函数：哨兵划分
 *
 * @param arr   待划分数组
 * @param left  左端索引
 * @param right 右端索引
 * @return {@code int} 基准数最终索引
 * @date 2024-11-14 17:24:49
 */
public static int partition(int[] arr, int left, int right) {
    // 以arr[left]为基准，将数组分为两部分，左边小于基准，右边大于等于基准
    int i = left, j = right;
    while (i < j) {
        // 从右往左，找到首个小于基准数的元素索引
        while (i < j && arr[j] >= arr[left]) j--;
        // 从左往右，找到首个大于基准数的元素索引
        while (i < j && arr[i] < arr[left]) i++;
        swap(arr, i, j); // 交换这两个元素
    }
    swap(arr, i, left); // 将基准数交换至两个子数组的分界线
    return i; // 返回基准数索引
}
```

算法流程：首先对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组；然后对左子数组和右子数组分别递归执行“哨兵划分”；持续递归知道子数组长度为1时终止，从而完成这个数组的排序。

```java
/**
 * 方法描述：快速排序算法演示函数
 *
 * @param arr   待排序数组
 * @param left  左端索引
 * @param right 右端索引
 * @date 2024-11-14 17:41:10
 */
public static void quickSort(int[] arr, int left, int right) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 子数组长度为 1 时终止递归
    if (left >= right) {
        return;
    }
    // 哨兵划分
    int pivot = partition(arr, left, right);
    // 分别递归左子数组、右子数组
    quickSort(arr, left, pivot - 1);
    quickSort(arr, pivot + 1, right);
}
```

**算法特性：**

* 时间复杂度为$O(n·logn)$、自适应排序，在平均情况下，哨兵划分的递归层数为`logn`，每层中的总循环数为n，总体用`O(n·logn)`时间。在最差情况下，每轮哨兵划分操作都将长度为n的数组划分为长度为0和`n-1`的两个子数组，此时递归层数达到n，每层中的循环数为n，总体使用$O(n^2)$时间。
* 空间复杂度为`O(n)`、原地排序，在输入数组完全倒序的情况下，达到最差递归深度n，使用`O(n)`栈帧空间。排序操作是在原数组上进行的，未借助额外数组。
* 非稳定排序，在哨兵划分最后一步，基准数可能会被交换至相等元素右侧。

> 快速排序“快速”的原因。
>
> 快速排序的时间复杂度与归并排序和堆排序相同，但是通常情况下，快速排序的效率更高，有以下原因：
>
> * 出现最差情况的概率很低，虽然快速排序的最差时间复杂度为$O(n^2)$，没有归并排序稳定，但是在绝大多数情况下，快速排序能在$O(n·logn)$的时间复杂度下运行。
> * 缓存使用效率高，在执行哨兵划分操时，系统可将整个子数组加载到缓存，因此访问元素的效率比较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏了这一特性。
> * 复杂度的常系数小，在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的的原因类似。



**快速排序的基准数优化**

快速排序在一些特殊的输入下时间效率会降低，例如输入的数组是完全倒序的，由于选择的时最左端的元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为`n-1`，右子数组长度为0。如此递归下去，每轮哨兵划分后都有一个子数组长度为0，分治策略失效，快速排序退化为“冒泡排序”的近似形式。为了尽量避免这种情况，可以优化哨兵划分中的基准数的选取策略。

优化方案：在数组中选取三个元素（通常为首、尾、中点元素），然后将这三个候选元素的中位数作为基准数。

> 使用这种策略将大幅提升基准数“既不太大也不太小”的概率。
>
> 也可以选取更多候选元素，进一步提升算法稳定性。
>
> 通过使用这种基准数选取策略，快速排序时间复杂度退化至$O(n^2)$的概率大大降低。

策略代码实现：

```java
/**
 * 方法描述：快速排序算法核心辅助函数：哨兵划分
 *
 * @param arr   待划分数组
 * @param left  左端索引
 * @param right 右端索引
 * @return {@code int} 基准数最终索引
 * @date 2024-11-14 17:24:49
 */
public static int partition(int[] arr, int left, int right) {
    // 选取三个候选元素的中位数
    int med = medianThree(arr, left, (left + right) / 2, right);
    // 将中位数交换至数组最左端
    swap(arr, left, med);
    // 以arr[left]为基准，将小于等于arr[left]的元素放左边，大于arr[left]的元素放右边
    int i = left, j = right;
    while (i < j) {
        // 从右往左，找到首个小于基准数的元素索引
        while (i < j && arr[j] >= arr[left]) j--;
        // 从左往右，找到首个大于基准数的元素索引
        while (i < j && arr[i] < arr[left]) i++;
        swap(arr, i, j); // 交换这两个元素
    }
    swap(arr, i, left); // 将基准数交换至两个子数组的分界线
    return i; // 返回基准数索引
}

/**
 * 方法描述：哨兵划分策略辅助函数：获取数组指定三个索引的中位数索引
 *
 * @param arr   数组
 * @param left  左端索引
 * @param mid   中点索引
 * @param right 右端索引
 * @return {@code int} 中位数索引
 * @date 2024-11-15 05:56:47
 */
private static int medianThree(int[] arr, int left, int mid, int right) {
    int l = arr[left], m = arr[mid], r = arr[right];
    // m在l,r之间
    if ((m > l && m < r) || (m < l && m > r)) return mid;
    // l在m,r之间
    if ((l > m && l < r) || (l < m && l > r)) return left;
    // r在m,l之间
    return right;
}
```



**尾递归优化**

在某些输入下，快速排序可能占用空间较多，例如，输入一个完全有序的数组，设递归中的子数组长度为m，每轮哨兵划分操作都将产生长度为0的左子数组和长度为`m-1`的右子数组，这意味着每层递归调用减少的问题规模非常小（只减少了一个元素），递归树的高度会达到`n-1`，此时需要占用`O(n)`大小的栈帧空间。

优化方案：每轮哨兵排序后只对较短的子数组进行递归，而不是立刻分别递归左右子数组（只要left＜right，循环就会一直进行下去），这样以来较短子数组长度不会超过$\frac{n}{2}$，所以这种方法能确保递归深度不超过$logn$，从而将最差空间复杂度优化至$O(logn)$。

尾递归优化代码实现：

```java
/**
 * 方法描述：快速排序算法演示函数
 *
 * @param arr   待排序数组
 * @param left  左端索引
 * @param right 右端索引
 * @date 2024-11-14 17:41:10
 */
public static void quickSort(int[] arr, int left, int right) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 子数组长度为 1 时终止递归
    while (left < right) {
        // 哨兵划分
        int pivot = partition(arr, left, right);
        // 对两个子数组中较短的那个执行快速排序
        if (pivot - left < right - pivot) {
            quickSort(arr, left, pivot - 1);
            left = pivot + 1;
        } else {
            quickSort(arr, pivot + 1, right);
            right = pivot - 1;
        }
    }
}
```

## 6、归并排序

**归并排序（merge sort）** 是一种基于分治策略的排序算法，包含了“划分”和“合并”阶段。

划分阶段：通过不断地将数组从中点处分开，将长数组的排序问题转化为短数组的排序问题。

合并阶段：当子数组长度为1时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。

算法流程：

划分阶段“从顶至底”递归地将数组从中点切分为两个子数组：

1. 计算数组重点`mid`，递归划分左子数组（区间`[left, mid]`）和右子数组（区间`[mid + 1, right]`）;
2. 递归执行步骤1，直至子数组长度为1时终止。

合并阶段“从底至顶”将左子数组和右子数组合并为一个有序数组。从长度为1的子数组开始合并，合并过程中，每个子数组都是有序的。

> 从流程上来看，归并排序与二叉树后续遍历的递归顺序一致：
>
> 后续遍历：先递归左子树，再递归右子树，最后处理根节点。
>
> 归并排序：先递归左子数组，再递归右子数组，最后处理合并。

**代码实现：**

```java
/**
 * 方法描述：归并排序算法演示函数
 *
 * @param arr   待排序数组
 * @param left  左端索引
 * @param right 右端索引
 * @date 2024-11-15 06:48:38
 */
public static void mergeSort(int[] arr, int left, int right) {
    // 终止条件：子数组长度为 1 时终止递归
    if (left >= right) return;
    // 划分阶段
    int mid = (left + right) / 2; // 计算中点索引
    mergeSort(arr, left, mid); // 递归左子数组
    mergeSort(arr, mid + 1, right); // 递归右子数组
    // 合并阶段
    merge(arr, left, mid, right);
}

/**
 * 方法描述：归并排序辅助函数：合并左子数组和右子数组
 *
 * @param arr   原数组
 * @param left  子数组左端索引
 * @param mid   子数组中点索引
 * @param right 子数组右端索引
 * @date 2024-11-15 06:37:50
 */
private static void merge(int[] arr, int left, int mid, int right) {
    // 左子数组区间为[left, mid]， 右子数组区间为[mid+1, right]
    // 创建一个临时数组temp，用于存放合并后的结果
    int[] temp = new int[right - left + 1];
    // 初始化左右子数组和临时数组的起始索引
    int i = left, j = mid + 1, k = 0;
    // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中
    while (i <= mid && j <= right) {
        if (arr[i] < arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    // 将左右子数组剩余元素复制到临时数组中
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    while (j <= right) {
        temp[k++] = arr[j++];
    }
    // 将临时数组中的元素复制回原数组
    for (i = left; i <= right; i++) {
        arr[i] = temp[i - left];
    }
}
```

**算法特性**

* 时间复杂度为$O(n·logn)$、非自适应排序，划分产生高度为$logn$的递归树，每层合并的操作数量为n，因此总体时间复杂度为$O(n·logn)$。
* 空间复杂度为$O(n)$、非原地排序，递归深度为$logn$，使用$O(logn)$大小的栈帧空间。合并操作需要借助辅助数组实现，使用$O(n)$大小的额外空间。
* 稳定排序，在合并过程中，相等元素的次序保持不变。

> 使用场景：用于链表排序
>
> 对于链表，归并排序相较于其他排序算法具有显著优势，可以将链表排序任务的空间复杂度优化至$O(1)$。
>
> * 划分阶段：可以使用“迭代”替代“递归”来实现链表划分工作，从而省去递归使用的栈帧空间。
> * 合并阶段：在链表中，节点怎山操作仅需改变引用（指针）即可实现，因此合并阶段（将连个短有序链表合并为一个长有序链表）无须创建额外链表。

## 7、堆排序

**堆排序（heap sort）** 是一种基于堆数据结构实现的高效排序算法，通过“建堆操作”和“元素出堆操作”实现堆排序。大体思路如下：

1. 输入数组并建立小顶堆，此时最小元素位于堆顶。
2. 不断执行出堆操作，一次记录出堆元素，即可得到从小到大排序的序列。

算法流程（数组长度为n）：

1. 输入数组并建立大顶堆，完成后最大元素位于堆顶。
2. 将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换，完成交换后，堆长度减1，已排序元素数量加1。
3. 从堆顶元素开始，从底到顶执行堆化操作（sift down），完成堆化后，堆的性质得到修复。
4. 循环执行第2步和第3步，循环`n-1`轮后，即可完成数组排序。

**代码实现：**

```java
/**
 * 方法描述：堆排序算法函数演示
 *
 * @param arr 待排序数组
 * @date 2024-11-15 07:16:06
 */
public static void heapSort(int[] arr) {
    if (arr == null || arr.length < 2) return;
    // 建堆：堆化出叶节点意外的其他所有节点
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        siftDown(arr, arr.length, i);
    }
    // 从堆中提取最大元素，循环n-1次
    for (int i = arr.length - 1; i > 0; i--) {
        // 交换根节点与最右叶节点
        swap(arr, 0, i);
        // 以根节点为起点，从顶至底进行堆化
        siftDown(arr, i, 0);
    }
}

/**
 * 方法描述：堆排序算法辅助函数：从顶至底堆化
 * <br/><font color="blue">说明：与常规的堆化函数不同，由于堆的长度会随着提取最大元素而减小，因此需要使用额外使用一个参数来指定堆的有效长度</font>
 *
 * @param arr 待堆化数组
 * @param n   数组长度
 * @param i   当前节点索引
 * @date 2024-11-15 07:17:26
 */
private static void siftDown(int[] arr, int n, int i) {
    while (true) {
        // 判断节点i，l，r中值最大的节点，记为ma
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        int ma = i;
        if (l < n && arr[l] > arr[ma]) ma = l;
        if (r < n && arr[r] > arr[ma]) ma = r;
        // 若节点i最大或索引l，r越界，则无须继续堆化
        if (ma == i) break;
        // 交换两个节点
        swap(arr, i, ma);
        // 继续堆化
        i = ma;
    }
}
```

**算法特性：**

* 时间复杂度为$O(n·logn)$、非自适应排序，建堆操作使用$O(n)$时间，从堆中提取最大元素的时间复杂度为$O(logn)$，共循环`n-1`轮。
* 空间复杂度为$O(1)$、原地排序，几个指针变量使用 $O(1)$空间，元素交换和堆化操作都是在原数组上进行的。
* 非稳定排序，在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。

## 8、桶排序

**桶排序（bucket sort）** 是分治策略的一个典型应用，它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中，然后在每个桶内部分别执行排序，最终按照桶的顺序将所有数据合并。

> 之前的排序算法都属于“基于比较的排序算法”，它们通过比较元素的大小来实现排序。此类算法时间复杂度无法超越 $O(n·logn)$。桶排序属于“非比较排序算法”，这类算法的时间复杂度可以达到线性阶。

算法流程（一个长度为n的数组，其元素范围是`[0, 1)`内的浮点数）：

1. 初始化k个桶，将n个元素分配到k个桶中。
2. 对每个桶分别执行排序（排序算法随意）。
3. 按照桶从小到大的顺序合并结果。

**代码实现：**

```java
/**
 * 方法描述：桶排序算法演示函数
 *
 * @param arr 待排序数组
 * @date 2024-11-15 08:13:48
 */
public static void bucketSort(float[] arr) {
    if (arr == null || arr.length < 2) return;
    // 初始化k=n/2个桶，预期向每个桶分配2个元素
    int k = arr.length / 2;
    List<List<Float>> buckets = new ArrayList<>(k);
    for (int i = 0; i < k; i++) {
        buckets.add(new ArrayList<>(2));
    }
    // 1.将元素分配到各个桶中
    for (float num : arr) {
        // 输入数据范围为[0, 1)，使用(num * k)映射到索引范围[0, k-1]
        int i = (int) (num * k);
        // 将num添加进桶i中
        buckets.get(i).add(num);
    }
    // 2.对各个桶执行排序
    for (List<Float> bucket : buckets) {
        Collections.sort(bucket);
    }
    // 3.将各个桶中的元素合并到原数组中
    int i = 0;
    for (List<Float> bucket : buckets) {
        for (float num : bucket) {
            arr[i++] = num;
        }
    }
}
```

> 桶排序适用于处理体量很大的数据，例如，输入数据包含100万个元素，由于空间限制，系统内存无法一次性加载所有数据，此时，可以将数据分成1000个桶，然后分别对每个桶进行排序，最后将结果合并。

**算法特性：**

* 时间复杂度为 $O(n+k)$，假设元素在各个桶内平均分布，那么每个桶内的元素数量为 $\frac{n}{k}$，且排序单个桶使用 $O(\frac{n}{k}log\frac{n}{k})$时间，则排序所有桶使用$O(nlog\frac{n}{k})$时间，当桶数量k比较大时，时间复杂度趋向于$O(n)$。合并结果时需要遍历所有桶和元素，花费 $O(n+k)$时间。
* 自适应排序，在最差情况下，所有数据被分配到一个桶中，且排序该桶使用 $O(n^2)$时间。
* 空间复杂度为 $O(n+k)$、非原地排序，需要借助k个桶和总共n个元素的额外空间。
* 桶排序是否稳定取决于排序桶内元素的算法是否稳定。

> 如何实现平均分配？
>
> 桶排序时间复杂度理论上可以达到 $O(n)$，关键在于将元素均匀分配到各个桶中，为了实现平均飞陪，可以先设定一条大致的分界线，将数据粗略地分配到3个桶中，分配完毕后，再将元素较多的桶继续划分为3个桶，直至所有桶中的元素数量大致相等。
>
> 这种分配方式本质上是创建一颗递归树，目标是让叶节点的值尽可能平均（不一定非要是3个桶，可根据数据特性进行选择）。
>
> 如果提前知道数据的概率分布，则可以根据数据概率分布设置每个桶的范围分界线，当然，数据分布并不一定要特意统计，也可以根据数据特点采用某种概率模型进行近似，这样就可以合理地设置桶范围区间，从而均匀地将元素放入桶中。

## 9、计数排序

**计数排序（counting sort）** 通过统计元素数量来实现排序，通常应用于整数数组。

**简单实现：**

给定一个长度位n的数组arr，其中的元素都是“非负整数”，计数排序流程如下。

1. 遍历数组，找出其中最大数字，即为m，然后创建一个长度为`m+1`的辅助数组counter。
2. 借助counter统计arr中各数字出现次数，其中`counter[num]`对应数字num出现次数。统计方法很简单，只需遍历arr（设当前数字为num），每轮将`counter[num]`加1即可。
3. 由于counter的各个索引天然有序，因此相当于所有数字已经排序好了，接下来，只需遍历counter，根据各数字出现次数从小到大顺序填入arr即可。

> 计数排序与桶排序的联系
>
> 从桶排序的角度看，可以将计数排序中的技术数组counter的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整形数据下的一个特例。

（简单实现代码略）

**完整实现：**

如果输入数据是对象，则简单实现中的步骤3就会失效（对象间存放的是内存地址/指针，必须通过原数据的内存地址/指针填入原数组）。

解决方案：

首先引入一个前缀和的概念，获取到counter后，首先计算counter的前缀和，索引i处的前缀和`prefix[i]`等于数组前i个元素之和：
$$
prefix[i]=\sum_{j=0}^i counter[j]
$$
前缀和具有明确意义，`prefix[i]-1`代表元素num在结果数组res中最后一次出现的索引。通过它可以获取元素在结果数组中的位置。

算法流程：获取到counter后，在counter原数组中原地计算counter前缀和，倒序遍历原数组arr的每个元素num，在每轮迭代中执行以下两个步骤：

1. 将num填入数组res的索引`prefix[num]-1`处。
2. 将此时counter中对应的前缀和`prefix[num]`的值减1，从而得到下次放置num的索引。

通过这种方式，巧妙地将数值直接取值放回原数组的“创造复现元数据”的方式转换为了取元数据（的引用）放置到结果数组的操作方式，从而解决了对象使用计数排序的问题。遍历完成后，数组res中就是排序号的结果，最后使用res覆盖原数组arr即可。

**代码实现：**

```java
/**
 * 方法描述：计数排序算法演示函数
 *
 * @param arr 待排序数组
 * @date 2024-11-15 09:35:16
 */
public static void countingSort(int[] arr) {
    if (arr == null || arr.length < 2) return;
    // 1.找出数组中的最大值，创建counter
    int m = 0;
    for (int num : arr) {
        m = Math.max(m, num);
    }
    int[] counter = new int[m + 1];

    // 2.统计每个元素出现的次数
    for (int num : arr) {
        counter[num]++;
    }

    // 3.计算前缀和
    for (int i = 0; i < m; i++) {
        counter[i + 1] += counter[i];
    }

    // 4.倒序遍历原数组，通过前缀和将每个元素放入结果数组中
    int[] res = new int[arr.length];
    for (int i = arr.length - 1; i >= 0; i--) {
        res[counter[arr[i]] - 1] = arr[i];
        counter[arr[i]]--;
    }

    // 5.复制结果数组到原数组
    System.arraycopy(res, 0, arr, 0, res.length);
}
```

**算法特性：**

* 时间复杂度为 $O(n+m)$，涉及遍历arr和counter，都使用线性时间，一般情况下 $n\gg m$，时间复杂度趋于 $O(n)$。
* 空间复杂度为 $O(m+n)$、非原地排序，接住了长度分别为n和m的数组res和counter。
* 稳定排序，由于向res中填充元素的顺序是“从右向左”，因此倒序遍历原数组正好避免了改变相等元素之间位置，从而实现稳定派系。

## 10、基数排序

> 计数排序的使用限制
>
> 计数排序适用于数量n比较大但数据范围m较小的情况，假设需要对 $n=10^6$个学号进行排序，而学号是一个8位数字，这意味着数据范围 $m=10^8-1$非常大，使用计数排序需要分配大量内存空间，基数排序可以避免这种情况。

**基数排序（radix sort）** 的核心思想与计数排序一致，也通过统计个数来实现排序，在此基础上，基数排序利用数字各位之间的递进关系，一次对每一位进行排序，从而得到最终排序结果。

算法流程：以引言中的学号为例，假设数字的最低位是第1位，最高位是第8位，基数排序流程如下：

1. 初始化位数 $k=1$。
2. 对学号的第k位执行计数排序，完成后，数据根据第k位从小到大排序。
3. 将k增加1，然后返回步骤2继续迭代，直到所有位数排序完成后结束。

> 对于一个d进制的数字 $x$，要获取其第k位 $x_k$，可以使用以下计算公式：
> $$
> x_k=\lfloor\frac{x}{d^{k-1}}\rfloor\mod d
> $$
> 其中，$\lfloor a \rfloor$表示对a向下取整，$\mod d$表示对d取模（取余），对于学号数据，$d=10$、$k\in[1,8]$。

再对计数排序代码进行部分修改，使之可以根据数字的第k位进行排序：

```java
/**
 * 方法描述：基数排序算法演示函数
 * @param arr 待排序数组
 * @date 2024-11-15 10:40:11
 */
public static void radixSort(int[] arr) {
    if (arr == null || arr.length < 2) return;
    // 1.获取数组的最大元素，用于判断最大位数
    int m = Integer.MIN_VALUE;
    for (int num : arr) {
        m = Math.max(m, num);
    }
    // 2.按照从低位到高位的顺序遍历
    for (int exp = 1; exp <= m; exp *= 10) {
        // 3.对数组的第k位进行计数排序
        // k = 1 -> exp = 1
        // k = 2 -> exp = 10
        // 即exp = 10^(k-1)
        countingSortForRadix(arr, exp);
    }
}
```

> 为什么从低位开始排序？
>
> 因为后一轮排序会覆盖前一轮排序的结果，但是数字的高位优先级高于低位，所以需要从低位开始排序。

**算法特性：**

* 时间复杂度 $O(nk)$，设数据量为n、数据为d进制、最大位数为k，则对某一位执行计数排序使用 $O(n+d)$时间，排序所有k位使用 $O((n+d)k)$时间。通常情况下，d和k都相对较小，时间复杂度趋向 $O(n)$。
* 空间复杂度为 $O(n+d)$、非原地排序，与计数排序相同，基数排序需要借助长度为n和d的数组res和counter。
* 稳定排序，当计数排序稳定时，基数排序也稳定，当计数排序不稳定时，基数排序也不稳定，基数排序无法保证得到正确的排序结果。
