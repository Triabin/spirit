---
title: SQL与数据库
---

# SQL与数据库

参考：[黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括](https://www.bilibili.com/video/BV1Kr4y1i7ru)

## SQL

概念：SQL，即structure query language，结构化检索语言的简称，是一种**标准化的编程语言**，专用于管理关系型数据库系统（RDBMS）。其核心功能包括数据定义、数据操纵、数据查询和数据控制，支持用户在不了解底层存储细节的情况下操作数据。

**非过程化特性**：用户只需声明“做什么”（如查询、更新），无需指定“怎么做”，由数据库引擎自动优化执行路径。

**统一语法**：适用于不同底层结构的数据库（如 Oracle、MySQL、SQL Server），提供一致的接口。

1974 年由 IBM 研究员 Boyce 和 Chamberlin 在 System R 数据库系统中首次实现（原名 SEQUEL），1986 年被 ANSI 和 ISO 采纳为关系数据库的国际标准，后续演进为 SQL-89、SQL-92 等版本。

核心特性：

* 高度非过程化：用户无需指定数据存储路径，由数据库优化器自动选择高效执行策略，提升数据独立性与操作效率。

* 面相集合的操作：操作对象和结果均为元组集合，例如，依次`UPDATE`可更新多行，`SELECT`返回结果集。

* 两种使用方式统一

  ① 自含式：独立执行（适合废专业人员）

  ② 嵌入式：嵌套在C、Java等宿主语言中（适合开发人员）

* 语法简洁易学：核心功能仅需9个动词，类英语口语化语法，如`SELECT * FROM table WHERE condition`。

* 支持模式与三级结构

  ① 外模式：视图（view）

  ② 全局模式：基本表（table）

  ③ 内模式：存储文件（由系统自动管理）

### 1、核心功能模块

SQL 按功能分为六类语句，覆盖数据库全生命周期操作：

|      功能分类       |      核心动词（关键字）      | 作用 |
| :-----------------: | :--------------------------: | :--: |
| 数据查询语言（DQL） |           `SELECT`           | 从表中检索数据，支持过滤、排序、分组，如`WHERE`、`ORDER BY`、`GROUP BY` |
| 数据操作语言（DML） | `INSERT`、`UPDATE`、`DELETE` | 增删改表中的记录 |
| 数据定义语言（DDL） | `CREATE`、`ALTER`、`DROP` |定义/修改数据库对象，如表、索引、视图|
| 数据控制语言（DCL） | `GRANT`、`REVOKE` | 管理用户权限，如访问控制 |
| 事务控制语言（TCL） | `COMMIT`、`ROLLBACK` | 确保数据一致性，如事务提交或回滚 |
| 指针控制语言（CCL） | `DECLARE COURSOR` | 逐行处理数据（较少使用） |

### 2、基本语法元素

#### 2.0 通用语法

* SQL语句可以单行或多行书写，以分号结尾。
* SQL语句可以使用空格或缩进来增强语句的可读性。
* 一些数据库的SQL语句不区分大小写，但是关键字建议使用大写。
* 注释：
  ```sql
  -- 单行注释
  /*
   多行注释
   */
  ```

#### 2.1 数据定义（DDL）

数据定义语言，Data Definition Language，用来定义数据库对象（数据库、表、字段）。

##### 数据库操作

* 查询

  ```sql
  -- 查询所有数据库
  SHOW DATABASES;
  -- 查询当前数据库
  SELECT DATABASE();
  ```

* 创建

  ```sql
  CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];
  ```
  
* 删除

  ```sql
  DROP DATABASE [IF EXISTS] 数据库名;
  ```
  
* 使用

  ```sql
  USE 数据库名;
  ```

##### 表操作

* 查询

  ```sql
  SHOW TABLES; -- 查询当前数据库所有表
  DESC 表名; -- 查询表结构
  SHOW CREATE TABLE 表名; -- 查询指定表的建表语句
  ```

* 创建

  ```sql
  CREATE TABLE 表名(
    字段1 字段1类型[(长度)] [CHAR SET 字符集] [COLLATE 排序] [DEFAULT 默认值] [NOT NULL] [COMMENT 字段1注释],
    字段2 字段2类型[(长度)] [CHAR SET 字符集] [COLLATE 排序] [DEFAULT 默认值] [NOT NULL] [COMMENT 字段2注释],
    字段3 字段3类型[(长度)] [CHAR SET 字符集] [COLLATE 排序] [DEFAULT 默认值] [NOT NULL] [COMMENT 字段3注释],
    ……
    字段n 字段n类型[(长度)] [CHAR SET 字符集] [COLLATE 排序] [DEFAULT 默认值] [NOT NULL] [COMMENT 字段n注释]
  )[ENGINE=存储引擎 DEFAULT CHARSET=字符集 COLLATE=排序 COMMENT 表注释];
  ```

* 数据类型

  主要分为三类：数值、字符串、日期时间类型。具体类则需要根据具体的数据库系统而定。

* 修改表

  ```sql
  -- 添加字段
  ALTER TABLE 表名 ADD 字段名 类型[(长度)] [COMMENT 注释] [约束]; -- 参考创建语句中的字段参数
  
  -- 修改字段数据类型
  ALTER TABLE 表名 MODIFY 字段名 新数据类型[(长度)];
  -- 修改字段名和字段类型
  ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型[(长度)] [COMMENT 注释] [约束];
  
  -- 删除字段
  ALTER TABLE 表名 DROP 字段名;
  
  -- 修改表名
  ALTER TABLE 表名 RENAME TO 新表名;
  
  -- 删除表
  DROP TABLE [IF EXISTS] 表名;
  -- 删除指定表并重新创建该表
  TRUNCATE TABLE 表名;
  ```

  

#### 2.2 数据操作（DML）

数据操作语言，Data Manipulation Language，用来对数据库表中的数据进行增删改。

##### 添加数据（INSERT）

```sql
-- 给指定字段添加数据
INSERT INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...);
-- 给全部字段添加数据
INSERT INTO 表名 VALUES(值1, 值2, ...)；

-- 批量添加数据
INSERT INTO 表名(字段1, 字段2, ...) VALUES(值11, 值12, ...), (值21, 值22, ...), ...;
INSERT INTO 表名 VALUES(值11, 值12, ...), (值21, 值22, ...), ...;
```

:::warning 注意

* 插入数据时，指定的字段顺序需要与值的顺序是一一对应的；
* 字符串和日期型数据应该包含在引号中；
* 插入的数据大小，应该在字段的规定范围内。

:::

##### 修改数据（UPDATE）

```sql
-- 基本语法
UPDATE 表名 SET 字段1=值1, 字段2=值2, ...[ WHERE 条件];
```

> where条件如果没有，则修改整张表。

##### 删除数据（DELETE）

```sql
-- 基本语法
DELETE FROM 表名[ WHERE 条件];
```

:::warning 注意

* DELETE语句的条件可选，如果没有则删除整张表数据（注意与TRUNCATE区别）；
* DELETE语句不能删除某一个字段的值（可以使用UPDATE）。

:::

#### 2.3 数据查询（DQL）

数据库查询语言，Data Query Language，用来查询数据库表中的记录。

基础结构：

```sql
SELECT [DISTINCT] 字段列表
FROM 表名列表
WHERE 条件列表
GROUP BY 分组字段列表 
HAVING 分组后条件列表
ORDER BY 排序列字段列表[ ASC/DESC]
LIMIT [起始索引, ]行数;
```

执行顺序：`FROM > WHERE > GROUP BY > HANVING > SELECT > ORDER BY > LIMIT`，执行顺序涉及到语句中别名的使用。

##### 基本查询

```sql
-- 查询多个字段
SELECT 字段1, 字段2, ... FROM 表名;
-- 查询全部字段
SELECT * FROM 表名;

-- 设置别名
SELECT 字段1 [AS] 别名1, 字段2 [AS] 别名2, ... FROM 表名;
-- 去除重复记录
SELECT DISTINCT 字段列表 FROM 表名;
```

##### 条件查询（WHERE）

```sql
-- 语法
SELECT 字段列表 FROM 表名 WHERE 条件列表;
```

条件种类：

|      比较运算符       |                     功能                     |
| :-------------------: | :------------------------------------------: |
|          `>`          |                     大于                     |
|         `>=`          |                   大于等于                   |
|          `<`          |                     小于                     |
|         `<=`          |                   小于等于                   |
|      `<>`或`!=`       |                    不等于                    |
| `BETWEEN min AND max` |       在某个范围之内（包含最大最小值）       |
|  `IN(值1, 值2, ...)`  |             在IN后面的列表中的值             |
|     `LIKE 占位符`     | 模糊匹配（`_`匹配单个字符，`%`匹配任意字符） |
|       `IS NULL`       |                    为NULL                    |
|     `AND `或 `&&`     |            并且（多个条件都成立）            |
|      `OR`或`||`       |         或者（多个条件任意一个成立）         |
|      `NOT`或`!`       |                   非，不是                   |

:::warning 注意

* `BETWEEN min AND max`语句中，BETWEEN后为较小值，AND后为较大值；
* 匹配字段column为两个字符的数据：`SELECT * FROM 表 WHERE column LIKE '__'`。

:::

##### 聚合函数（count、max、min、avg、sum）

聚合函数，即将一列数据作为一个整体，进行纵向计算，常见的聚合函数：

| 函数  |   功能   |
| :---: | :------: |
| count | 统计数量 |
|  max  |  最大值  |
|  min  |  最小值  |
|  avg  |  平均值  |
|  sum  |   求和   |

```sql
-- 语法
SELECT 聚合函数(字段列表) FROM 表名;
```

:::danger 注意

NULL值不参与所有聚合函数运算。

:::

##### 分组查询（GROUP BY）

```sql
SELECT 字段列表 FROM 表名 [WHERE 分组前的条件] GROUP BY 分组字段名 [HAVING 分组后的过滤条件];
```

`WHERE`与`HAVING`区别：

* 执行时机不同：`WHERE`是分组之前进行过滤，不满足`WHERE`条件的不参与分组；`HAVING`是分组之后对结果进行过滤。
* 判断条件不同：`WHERE`不能对聚合函数进行判断，而`HAVING`可以。

:::warning 注意

* 执行顺序：`WHERE > 聚合函数 > HAVING`。
* 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。

:::

##### 排序查询（ORDER BY）

```sql
-- 语法
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2, ...;
```

排序方式：`ASC`升序（默认）、`DESC`降序。

说明：**<font color="red">如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</font>**。

##### 分页查询（LIMIT）

**分页查询是数据库的方言**，不同数据库有不同实现，此处以MySQL为例：

```sql
-- 语法
SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;
```

* 起始索引从0开始，`起始索引 = (查询页码 - 1) * 每页显示记录数`。
* 如果查询的是第一页数据，起始索引可以省略，直接简写为`LIMIT 查询记录数`。

#### 2.4 数据控制（DCL）

数据控制语言，Data Control Language，用来管理数据库用户、控制数据库的访问权限。

关于数据控制语句，各个数据库有自己的用户管理策略，因此各个数据库的操作语句也各不相同，这类SQL开发人员操作比较少，主要是DBA（Database Administrator，即数据库管理员）使用。

### 3、函数

函数主要看各自数据库的实现。

### 4、约束

概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。用来保证数据库中数据的正确性、有效性和完整性。

分类：

|   约束   |                             描述                             |    关键字     |
| :------: | :----------------------------------------------------------: | :-----------: |
| 非空约束 |                   限制该字段的数据不能为空                   |  `NOT NULL`   |
| 唯一约束 |            保证该字段的所有数据都是唯一、不重复的            |   `UNIQUE`    |
| 主键约束 |           主键时一行数据的唯一标识，要求非空且唯一           | `PRIMARY KEY` |
| 默认约束 |        保存数据时，如果位置定该字段的值，则采用默认值        |   `DEFAULT`   |
| 检查约束 |                   保证字段值满足某一个条件                   |    `CHECK`    |
| 外键约束 | 用来让两张表的数据之间建立连接，保证功能数据的一致性和完整性 | `FOREIGN KEY` |

约束是用于表中字段上的，可以在创建/修改表的时候添加约束。

#### 4.1 基本使用

案例：根据需求完成表结构的创建。

| 字段名 |  字段含义  |  字段类型   |         约束条件          |          约束关键字           |
| :----: | :--------: | :---------: | :-----------------------: | :---------------------------: |
|   id   | ID唯一表示 |     int     |         自增主键          | `PRIMARY KEY, AUTO_INCREMENT` |
|  name  |    姓名    | varchar(10) |       不为空且唯一        |      `NOT NULL, UNIQUE`       |
|  age   |    年龄    |     int     |    大于0且小于等于120     |            `CHECK`            |
| status |    状态    |   char(1)   | 如果没有指定该值，默认为1 |           `DEFAULT`           |
| gender |    性别    |   char(1)   |            无             |                               |

```sql
CREATE TABLE `user`(
    id int PRIMARY KEY AUTO_INCREMENT COMMENT '自增主键', -- 此处以MySQL为例，自增逻辑各个数据库实现不一致
    name varchar(10) NOT NULL UNIQUE COMMENT '用户名',
    age int CHECK ( age > 0 && age <= 120 ) COMMENT '年龄，0～120',
    status char(1) DEFAULT '1' COMMENT '状态，默认为1',
    gender char(1) COMMENT '性别'
) COMMENT '用户表';
```

:::warning 注意

* 注意区分两张表的逻辑关联和外键关联。

:::

#### 4.2 外键约束

概念：用来让两张表的数据之间建立连接，保证功能数据的一致性和完整性。

```sql
-- 语法
CREATE TABLE 表名(
  字段名 数据类型,
  ...
  [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)
);
-- 修改时添加
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);

-- 删除外键
ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
```

#### 4.3 外键删除更新行为

删除/更新行为：

|     行为      |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
|  `NO ACTION`  | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与`RESTRICT`一致） |
|  `RESTRICT`   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与`NO ACTION`一致） |
|   `CASCADE`   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则同步删除/更新外键在子表中的记录。 |
|  `SET NULL`   | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键的值为`NULL`（这就要求该外键允许为空）。 |
| `SET DEFAULT` | 父表有变更时，子表将外键设置成一个默认的值（InnoDB不支持）。 |

```sql
-- 语法
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FROEIGN KEY(外键字段) REFERENCE 主表名(主表字段名) ON UPDATE 更新时的行为 ON DELETE 删除时的行为;
```

### 5、多表查询

#### 5.1 多表关系

#### 5.2 多表查询概述

#### 5.3 内连接

#### 5.4 外连接

#### 5.5 自连接

#### 5.6 子查询

#### 5.7 多表查询案例

## MySQL

### 1、语法差异

* 不区分大小写，但是关键字建议使用大写
* 单行注释可以使用“#”

#### 数据控制语句

##### 用户管理

```sql
# 查询用户
USE `mysql`;
SELECT * FROM `user`;

# 创建用户
CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
# 修改用户密码
ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';
# 删除用户
DROP USER '用户名'@'主机名';
```

`mysql.user`表中，`User`字段为用户名，`Host`字段为可远程访问数据库的IP地址，即上述语句中的`主机名`，`%`为全都可以访问。

##### 权限控制

MySQL中定义了多种权限，但是常用的权限就以下几种：

|          权限           |        说明        |
| :---------------------: | :----------------: |
| `ALL`, `ALL PRIVILEGES` |      所有权限      |
|        `SELECT`         |      查询数据      |
|        `INSERT`         |      插入数据      |
|        `UPDATE`         |      修改数据      |
|        `DELETE`         |      删除数据      |
|         `ALTER`         |       修改表       |
|         `DROP`          | 删除数据库/表/视图 |
|        `CREATE`         |   创建数据库/表    |

其他权限和含义参考[官方文档](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html)。

```sql
# 查询权限
SHOW GRANTS FOR '用户名'@'主机名';
# 授予权限
GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';
# 撤销权限
REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
```

* 多个权限之间，用都好分隔；
* 授权时，数据库名和表名可以用`*`进行通配，代表所有。

### 2、数据类型

<table style="text-align: center; vertical-align: middle;">
  <thead>
    <tr>
      <th colspan="6">MySQL数据类型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="10">数值类型</td>
    </tr>
    <tr>
      <td>类型</td>
      <td>大小</td>
      <td>有符号（SIGNED）范围</td>
      <td>无符号（UNSIGNED）范围</td>
      <td>描述</td>
    </tr>
    <tr>
      <td>TINYINT</td>
      <td>1 Byte</td>
      <td>[-128, 127]</td>
      <td>[0, 255]</td>
      <td>小整数值</td>
    </tr>
    <tr>
      <td>SMALLINT</td>
      <td>2 Byte</td>
      <td>[-32768, 32767]</td>
      <td>[0, 65535]</td>
      <td>大整数值</td>
    </tr>
    <tr>
      <td>MEDIUMINT</td>
      <td>3 Byte</td>
      <td>[-8388608, 8388607]</td>
      <td>[0, 16777215]</td>
      <td>大整数值</td>
    </tr>
    <tr>
      <td>INT或INTEGER</td>
      <td>4 Byte</td>
      <td>[-2147483648, 2147483647]</td>
      <td>[0, 4294967295]</td>
      <td>大整数值</td>
    </tr>
    <tr>
      <td>BIGINT</td>
      <td>8 Byte</td>
      <td>[-2<sup>63</sup>, 2<sup>63</sup>-1]</td>
      <td>[0, 2<sup>64</sup>-1]</td>
      <td>极大整数值</td>
    </tr>
    <tr>
      <td>FLOAT</td>
      <td>4 Byte</td>
      <td>[-3.402823466x10<sup>38</sup>, 3.402823466351x10<sup>38</sup>-1]</td>
      <td>0和[1.175494351x10<sup>-38</sup>, 3.402823466x10<sup>38</sup>-1]</td>
      <td>单精度浮点数值</td>
    </tr>
    <tr>
      <td>DOUBLE</td>
      <td>8 Byte</td>
      <td>[-1.7976931348623157x10<sup>308</sup>, 1.7976931348623157x10<sup>308</sup>-1]</td>
      <td>0和[2.2250738585072014x10<sup>-308</sup>, 1.7976931348623157x10<sup>308</sup>-1]</td>
      <td>双精度浮点数值</td>
    </tr>
    <tr>
      <td></td>
      <td>DECIMAL</td>
      <td>依赖于M（精度）和D（标度）的值</td>
      <td>依赖于M（精度）和D（标度）的值</td>
      <td>小数值（精确定点数）</td>
    </tr>
    <tr>
      <td rowspan="12">数值类型</td>
    </tr>
    <tr>
      <td>类型</td>
      <td>大小</td>
      <td colspan="3">描述</td>
    </tr>
    <tr>
      <td>CHAR</td>
      <td>0-255 Byte</td>
      <td colspan="3">定长字符串</td>
    </tr>
    <tr>
      <td>VARCHAR</td>
      <td>0-65535 Byte</td>
      <td colspan="3">变长字符串</td>
    </tr>
    <tr>
      <td>TINYBLOB</td>
      <td>0-255 Byte</td>
      <td colspan="3">不超过255个字符的二进制数据</td>
    </tr>
    <tr>
      <td>TINYTEXT</td>
      <td>0-255 Byte</td>
      <td colspan="3">短文本字符串</td>
    </tr>
    <tr>
      <td>BLOB</td>
      <td>0-65535 Byte</td>
      <td colspan="3">二进制形式的长文本数据</td>
    </tr>
    <tr>
      <td>TEXT</td>
      <td>0-65535 Byte</td>
      <td colspan="3">长文本数据</td>
    </tr>
    <tr>
      <td>MEDIUMBLOB</td>
      <td>0-16777215 Byte</td>
      <td colspan="3">二进制形式的中等长度文本数据</td>
    </tr>
    <tr>
      <td>MEDIUMTEXT</td>
      <td>0-16777215 Byte</td>
      <td colspan="3">中等长度文本数据</td>
    </tr>
    <tr>
      <td>LONGBLOB</td>
      <td>0-4294967295 Byte</td>
      <td colspan="3">二进制形式的极大文本数据</td>
    </tr>
    <tr>
      <td>LONGTEXT</td>
      <td>0-4294967295 Byte</td>
      <td colspan="3">极大文本数据</td>
    </tr>
    <tr>
      <td rowspan="7">日期时间类型</td>
    </tr>
    <tr>
      <td>类型</td>
      <td>大小</td>
      <td>范围</td>
      <td>格式</td>
      <td>描述</td>
    </tr>
    <tr>
      <td>DATE</td>
      <td>3 Byte</td>
      <td>1000-01-01 ~ 9999-12-31</td>
      <td>yyyy-MM-dd</td>
      <td>日期值</td>
    </tr>
    <tr>
      <td>TIME</td>
      <td>3 Byte</td>
      <td>-838:59:59 ~ 838:59:59</td>
      <td>HH:mm:ss</td>
      <td>时间值或持续时间</td>
    </tr>
    <tr>
      <td>YEAR</td>
      <td>1 Byte</td>
      <td>1901 ~ 2155</td>
      <td>yyyy</td>
      <td>年份值</td>
    </tr>
    <tr>
      <td>DATETIME</td>
      <td>8 Byte</td>
      <td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
      <td>yyyy-MM-dd HH:mm:ss</td>
      <td>日期时间值</td>
    </tr>
    <tr>
      <td>TIMESTAMP</td>
      <td>4 Byte</td>
      <td>1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC</td>
      <td>yyyy-MM-dd HH:mm:ss</td>
      <td>日期时间值，时间戳</td>
    </tr>
  </tbody>
</table>
### 3、内置函数

#### 3.1 字符串函数

MySQL中内置了很多字符串函数，常见的几个函数如下：

|             函数             |                           功能                            |
| :--------------------------: | :-------------------------------------------------------: |
|   `CONCAT(S1, S2,..., Sn)`   |              将多个字符串按照顺序拼接到一起               |
|         `LOWER(str)`         |                  将字符串str全部转为小写                  |
|         `UPPER(str)`         |                   将字符串全部转为大写                    |
|     `LPAD(str, n, pad)`      | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |
|     `RPAD(str, n, pad)`      | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 |
|         `TRIM(str)`          |                去掉字符串头部和尾部的空格                 |
| `SUBSTRING(str, start, len)` |        返回字符串str从str位置起的len个长度的字符串        |

#### 3.2 数值函数

常见的数值函数：

|     函数      |                功能                |
| :-----------: | :--------------------------------: |
|   `CEIL(x)`   |              向上取整              |
|  `FLOOR(x)`   |              向下取整              |
|  `MOD(x, y)`  |           取模$x\div y$            |
|   `RAND()`    |      返回`[0, 1)`内的随机整数      |
| `ROUND(x, y)` | 求参数x的四舍五入的值，保留y位小数 |

#### 3.3 日期函数

常见日期函数：

|                 函数                 |                             功能                             |
| :----------------------------------: | :----------------------------------------------------------: |
|             `CURDATE()`              |                         返回当前日期                         |
|             `CURTIME()`              |                         返回当前时间                         |
|               `NOW()`                |                      返回当前日期和时间                      |
|             `YEAR(date)`             |                    获取指定日期date的年份                    |
|            `MONTH(date)`             |                    获取指定日期date的月份                    |
|             `DAY(date)`              |                    获取指定日期date的日期                    |
| `DATE_ADD(date, INTERVAL expr type)` | 返回日期或时间值加上一个时间间隔expr后的时间值，type是时间单位 |
|       `DATEDIFF(date1, date2)`       |          返回起始时间date1和结束时间date2之间的天数          |

#### 3.4 流程函数

流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。

|                           函数                            |                        功能                         |
| :-------------------------------------------------------: | :-------------------------------------------------: |
|                     `IF(value, t, f)`                     |         如果value位true，则返回t，否则返回f         |
|                 `IFNULL(value1, value2)`                  |    如果value1不为空，返回value1，否则返回value2     |
|    `CASE WHEN [val1] THEN [res1]...ELSE [default] END`    |  如果val1为true，返回res1，……否则返回default默认值  |
| `CASE [expr] WHEN [val1] THEN [res1]...ELSE default] END` | 如果expr的值为val1，返回res1……否则返回default默认值 |

### 4、约束

检查约束需要8.0.16版本以后。

### 面试题

> MySQL索引高频考点解析。
>
> 问：什么是索引？为什么需要索引？
>
> 答：查字典的时候你是一页一页翻去找字还是先翻目录通过目录定位找到你想找的字呢？肯定是通过目录查啊，因为目录快啊。这里的目录其实就是一种索引，通过空间去换时间的一个思想，加快查询速度。那从数据库层面来说，索引就是一种能够快速查找的数据结构，能够加快SQL执行速度的。字典一页一页翻找的这种形式就是全表扫描，通过目录查数据就是索引查询，所以执行SQL肯定走索引快呀，全表扫描肯定慢啊。
>
> 问：如果让你设计，你觉得数据库用哪种数据结构做索引比较好？
>
> 答：常见的能快速搜索的数据结构有哈希表、二叉排序树、平衡二叉树、红黑树、B树、B+树等等。哈希表用唯一key去查对应的value，时间复杂度为O(1)，它很快，但是无法做范围查询，也没办法排序；二叉排序树左节点小于根，右节点大于根，中序遍历它就是有序的，所以它可以做排序，也可以范围查询，但是二叉排序树顺序插入的情况下，它会退化为链表，性能就会很差，那怎么办呢——平衡二叉树；平衡二叉树插入节点，使用旋转操作，让二叉树去保持平衡，左右子树的高度差不大于1，平衡二叉树能够避免极端情况下退化为链表，但是由于平衡二叉树它追求绝对完美的平衡，会导致频繁地左旋右旋去保持平衡，当它应用于数据库中，（数据库）插入删除的时候，频繁旋转就会带来大量的磁盘IO，降低性能，那再升级一下——红黑树；红黑树也是一种自平衡的二叉排序树，通过插入、删除数据的时候去变色、旋转让树保持平衡，但是红黑二叉树它不追求绝对的平衡，只要大致平衡就可以了，这就大大地降低了插入、删除需要的旋转操作，应用到数据库中就减少了磁盘IO，但是红黑二叉树它是一种二叉树，一个节点就只能有两个孩子（子节点），存储大量数据的时候，树高就会很高，排序树的查找性能和树高是直接相关的，这导致了存储大量数据的时候红黑树的查找性能其实没那么好，要多次磁盘IO，所以红黑树其实适合存储少量数据的内存操作，像Java的HashMap，当某个桶数据量超过阈值的时候，链表就会转化为红黑树，而当整个HashMap数据量比较多的时候，它也能平均分配到每个桶里面，每个桶都可以对应一个链表或二叉树，这样的话单个红黑树存储的数据也不会很多，而且纯内存操作也比较快。这个二叉树高度太高不行了，那有没有一种（解决）方法呢？可以用B树，B树是多路平衡排序树，一个节点它有N个孩子（子节点），数据量大的情况，树高也不会像红黑树那么高，但是B树的节点又存数据，又存索引值，就导致了B树的一个节点存不了多少索引，树高就会变得比较高，而且B树做范围查询的时候，它需要回溯整个树机构，效率比较低，会产生很多的随机IO，所以B树也不行，得上B+树；B+树也是这种多路平衡排序树，而且B+树的非叶子结点只存索引值，它不存数据，不存数据单个节点能存的索引值就变多，树的高度是更低的，查询性能就更好了，B+树的数据只存在于最下面的叶子节点，而且叶子节点由双向链表去连接，范围查询只需要遍历链表就可以了，不用回溯树结构，所以性能是更好的，所以像MySQL这种数据库，就会使用B+树来保存索引。
>
> 问：那B+树具体是怎么存储数据的呢？
>
> 答：MySQL索引从存储结构上划分主要有两种，聚集（簇）索引和非聚集（簇）索引。聚集索引就是索引和数据一块儿存，非聚集索引就是索引和数据分开存，例如主键索引就是聚集索引，非叶子结点都是索引值，然后叶子结点保存全部索引和对应的行数据，这里索引值就是ID对应的行数据，然后主键在B+树中，这也就决定了主键应该自增插入，因为如果不自增的话，它会导致页分裂带来的性能问题，像MySQL中的唯一索引、普通索引、前缀索引，它这种东西就是二级索引，或者叫非聚集索引，这种索引非叶子节点存储索引值，叶子结点去存储索引值和对应的主键ID，所以查询的时候，它需要现根据索引列查出对应的主键ID，然后再根据主键ID去查主键索引，然后查出对应的行数据，这也就是说为啥叫二级索引，因为它先查自己的索引树去查主键ID，然后再查主键的索引树，去查处行数据，这个过程叫回表，所以这里也可以看到回表会降低查询效率，**所以很多SQL优化其实就是要避免回表**。
>
> 问：那查二级索引一定会回表吗？
>
> 答：不一定，如果只查ID，二级索引树的叶子结点就有ID，所以就可以直接只查二级索引树，就没必要再回表查询了，这就提高了性能。当一个索引包含所有需要查询字段值的时候，那就可以不回表，这种情况叫覆盖索引，所以减少回表查询就是尽可能做到覆盖索引，如果一个索引列有多个字段，那就能大大增加覆盖索引的概率，这种索引就叫做联合索引。所谓联合索引就是针对表中的多个字段去创建索引。举个例子，你对姓名、年龄两个字段去建立联合索引，那索引列就是姓名和年龄，所以树的叶子结点还挂了ID，如果我去执行`SELECT id, 姓名, 年龄 where 姓名=xxx;`那就可以走联合索引，直接就能查到ID、姓名和年龄，就能避免回表提升性能，所以减少回表查询的方式之一就是去创建联合索引，然后尽可能的去避免使用`SELECT *`，因为它会查出所有列数据，就很容易触发回表。
>
> 问：你提到联合索引，那讲一下最左前缀匹配法则吧。
>
> 答：联合索引因为有多个索引列，所以排序的时候会根据索引列的顺序去排，查找的时候会根据索引列的顺序从左到右依次匹配。比如说，建立联合索引(a, b, c)，MySQL底层建立B+树的时候，会现根据a去排序，再根据b去排序，再根据c排序。所以查询的时候得先从a开始查，如果a不存在，那b、c就是乱序的，同样的，如果a、b不存在，c也一定是乱序的，它无法跳过前面的索引列去匹配，必须从左到右依次使用索引列去匹配。例如建立联合索引（a, b, c）查询的条件是`WHERE a=1 AND b=2`，显然会走索引，最左边的a、b都有；查询条件为`WHERE b=2 AND a=1`也会走索引，只要有a有b就可以，书写顺序无所谓，MySQL的优化器它会自动把索引列重排序；查询条件为`WHERE a=1 AND c=2`会走索引吗？它会走部分索引，a会走索引，c部分无法走索引，因为按照索引顺序，c的左边是b，查询部分没有b，那c就无法走索引了，在无法保证a、b有序的情况下，c就是乱序的；查询条件为`WHERE b=1 AND c=2`会走索引吗？完全不会，因为a在最左边，b、c的有序是建立在a上的，a缺失的情况下，b、c就无法保证有序了。
>
> 问：那讲一下其他索引失效的场景。
>
> 答：比如说模糊查询场景中，`WHERE name LIKE '王%';`，这种百分号在后面的尾部模糊，索引是生效的，因为索引从左往右的那个“王”是存在的，可以根据“王”去匹配，`WHERE name LIKE '%王';`头部模糊了，索引就失效了，从左往右匹配，左边没有数据，没有办法搜索匹配。索引列运算的时候或者函数运算的时候也会让索引失效，因为B+树存的就是索引值，你一计算，一使用函数，那就无法确定B+树位置了。在去做隐式类型转换的时候，也会让索引失效，因为隐式类型转换就会触发cast函数，去做转化，就调用函数了。再比如用`OR`的时候出现了非索引列，那就没办法走索引了，因为不可能同时做索引扫描和全表扫描啊，所以就直接退化成全表扫描。
>
> 问：索引这么快，全加索引行不行？
>
> 答：索引呢就像是字典里面的目录，如果加了过多的索引，那目录就会越来越多了，占用的空间就会越来越大，如果目录占用的空间都赶上正文了，那还要正文干嘛呢。所以索引并不是越多越好，而且索引会降低增删改的性能，因为你增删改数据的同时要更新对应的索引，所以索引肯定不是越多越好，也不是万能的。
>
> 问：应该怎么加索引比较好？
>
> 答：数据量比较大的、查询频繁的就是和加索引，经常`WHERE`、`GROUP BY`、`ORDER BY`的列适合建索引，增删改频繁的就不适合加索引了；对于区分度比较高的列，也比较适合做索引，例如身份证号这种；像性别、枚举这种区分度很低的就不适合加索引，整个B+树，全是一边男，一边女，加了索引也提高不了效率；对于比较长的字符串，可以使用前缀索引，然后要尽量的多用联合索引，而不用单例索引，因为联合索引很多时候可以覆盖索引，避免回表提升效率；**注意一张表的索引不要太多，最多不要超过5个**，不然会大大降低插入和删除的效率。
>
> 问：那怎么知道要不要加索引呢？怎么判断一个SQL是否走了索引？
>
> 答：可以打开MySQL慢查询日志，慢查询日志记录了执行时间超过阈值的所有查询语句，这样就找到慢SQL了，然后可以使用`EXPLAIN`执行计划去对慢SQL进行分析查询是否走了索引，走了什么索引，然后针对性的做优化就可以了。

## SQLite

