---
title: 23种设计模式
createTime: 2025/07/07 09:30:40
tags:
  - 设计模式
  - 23 GoF
---

# 23设计模式

设计模式（Design Patterns）由“四人帮”（GoF，Gang of Four）在1994年的著作《设计模式：可复用面向对象软件的基础》中系统总结为23种，分为三大类：**创建型模式**（5种）、**结构型模式**（7种）和**行为型模式**（11种）：

* 创建模式
  
  关注对象的创建机制，**解耦实例化过程，提升灵活性和可扩展性**。
  
  |   模式名称   |                  核心作用                  |                 典型应用场景                  |
  | :----------: | :----------------------------------------: | :-------------------------------------------: |
  |   单例模式   |  确保一个类仅有一个实例，并提供全局访问点  |           数据库连接池、日志管理器            |
  | 工厂方法模式 |  由子类决定实例化哪个类，延迟实例化到子类  |     框架中的对象创建（如Spring Bean工厂）     |
  | 抽象工厂模式 |  创建相关或依赖对象的家族，无需指定具体类  | 跨平台UI组件库（如不同操作系统的按钮/文本框） |
  |  建造者模式  |  分离复杂对象的构建与表示，支持分步骤构建  |   构建复杂对象（如HTML文档生成、订单系统）    |
  |   原型模式   | 通过复制现有对象创建新对象，避免重复初始化 |       游戏角色复制、高性能对象创建场景        |
  
* 结构模式
  
  关注类和对象的组合方式，**优化代码结构并提升复用性**。
  
  |  模式名称  |                       核心作用                        |                典型应用场景                |
  | :--------: | :---------------------------------------------------: | :----------------------------------------: |
  | 适配器模式 |             转换接口使不兼容的类协同工作              |        整合旧系统接口、第三方库兼容        |
  |  桥接模式  |           分离抽象与实现，允许两者独立变化            | 多维度变化的系统（如不同形状和颜色的图形） |
  |  组合模式  | 以树形结构处理“部分-整体”关系，统一对待单个对象和组合 |   文件系统、UI组件树（如菜单嵌套子菜单）   |
  | 装饰器模式 |            动态添加职责，无需修改原有代码             |     Java I/O流（如BufferedInpuStream）     |
  |  外观模式  |          为复杂子系统提供统一接口，简化调用           |           整合支付系统、API网关            |
  |  享元模式  |             共享细粒度对象以减少内存占用              |  文本编辑器中的文字字符对象、游戏粒子系统  |
  |  代理模式  |   控制对象访问，提供间接层（如延迟加载、权限控制）    |          卢骈懒加载、远程服务代理          |
  
* 行为模式
  
  关注对象间通信与职责分配，**优化协作流程**。
  
  |   模式名称   |                核心作用                |               典型应用场景                |
  | :----------: | :------------------------------------: | :---------------------------------------: |
  |  责任链模式  |      沿处理链传递请求，直至被处理      |           审批流程、异常处理链            |
  |   命令对象   | 将请求封装为对象，支持撤销、队列等操作 |           任务队列、GUI按钮事件           |
  |  解释器模式  |         定义语言语法并解释执行         |      编译器、规则引擎（如SQL解释器）      |
  |  迭代器模式  |    提供统一方法顺序访问聚合对象元素    |       集合遍历（如Java的Iterator）        |
  |  中介者模式  |      封装对象间交互，减少直接耦合      |             聊天室、事件总线              |
  |  备忘录模式  |      捕获并保存对象状态，支持回滚      |            撤销操作、游戏存档             |
  |  观察者模式  |   定义一对多依赖，状态变更时自动通知   |        事件监听系统（如消息推送）         |
  |   状态模式   |    允许对象在内部状态改变时改变行为    | 订单状态机（待支付/已发货）、游戏角色行为 |
  |   策略模式   |         封装算法族，使其可互换         |        排序算法选择、支付方式切换         |
  | 模板方法模式 |     定义算法骨架，子类重写特定步骤     |      框架狗子方法（如Spring初始化）       |
  |  访问者模式  |      在不修改类的前提下添加新操作      |        编译器语法树分析、报表生成         |

## 0、设计模式的七大原则

面向对象或者编程过程中有七大基本原则：

* 开闭原则（Open Closed Principle，OCP），软件实体（类、模块、函数等）因该对扩展开放，对修改关闭。
* 单一职责原则（Single Responsibility Principle，SRP），一个类或模块应该有且只有一个引起它变化的原因，即一个类只负责一项功能，这样可以降低类之间的耦合度，提高代码的可维护性和可复用性。
* 里氏代换原则（Liskov Substitution Principle，LSP），子类必须能替换其基（父）类，并且不应该改变原有程序的正确性，即子类应该可以无缝替换父类，而不会导致程序出现错误。这个原则强调了继承的正确使用，避免滥用继承导致的问题。
* 依赖倒置原则（Dependency Inversion Principle，DIP），高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。这个原则鼓励使用接口和抽象类，降低模块之间的耦合度，提高代码的灵活性和可测试性。
* 接口隔离原则（Interface Segregation Principle，ISP），客户端不应该被迫依赖于它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。这个原则鼓励将大接口拆分成更小的、更具体的接口，避免客户端依赖不需要的方法。
* 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP），有线使用对象组合/聚合而不是继承来达到复用。组合/聚合可以更灵活地实现服用，而继承可能会导致“继承爆炸“和”脆弱性“。
* 最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LoD），一个对象应该对其他对象有尽可能少的了解。简言之，一个类/方法等直接关联的参数、属性、返回值以外的其他对象尽可能少的产生关联。这个原则旨在降低类之间的耦合度，提高代码的内聚性。

## 1、单例模式（Singleton)

总共有8种写法（以Java为例）：

* 饿汉式（hungry loading）：将构造器方法设置为私有，并在类内部使用静态常量创建该类实例之后提供统一的访问方法返回该实例，类加载到内存后，只实例化一个单例，JVM确保所有线程访问到的都是同一个资源，线程安全，缺点是不管使用与否，类装载时就会完成实例化。

  ```java
  public class SingletonDemo {
      private static final SingletonDemo INSTANCE = new SingletonDemo();
  
      private SingletonDemo() {};
  
      public static SingletonDemo getInstance() {
          return INSTANCE;
      }
  }
  ```

* 跟上一种写法没区别，只是将`new SingletonDemo()`这一步骤放到静态代码块中。

* 懒汉式（lazy loading）：当需要用到实例时采取创建实例，之后都返回第一次创建的实例，虽然节省了资源，但是一旦创建期间有其他线程同时访问这个实例，将导致线程安全问题（例如下列代码中创建耗时至少1ms，这期间可能会有其他线程也访问这个实例），却导致了线程不安全。

  ```java
  class SingletonDemo {
      private static SingletonDemo INSTANCE;
  
      private SingletonDemo() {}
  
      public static SingletonDemo getInstance() {
          if (INSTANCE == null) {
              try {
                  Thread.sleep(1);
              } catch (Exception e) {
                  e.printStackTrace();
              }
              INSTANCE = new SingletonDemo();
          }
          return INSTANCE;
      }
  }
  
  @Test
  public void test(){
      for (int i = 0; i < 10; i++) {
          new Thread(() -> {
              System.out.println(SingletonDemo.getInstance().hashCode());
          }).start();
      }
  }
  /* 运行结果（每一次的hashCode都不一样）：
  999561843
  350209186
  860237855
  1266044030
  879210736
  406090928
  3751867
  962939428
  320039746
  1565079402
  */
  ```

* 懒汉式（lazy loading）：通过上锁解决线程问题，但是带来了效率下降

  ```java
  public class SingletonDemo {
      private static SingletonDemo INSTANCE;
  
      private SingletonDemo() {}
  
      public static synchronized SingletonDemo getInstance() {
          if (INSTANCE == null) {
              try {
                  Thread.sleep(1);
              } catch (Exception e) {
                  e.printStackTrace();
              }
              INSTANCE = new SingletonDemo();
          }
          return INSTANCE;
      }
  }
  
  @Test
  public void test(){
      for (int i = 0; i < 10; i++) {
          new Thread(() -> {
              System.out.println(SingletonDemo.getInstance().hashCode());
          }).start();
      }
  }
  /* 运行结果：
  1542737733
  1542737733
  1542737733
  1542737733
  1542737733
  1542737733
  1542737733
  1542737733
  1542737733
  1542737733
  */
  ```

* 懒汉式：注意解决懒汉式时候的减小同步代码块陷阱，该方式不能解决线程问题，因为有可能同时有多个线程运行到进入if判断这一步。

  ```java
  public static SingletonDemo getInstance() {
      if (INSTANCE == null) {
          synchronized (SingletonDemo.class) {
              try {
                  Thread.sleep(1);
              } catch (Exception e) {
                  e.printStackTrace();
              }
              INSTANCE = new SingletonDemo();
          }
      }
      return INSTANCE;
  }
  ```

* 懒汉式：双重检查单例，即进入同步代码块后再判一次空。

  ```java
  public static SingletonDemo getInstance() {
      if (INSTANCE == null) {
          synchronized (SingletonDemo.class) {
              // 双重检查
              if (INSTANCE == null) {
                  try {
                      Thread.sleep(1);
                  } catch (Exception e) {
                      e.printStackTrace();
                  }
                  INSTANCE = new SingletonDemo();
              }
          }
      }
  }
  /* 运行结果：
  1160871228
  1160871228
  1160871228
  1160871228
  1160871228
  1160871228
  1160871228
  1160871228
  1160871228
  1160871228
  */
  ```

  此方法虽然能够完满解决懒汉式线程问题，但是实际使用中复杂化了逻辑，一般不怎么使用，主要是饿汉式写法占用的资源只要不是特别大，那么这种写法就没有必要，并且即使是这样的写法，最终只要用上了这个实例，它还是会始终存在内存中，但是却还要增加维护负担，故一般不采用。

* 懒汉式：静态内部类方式实现，当加载外部类时不会加载内部类，这样可以实现懒加载。

  ```java
  public class SingletonDemo {
      private SingletonDemo() {}
  
      private static class SingletonHolder {
          private static final SingletonDemo INSTANCE = new SingletonDemo();
      }
  
      // 当调用此方法时，SingletonHolder才会加载
      public static SingletonDemo getInstance() {
          return SingletonHolder.INSTANCE;
      }
  }
  ```

  这种方式算是最为完满的方法了。

* 枚举实现单例（《Effective Java》中推荐的方式），使用枚举实现单例，不仅可以解决线程同步问题，还能防止反序列化。

  ```java
  public enum SingletonDemo {
      INSTANCE;
  }
  ```

总结：常规的工作流程中，使用最为广泛的还是饿汉式，如无必要，尽量避免复杂化项目结构与开发流程。同时，如果真要考虑资源消耗问题而使用懒加载，则可以考虑使用静态内部类方式。最为完满的方式则为枚举。

Java开发中，单例模式大多数时候使用都是通过Spring的Bean工厂来保证单例，自己写的情况较少。

## 2、策略模式（Strategy）

以`java.lang.Comparable`和`java.util.Comparator`两个接口为例，当使用`Comparable`时，要求待比较对象实现接口，对代码的侵入性太强，且无法扩展，不符合**开闭原则**，之后设计了`Comparator`接口，将比较操作与待比较对象分离，例如排序时，当需要对对象换一个维度排序，只需要重新定义一个`Comparator`，在比较器中定义排序规则，然后将待比较数据和比较器一起传给排序函数，即可实现新的排序维度。`Comparator`一方面将比较操作与原对象解耦，另一方面增加了排序的可扩展性，这样将可变部分交给调用方的设计模式即为策略模式。

```java
@Test
public void test() {
    String[] arr = {"a🥱🥱bc", "def", "gdfafdahi", "j341kl", "mno", "🤡🤡🤡"};
    Comparator<String> lengthComparator = Comparator.comparingInt(String::length);
    Comparator<String> byteComparator = Comparator.comparingInt(str -> str.getBytes().length);
    System.out.println("原数组：" + Arrays.toString(arr));
    Arrays.sort(arr, lengthComparator);
    System.out.println("字符长度排序：" + Arrays.toString(arr));
    Arrays.sort(arr, byteComparator);
    System.out.println("字节长度排序：" + Arrays.toString(arr));
}
```

> 运行结果：
>
> 原数组：[a🥱🥱bc, def, gdfafdahi, j341kl, mno, 🤡🤡🤡]
> 字符长度排序：[def, mno, j341kl, 🤡🤡🤡, a🥱🥱bc, gdfafdahi]
> 字节长度排序：[def, mno, j341kl, gdfafdahi, a🥱🥱bc, 🤡🤡🤡]

## 3、工厂模式（Factory）

任何可以产生对象的方法或类都可以称之为工厂，单例也是一种工厂。

为什么有了new关键字以后还要有工厂？

* 灵活控制生产过程
* 权限、修饰、日志

### 3.1 简单工厂（静态工厂）

简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory  Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

简单工厂模式包含以下三个角色：

- Factory：工厂角色，工厂角色负责实现创建所有实例的内部逻辑。
- Product：抽象产品角色，抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口。
- ConcreteProduct：具体产品角色，具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

#### 应用案例解析
例如一个Java软件系统，可以提供多个不同的提示信息打印对象，这些打印对象都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得对象打印处不同的效果，如果希望在使用这些提示信息打印对象时不需要知道具体的类名，只需要知道该类的一个参数，并提供一个调用的方法，把该参数传入方法即可返回一个相应的提示信息打印对象，此时就可以使用简单工厂模式。

 实现步骤：

1. 定义基类

   ```java
   package com.triabin.ideasy_server.design_ptn_demo;
   
   import lombok.AllArgsConstructor;
   import lombok.Getter;
   import lombok.Setter;
   
   /**
    * 类描述：控制台信息打印基类
    *
    * @author Triabin
    * @date 2025-07-28 16:33:46
    */
   @Getter
   @Setter
   @AllArgsConstructor
   public abstract class Msg {
       /**
        * 字体颜色
        */
       private String fontColor;
   
       /**
        * 信息内容
        */
       private String msg;
   
       /**
        * 打印信息
        */
       public void print() {
           if (fontColor == null || fontColor.isEmpty()) {
               System.out.println(msg);
           } else {
               System.out.println(fontColor + msg + "\u001B[0m");
           }
       }
   }
   ```

2. 根据需求分别继承基类实现子类

   ```java
   package com.triabin.ideasy_server.design_ptn_demo;
   
   /**
    * 类描述：普通信息打印对象
    *
    * @author Triabin
    * @date 2025-07-28 16:54:01
    */
   public class InfoMsg extends Msg{
       public InfoMsg(String msg) {
           super("\u001B[34m", msg);
       }
   }
   ```

   ```java
   package com.triabin.ideasy_server.design_ptn_demo;
   
   /**
    * 类描述：成功信息打印对象
    *
    * @author Triabin
    * @date 2025-07-28 16:38:15
    */
   public class SuccessMsg extends Msg {
   
       public SuccessMsg(String msg) {
           super("\u001B[32m", msg);
       }
   }
   ```

   ```java
   package com.triabin.ideasy_server.design_ptn_demo;
   
   /**
    * 类描述：告警信息打印对象
    *
    * @author Triabin
    * @date 2025-07-28 16:52:47
    */
   public class WarningMsg extends Msg{
       public WarningMsg(String msg) {
           super("\u001B[33m", msg);
       }
   }
   ```

   ```java
   package com.triabin.ideasy_server.design_ptn_demo;
   
   /**
    * 类描述：告警信息打印对象
    *
    * @author Triabin
    * @date 2025-07-28 16:52:47
    */
   public class WarningMsg extends Msg{
       public WarningMsg(String msg) {
           super("\u001B[33m", msg);
       }
   }
   ```

3. 定义工厂类

   ```java
   package com.triabin.ideasy_server.design_ptn_demo;
   
   /**
    * 类描述：提示信息打印对象工厂
    *
    * @author Triabin
    * @date 2025-07-28 16:55:13
    */
   public class MsgPrinterFactory {
   
       public static Msg create(MsgType type, String msg) {
           System.out.println("线程" + Thread.currentThread().getName() + "创建了" + type + "类型的提示信息：" + msg);
           return switch (type) {
               case INFO -> new InfoMsg(msg);
               case SUCCESS -> new SuccessMsg(msg);
               case WARNING -> new WarningMsg(msg);
               case ERROR -> new ErrorMsg(msg);
           };
       }
   }
   ```

   ```java
   package com.triabin.ideasy_server.design_ptn_demo;
   
   /**
    * 类描述：信息打印类别
    *
    * @author Triabin
    * @date 2025-07-28 16:34:31
    */
   public enum MsgType {
       INFO,
       SUCCESS,
       WARNING,
       ERROR
   }
   ```

4. 演示

   ```java
   package com.triabin.ideasy_server.design_ptn_demo;
   
   /**
    * 类描述：样例演示类
    *
    * @author Triabin
    * @date 2025-07-28 16:58:10
    */
   public class Demo {
       public static void main(String[] args) {
   
           Msg info = MsgPrinterFactory.create(MsgType.INFO, "普通提示信息");
           Msg success = MsgPrinterFactory.create(MsgType.SUCCESS, "成功提示信息");
           Msg warning = MsgPrinterFactory.create(MsgType.WARNING, "警告提示信息");
           Msg error = MsgPrinterFactory.create(MsgType.ERROR, "错误提示信息");
   
           info.print();
           success.print();
           warning.print();
           error.print();
       }
   }
   ```

   演示效果：

   **![image-20250728171054298](/images/image-20250728171054298.png)**

5. 总结：通过以上案例可知，在定义工厂方法的时候，还可以为每一个通过工厂创建的类统一添加一些额外操作，例如上述案例中的打印线程信息日志，如果去需要去记住各种颜色的值（`31m`、`32m`等），无疑会增加记忆负担，增加犯错的概率，且这种值只在需要的时候查询一下就好了，所以封装以后只需要关注打印信息的内容和类别即可，而类别再通过枚举限定后，代码编辑器可以自动识别然后通过枚举名称见名知意即可。这样就统一固定了类的创建流程，后续扩展的话只需要添加继承基类的子类和枚举对象即可，不必重复编写/修改创建流程的代码。

#### 优劣分析

- 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
- 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。（Spring）
- 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的（例如上述案例中需要在工厂创建逻辑中添加枚举类型的判断）。
- 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

#### 总结

- 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。
- 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
- 简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
- 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。
- 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。
- 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。

> 模式在实际产品中的应用：
>
> 1. JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。
>
>    ```java
>    public final static DateFormat getDateInstance();
>    public final static DateFormat getDateInstance(int style);
>    public final static DateFormat getDateInstance(int style,Locale locale);
>    ```
>
> 2. Java加密技术。
>
>    ```java
>    // 获取不同加密算法的密钥生成器
>    KeyGenerator keyGen=KeyGenerator.getInstance("DESede");
>    // 创建加密器
>    Cipher cp=Cipher.getInstance("DESede");
>    ```

### 3.2 工厂方法模式

### 3.3 抽象工厂模式

### SpringIOC

## 4、代理模式

## 5、备忘录模式

## 6、迭代器模式

## 7、访问者模式

## 8、观察者模式

## 9、解释器模式

## 10、命令模式

## 11、模板方法模式

## 12、桥接模式

## 13、适配器模式

## 14、外观模式

## 15、享元模式

## 16、原型模式

## 17、责任链模式

## 18、中介者模式

## 19、装饰模式

## 20、状态模式

## 21、组合模式
