---
title: Java基础
order: 2
---

# Java基础

> 带\*号的章节不重要

## 1、Java基础概念

### 1.1 注释

单行注释：`// 单行注释信息`

多行注释：`/* 多行注释信息 */`

文档注释：`/** 文档注释信息 */`

> 说明
>
> 注释内容不会参与编译和运行，仅仅是对代码的解释说明。
>
> 不管是单行注释还是多行注释，在书写的时候都不要嵌套。
>

### 1.2 关键字

关键字：被Java赋予特定含义的英文单词。

关键字特性：

* 关键字的字母全部小写
* 常用代码编辑器针对关键字有特殊的颜色标记，非常直观

> Java中大约有50多个关键字，不必刻意记忆，见官网：[Oracle官网](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)

常见关键字：

* `class`：用于创建/定义一个类，类是Java最基本的组成单元。

### 1.3 字面量

字面量用于告诉程序员数据在程序中的书写格式。

在代码中，一般会书写一下六种字面量：

| 字面量类型 |                   说明                   |            举例             |
| :--------: | :--------------------------------------: | :-------------------------: |
|  整数类型  |             不带小数点的数字             |        `666`，`-88`         |
|  小数类型  |              带小数点的数字              |      `13.14`，`-5.21`       |
| 字符串类型 |           用双引号括起来的内容           | `HelloJava`，`new一个对象`  |
|  字符类型  | 用单引号括起来的内容，内容只能有一个字符 |    `'A'`、`'0'`、`'我'`     |
|  布尔类型  |             布尔值，标识真假             | 只有两个值：`true`、`false` |
|   空类型   |            一个特殊的值，空值            |           `null`            |

用例：

```java
public class ValueDemo {
    public static void main(Stringp[] args) {
        // 整数
        System.out.println(121);
        System.out.println(-33);
      
        // 小数
        System.out.println(3.14);
        System.out.println(-6.98);
      
        // 字符串
        System.out.println("str");
        System.out.println("字符串");
      
        // 布尔
        System.out.println(true);
        System.out.println(false);
      
        // 空
        System.out.println(null);
    }
}
```

**特殊字符类型的字面量：**

* `\t`：制表符，在打印的时候，把前面字符串的长度补齐到8或8的整数倍。最少补一个空格，最多补8个空格。

  ```java
  public class Demo {
    public static void main(String[] args) {
      // 不用制表符的版本全都拼接在一起
      System.out.println("name" + "age");
      System.out.println("tom" + 23);
      
      // 使用制表符后自动对齐
      System.out.println("name" + '\t' + "age");
      System.out.println("tom\t23");
    }
  }
  ```

* `\n`：换行符略

### 1.4 变量

变量：在程序中存储数据的标识。

变量定义：`数据类型 变量名 = 数据值;`

* 数据类型：为存储数据的（内存）空间中存储的数据添加的类型限制（整数、小数、字符串等）。
* 变量名：为存储数据的空间起的名字（标识）。
* `=`：赋值符号，标识将右侧的字面量值赋给左侧的变量名所对应的内存空间。
* 数据值：存储在内存空间中的值。

变量的基本用法：

* 输出打印

  ```java
  int a = 10;
  System.out.println(a); // 10
  ```

* 参与计算

  ```java
  int a = 10;
  int b = 20;
  System.out.println(a + b);
  ```

* 修改记录的值

  ```java
  int a = 10;
  System.out.println("修改前变量a = " + a);
  a = 20;
  System.out.println("修改后变量a = " + a);
  ```

变量使用的注意事项：

* 只能存一个值

* 变量名不允许重复定义

* 一条语句可以定义多个变量（逗号隔开即可）

  ```java
  int a = 1, b = 2, c = 3, d = 4;
  ```

* 变量在使用之前一定要进行赋值

* 变量的作用域范围

### 1.5  数据类型

**基本数据类型：** 分为4类8种

* 整数

  ① byte：内存占用1个字节，即8个比特位，取一位作为符号位，其取值范围为`-128~127`，多用它的数组来存取流转文件内容。

  ② short：内存占用2个字节，去一位作为符号位，其取值范围为`-32768~32767`。

  ③ int：整数字面量的默认类型，内存占用4个字节，取值范围为`-2147483648~2147483647`。

  ④ long：内存占用8个字节，取值范围：`-9223372036854775808~9223372036854775807`，定义字面量时需要在字面量后面加一个`L`或`l`，但是一般建议使用大写的`L`，因为小写的`l`辨识度没有大写的高。

* 浮点数

  ① float：内存占用4个字节，共计32个比特位，第一位用来表示符号位；2\~9位为指数（阶码）；10\~32位为有效数字（尾数）。所以它的取值范围为`-3.401298e-38~3.402823e+38`。定义float字面量时也需要在末尾加一个`F`或`f`，一般建议使用大写。

  （TODO：关于浮点数的存储原理，还需另做文章解读）

  ② double：浮点数字面量的默认类型，内存占用8个字节，`-4.9000000e-324~1.797693e+308`。

* 字符：char，内存占用2个字节，取值范围为`0~65535`，字面量为单个字符，使用单引号括起来。

* 布尔：boolean，内存占用1个字节，值为`true`、`false`。

**引用数据类型**：数组、字符串、其他对象。

### 1.6 标识符

标识符：给类、方法、变量等取的名字。

命名规则：

* 由数字、字母、下划线和美元符号组成；
* 不能以数字开头
* 不能是关键字
* 区分大小写

命名规范：

* 方法和变量使用小驼峰命名法，即第一个单词首字母小写，其余大写；
* 类名使用大驼峰命名法，即每个单词首字母大写；
* 尽可能的见名知意

:::warning 注意

① 下划线开头的标识符：在早期代码中，有时用 `_`开头表示“私有”或“内部”成员（如 `_count`），但这不是强制规范，Oracle 官方编码规范不鼓励使用下划线开头，并且Java 9+ 中，单独的下划线 `_`是关键字（受限标识符），不能作为变量名；

② 美元符号开头的标识符：$常见于编译器自动生成的类或变量名（反编译class文件后可见），手动编写的代码中要尽可能的避免，以免与编译器生成的名称冲突。

:::

### 1.7 键盘录入\*

*观前提醒：常规开发工作过程中，这玩意儿几乎用不到，常见于公司内部自己写的命令行小工具，极少使用，常规上线的大型项目中我从来没见过使用。*

Java自带了`java.util.Scanner`类，用于处理键盘的输入。

```java
import java.util.Scanner;

public class Demo {
  Scanner sc = new Scanner(System.in);
  
  int input = sc.nextInt(); // 接收int型的数据，其他数据类型同理
  
  System.out.println("输入内容：" + input);
}
```

## 2、运算符

运算符和表达式：对字面量或者变量进行操作的符号即为运算符；用运算符把字面量或者变量连接起来，符合Java语法的式子就可以称为表达式。不同运算符连接的表达式体现的是不同类型的表达式。

### 2.1 算数运算符

加`+`、减`-`、乘`*`、除`/`、取模（余）`%`（运算符作用略或参见小学数学🐶）

在代码中，如果有小数参与计算，计算结果有可能不精确，所以在银行项目中涉及到小数点后几位一般要么用要么用BigDecimal对象，要么小数点后的位数用int手动计算。(TODO: 关于编程中小数不精确问题解析)

在除法运算中，如果除数和被除数都是整数，那么运算结果也会被作为整形（截取），除数和被除数任意一个如果是浮点类型，则计算结果自动四舍五入（或不精确）。

关于取模（余）运算，一般用于判断是否整除（余数为0），是否为偶数（能被2整除），以及范围内循环等。

`+`运算符的三种情况：

* 数字相加：数值相加

  隐式转换：又叫自动类型提升，取值范围小的数值转为取值范围大的数值。例如，在加法运算中，其中一个加数为double类型，其余为int，则相加结果为double类型，隐式转换不需要写额外的代码。

  * 取值范围从小到大：`byte < short < int < long < float < double`

  * 隐式转换的两种提升规则：一是取值范围小的和取值范围大的进行运算，晓得会先提升为大的，再进行计算；二是`byte`、`short`、`char`三种类型的数据在运算的时候，都会直接先提升为`int`，然后再进行计算（即使进行计算的两个数都是同一种数据类型，只要进行加法运算了，最终结果都是`int`类型）。

  强制转换：取值范围大的数值转为取值范围小的数值。如果把一个取值范围大的数值赋值给一个取值范围小的变量，是不允许赋值的，如果一定要赋值，那么就需要加入强制转换，强制转换需要手动编写代码声明。

  * 格式：`目标数据类型 变量名 = (目标数据类型) 被强转的数据（可以是变量名和字面量）;`
  * 强制转换可能会导致数据发生错误，例如将128转为`byte`类型，这超出了它的取值范围，就会导致出现错误。

* 字符串相加：如果`+`操作中出现字符串，此时这个`+`号就是字符串连接符，而不是运算符了，它会将前后的数据进行拼接并产生一个新的字符串。当然，如果是多个数字和字符串混合，则由是从左道友两个两个进行运算，所以在遇到字符串之前的数字都是进行正常的数值运算，遇到字符串之后的则全都是拼接。

* 字符相加：当`字符+字符`或`字符+数字`时，会将字符通过ASCII码查询到相应的数字之后再进行计算，如果是非ASCII字符，则使用期Unicode码点的值进行计算（例如`'中'`的码点为20013）。

> 练习题：键盘录入一个三位数，将其拆分为个位、十位、百位，然后分别打印在控制台。
>
> 题解：$位值 = 输入值 \div 所在位基础值 \bmod 10$
>
> 例如，
>
> $123_{个位} = 123 \div 1 \bmod 10 = 3$
>
> $123_{十位} = 123 \div 10 \bmod 10 = 2$（Java中的整数除法会被截取整形）
>
> $123_{百位} = 123 \div 100 \bmod 10 = 1$

### 2.2 自增/减运算符

自增运算符`++`：可以卸载变量的前面或者后面，作用是变量值+1。

* 写在后面：先使用变量，然后再给变量加一，例如`int a = 1;`那么`1 + a++`的运算结果为2，但是运算结束后a的值为2。
* 写在后面：与写在前面相反，上述示例中，如果是`1 + ++a`，则运算结果为3，运算结束后a的值为2。

无论是写在前面还是写在后面，单独使用的话，都没有区别；自增和自减多用于循环中。

### 2.3 赋值运算符

| 符号 |    作用    |              说明              |
| :--: | :--------: | :----------------------------: |
| `=`  |    赋值    | `int a = 10;`，将10赋值为变量a |
| `+=` |  加后赋值  |    `a += b; => a = a + b;`     |
| `-=` |  减后赋值  |    `a -= b; => a = a - b;`     |
| `*=` |  乘后赋值  |    `a *= b; => a = a * b;`     |
| `/=` |  除后赋值  |    `a /= b; => a = a / b;`     |
| `%=` | 取余后赋值 |    `a %= b; => a = a % b;`     |

`+=`、`-=`、`*=`、`/=`、`%=`底层都隐含了一个强制类型转换：

```java
public class Demo {
  public static void main(String[] args) {
    short s = 1;
    s += 1; // 运算结果的类型还是short，不是int，等同于s = (short) (s + 1);
    System.out.println(s);
  }
}
```

### 2.4 关系运算符

关系（比较）运算符的分类：

| 符号 |                             说明                             |
| :--: | :----------------------------------------------------------: |
| `==` |  `a == b`，判断a与b是否相等，成立为`true`，不成立为`false`   |
| `!=` | `a != b`，判断a与b是否不相等，成立为`true`，不成立为`false`  |
| `>`  |    `a > b`，判断a是否大于b，成立为`true`，不成立为`false`    |
| `>=` | `a >= b`，判断a是否大于或等于b，成立为`true`，不成立为`false` |
| `<`  |    `a < b`，判断a是否小于b，成立为`true`，不成立为`false`    |
| `<=` | `a <= b`，判断a是否小于或等于b，成立为`true`，不成立为`false` |

关系运算符的结构式boolean型。

### 2.5 逻辑运算符

在数学中，一个数据x，大于5，小于15，可以表示为：`5 < x < 15`，但是在Java中，需要将该式子进行拆解再进行合并表达：

* 拆解为：`x > 5`和`x < 15`
* 合并为：`x > 5 & x < 5`

| 符号 |     作用     |                             说明                             |
| :--: | :----------: | :----------------------------------------------------------: |
| `&`  | 逻辑与（且） |       并且，符号前后表达式/值为`true`，结果才是`true`        |
| `&&` |    短路与    | 如果符号前面的表达式运算结果/值为`false`，直接得出结果为`false`，不再运行符号后面的内容 |
| `|`  |    逻辑或    |            或者，两边都为`false`，结果才是`false`            |
| `||` |    短路或    | 如果符号前面的表达式/值为`true`，则直接得出结果为`true`，不再运行符号后面的内容 |
| `^`  |   逻辑异或   |                 相同为`false`，不同为`true`                  |
| `!`  |    逻辑非    |                             取反                             |

使用注意事项：

* 取反运算符最好不要多写，确定好逻辑后只写一次即可；
* 短路运算符简单理解：当左边表达式能确定最终结果，那么右边表达式就不再参与运行；
* 最长用的逻辑运算符：`&&`、`||`、`!`

### 2.6 三元运算符

三元运算符：又叫条件表达式、条件运算符、三目运算符等。其格式为`关系表达式 ? 表达式1 : 表达式2;`，关系表达式运算结果为`true`，则取`表达式1`结果，否则取`表达式2`，例如取两个数的较大值：`a > b ? a : b;`。

计算规则：

* 首先计算关系表达式的值
* 如果值为`true`，表达式1的值就是运算结果
* 如果值为`false`，表达式2的值就是运算结果

### 2.7 原码、反码、补码

**原码**：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。利用原码对正数进行计算是不会有问题的，但是如果是负数计算，由于第一位为符号位，那么运算结果就会出错（如果单独为负数运算写一套运算逻辑，那么对于CPU来说代价太大且极不方便），实际的运算结果与预期结果是相反的（符号位没变化），于是就设计了反码来对负数进行计算。

**反码**：为了解决原码不能计算负数的问题而出现的，正数的反码是其本身，负数的反码是符号位保持不变，其余位取反。

* 计算规则：正数反码不变，负数的反码在原码的基础上，符号位不变，数值取反，即0变1,1变0。
* 反码进行加减运算得到结果的反码
* 但是当反码加减结果跨0的时候出现了问题（结果为正数），因为在反码中出现了两个0（"-0"的`1000 00000`和“+0”的`0000 0000`的反码），于是为了只保留一个0，就在负数反码基础上+1（保留了原“-0”，原码为`1000 0000`，反码为`1111 1111`，加1后转为了`0000 0000`），得到了补码。

**补码**：正数的补码是其本身，负数的补码是在其取反的基础上+1。由于反码转为原码过程中，“-0”`1000 000`一直没有被使用，所以就规定，`1000 0000`为数字-128的补码（-128没有原码和反码），所以一个字节能表示的整数数值范围为`-128~127`，并且基于这个原因（方便CPU运算），CPU寄存器和内存中（甚至硬盘中）的整数的存储方式都是补码，所以原码和反码对于计算机来说都是概念上的东西，它不需要原码和反码，只需要补码进行数据流转运算即可，所以即使-128在计算机中没有原码和补码也不影响。

:::info Tips

有了原码、反码和补码的前置知识，就可以解释前面的Java基本数据类型取值范围的缘故了：

  ① byte占用一个字节，共计8个bit，所以取值范围为`-128~127`，short占两个字节，所以取值范围是`-32768~32767`……

  ② 隐式类型转换：整数隐式类型转换其实就是在小范围数据类型前面补0补到大范围数据类型的长度即可；

  ③ 强制类型转换：从左往右除去超出长度的比特位，保留剩下的比特位（丢失了前面的比特位很可能导致错误数据，例如正数变负数这种）。

:::

### 2.8 其他运算符

在学习了原码、反码和补码的相关知识后，逻辑与和逻辑或也能作为位运算符：

| 运算符 |    含义    |                           运算规则                           |
| :----: | :--------: | :----------------------------------------------------------: |
|  `&`   |   逻辑与   |            0为false，1为true（1是0否，编程通用）             |
|  `|`   |   逻辑或   |                      0为false，1为true                       |
|  `<<`  |    左移    | 补码向左移动，低位（移动后空出来的位置）补0，左边移出去的比特位丢弃 |
|  `>>`  |    右移    |            补码向右移动，高位补0或1（正数与负数）            |
| `>>>`  | 无符号右移 |                      向右移动，高位补0                       |

逻辑或与逻辑与：两个数的补码进行按位逻辑运算即可得到结果。

左移：实际上每左移一位，数值运算上就是原数值乘以2，有时候要写高性能代码常用，因为CPU的寄存器直接移位运算要比数值加减乘除快得多。

右移：高位（左侧）如果是1（负数）则补1，如果是0（正数），则补0，右移一次相当于原数值除以2。

无符号右移：不管正负，高位都是补0。

### 2.9 运算符优先级

| 优先级 |                 运算符                  |
| :----: | :-------------------------------------: |
|   1    |             `.`、`()`、`{}`             |
|   2    |          `!`、`~`、`++`、`--`           |
|   3    |              `*`、`/`、`%`              |
|   4    |                `+`、`-`                 |
|   5    |            `<<`、`>>`、`>>>`            |
|   6    |   `<`、`<=`、`>`、`>=`、`instanceof`    |
|   7    |               `==`、`!=`                |
|   8    |                   `&`                   |
|   9    |                   `^`                   |
|   10   |                   `|`                   |
|   11   |                  `&&`                   |
|   12   |                  `||`                   |
|   13   |                  `?:`                   |
|   14   | `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`&=` |

以上为Java中运算符的优先级，但是一般除了`<<`、`>>`、`>>>等涉及到CPU直接移位运算的符号外，其余时候皆直接使用小括号确定优先级。

## 3、流程控制语句

### 3.1 顺序结构

顺序结构语句是Java程序默认的执行流程，按照代码的先后顺序，从上到下依次执行。

### 3.2 分支结构

#### if语句

if语句在程序中就是用来判断的。

**①** if的第一种格式：

```java
// if 语句结构
if (关系表达式) {
  语句体;
}
```

执行流程：

* 首先计算关系表达式的值
* 如果表达式的值为`true`就执行语句体
* 如果关系表达式的值为`false`就不执行语句体
* 继续执行后面的其他语句

if语句的使用：

* 大括号的开头可以另起一行书写，但是建议写在第一行的末尾（Java语言的语法规范）
* 在语句体中，如果只有一句代码，大括号可以省略不写（在大型项目中不建议这样做）
* 如果对一个布尔类型的变量进行判断，不要用`==`号

**②** if的第二种格式：

```java
if (关系表达式) {
  语句体1;
} else {
  语句体2;
}
```

执行流程：

* 首先计算关系表达式的值
* 如果表达式的值为`true`就执行语句体1
* 如果关系表达式的值为`false`就执行语句体2
* 继续执行后面的其他语句

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/19/351060426455ab3df5ca3ebed00df4c2-image-20251219165245221.png" alt="image-20251219165245221" style="zoom:80%;" align="left" />

<div style="clear: both;"></div>

**③** if语句的第三种格式：

```java
if (关系表达式1) {
  语句体1;
} else if (关系表达式2) {
  语句体2;
}
  ...
 else if (关系表达式n) {
   语句体n;
 } else {
   语句体n+1;
 }
```

执行流程：逐个判断关系表达式，执行第一个关系表达式值为`true`的语句体，如果都为`false`，就执行语句体n+1。

#### switch语句

语句格式：

```java
switch (表达式) {
  case 值1:
    语句体1;
    break;
  case 值2:
    语句体2;
    break;
  ...
  case 值n:
    语句体n;
    break;
  default:
    语句体n+1;
    break; // 末尾可省略
}
```

执行流程：

* 首先计算表达式的值。
* 一次和case后面的值进行比较，如果有对应的值，就会从该case的语句体开始往后依次执行，中间如果遇到break或者方法中的return语句等，就会结束。
* 如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后结束整个switch语句。

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/19/8214cca4f8a3dff7f0874bc9b32f6e3a-image-20251219171412000.png" alt="image-20251219171412000" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

格式说明：

* 表达式：将要匹配的值，取值为`byte`、`short`、`int`、`char`，jdk5以后可以是`枚举`，jdk7以后可以是`String`（不能是`long`和浮点型）。
* case：后面跟的是要和表达式进行比较（匹配）的值。
* break：用于中断（提前结束）switch语句。
* default：所有情况都不匹配的时候就执行该语句体（类似if中的else），非必填项，也不一定是写在最下面，可以写在case之间的任意位置。当然还是比较建议必须写在最后面。
* case的值只能是字面量，不能是变量，且case后面的值不允许重复。

:::info Tips

① 如果有多个case后面的值都是相同的处理逻辑，可以直接将这些值（case 值:）写在一起，一行一条语句（必须逐行挨在一起），然后在最后一条语句后面只写一遍处理逻辑，这样任意一个case匹配成功都可迅速往后执行。（利用case穿透）

② 最后一条语句（不管是case还是default）可以不需要`break`也能正常结束，不过一般还是建议都写上，避免以后往后面添加逻辑的时候忘记写酿成惨剧（后果一般都挺严重），不要管编辑器会不会有格式告警那些。

③ jdk12以后switch新特性：

```java
public class Demo {
    // 使用此新特性，可以省略break语句，不存在穿透现象
    public static void printChNum(int num) {
        switch (num) {
            case 1 -> System.out.println("一");
            case 2 -> {
                // 只有一行的时候，花括号可省略
                System.out.println("二");
            }
            case 3 -> System.out.println("三");
            case 4, 5, 6, 7 -> System.out.println("即将支持！"); // 当需要利用穿透时还可以直接用逗号隔开多个匹配值
            default -> System.out.println(num + "这个数字还是算了。");
        }
    }
}
```

④ switch和if的选用：if一般用于对范围的判断，switch一般用于易穷举结果的匹配。

:::

### 3.3 循环结构

循环：重复做某件事，具有**明确的开始和停止标记**。在Java中，循环一共分为三类，分别是`for循环`、`while循环`以及`do...while循环`（几乎不怎么使用）。

#### for循环

格式：

```java
public class Demo {
    public static void main(String[] args) {
        //for(初始化语句;条件语句;条件控制语句) {
        //    循环结构语句;
        //}
        // 举例：打印十次HelloWorld
        for (int i = 0; i < 10; i++) {
            System.out.println("Hello World!");
        }
    }
}
```

执行流程：

* 执行初始化语句（只执行一次）
* 执行条件判断语句，判断为`true`则执行循环结构语句，`false`则循环结束
* 执行条件控制语句
* 回到第二步，重新开始执行条件判断语句，开启新一轮循环

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/22/14273258547a6ac4e033ab7f7951a2e3-image-20251222134920374.png" alt="image-20251222134920374" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

:::info Tips

① 初始化语句、条件语句和条件控制语句甚至循环结构语句都是非必填项，当然不建议这么做，如果省略条件语句，代表循环将会是一个死循环，容易造成OOM（内存溢出异常），不过有时候会用`for (::) + break;`类代替`while`循环。（`break`关键字在这里为跳出循环语句）。

② 当嵌套多层`for`循环时，可以给每层循环单独添加标签名，然后使用break关键字跳出指定循环：

```java
public class Demo {
    public static void main(String[] args) {
        outer: for (int i = 0; i < 100; i++) {
            inner: for (int j = 0; j < 100; j++) {
                if (i + j == 40) {
                    break outer;
                }
            }
        }
    }
}
```

:::

#### while循环

格式：

```java
public class Demo {
    public static void main(String[] args) {
        // 初始化语句;
        // while (条件判断语句) {
        //    循环控制语句;
        //    条件控制语句;
        // }
        // 举例：打印十次HelloWorld
        int count = 0;
        while (count < 10) {
            System.out.println("Hello World!");
            count++;
        }
    }
}
```

执行流程：

* 执行初始化语句（只执行一次）
* 执行条件判断语句，判断为`true`则执行循环结构语句，`false`则结束循环
* 执行条件控制语句
* 回到第二步，重新开始执行条件判断语句，开启新一轮循环

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/22/7a39187009e007a08a33c3fc3c54470f-image-20251222140845221.png" alt="image-20251222140845221" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

`for`和`while`对比:

* 相同点：运行规则都是一样的

* 区别：

  ① for循环中，控制循环的变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了；

  ② while循环中，控制循环的变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用；

  ③ for循环一般用在明确知道循环的次数或循环的范围时；

  ④ while循环一般用在不知道循环的次数或范围，但是明确知道循环结束的条件时。

> 案例1：打印折纸的次数
>
> 需求：世界最高峰是珠穆朗玛峰（8844.43米=8844430毫米），加入有一张足够大的纸，它的厚度是0.1毫米。请问需要折叠多少次，可以折成珠穆朗玛峰的高度？
>
> ```java
> // 题解：
> public class Anwser {
>     public int solution() {
>         double hight = 0.1;
>         int count = 0;
>         while (hight < 8844430) {
>             hight *= 2;
>             count++;
>         }
>         return count;
>     }
> }
> ```
>
> 案例2：回文数
>
> 需求：给你一个整数x，如果x是一个回文整数，打印true，否则返回false。
>
> 解释：回文数是指正序（从左到右）倒序（从右向左）读都是一样的整数。例如，121是回文，而123不是。
>
> ```java
> // 题解：
> public class Anwser {
>     public boolean solution(int x) {
>         // 用于循环流转变换的值
>         int loopVal = x;
>         // 记录从数字x从右往左倒过来的值
>         int palindrome = 0;
>         while (loopVal != 0) {
>             // 从右往左获取每一个数字
>             int posVal = loopVal % 10;
>             palindrome = palindrome * 10 + posVal;
>             // x个位上的值已获取，所以产生新的个位值
>             loopVal /= 10;
>         }
>         return palindrome == x;
>     }
> }
> ```
>
> 案例3：求商合余数
>
> 需求：给定两个整数，被除数和除数（都是正数，且不超过int范围）。将两数相除，要求不适用乘法、除法和取余运算符，得到商和余数。
>
> ```java
> // 题解：
> public class Anwser {
>     /**
>      * 方法描述：给定两个整数，被除数和除数（都是正数，且不超过int范围）。将两数相除，要求不适用乘法、除法和取余运算符，得到商和余数
>      *
>      * @param dividend 被除数
>      * @param divisor  除数
>      */
>     public void solution(int dividend, int divisor) {
>         int quotient = 0; // 商
>         int remainder = dividend; // 余数
>         while (remainder > divisor) {
>             remainder -= divisor;
>             quotient++;
>         }
>         System.out.printf("%d ÷ %d ＝ %d...%d\n", dividend, divisor, quotient, remainder);
>     }
> }
> ```

#### do...while循环*

格式：

```java
public class Demo {
    public static void main(String[] args) {
        // 初始化语句;
        //do {
        //    循环体语句;
        //    条件控制语句;
        //} while (条件判断语句);
        // 举例：打印十次HelloWorld
    }
}
```

与while区别就是先执行一遍循环体语句和控制语句再做判断，其余没有区别。

#### 无限循环和跳转控制语句

**无限循环**：循环一直停不下来（核心思想都是使条件判断结果始终为`true`），一般用于既不明确循环次数（或范围）也不明确结束条件的情况。一般来说，结束条件可能需要循环语句的运行结果来确定，又或者结束条件为程序停下来（只要程序不停止循环就不停止）。

```java
public class Demo {
    public static void main(String[] args) {
        // 无限循环的三种格式
        for (;;) {
            System.out.println("for无限循环");
        }
        while (true) {
            System.out.println("while无限循环");
        }
        do {
            System.out.println("do...while无限循环");
        } while (true);
    }
}
```

**循环的跳转控制语句**：涉及到两个关键字，`continue`：跳过本次循环，继续执行下次循环；`break`：结束整个循环。

> 案例1：求平方根
>
> 需求：键盘录入一个大于等于2的整数x，计算并返回x的平方根。结果只保留整数部分，小数部分将被舍去。
>
> 题解：从1开始计算每个数的平方，直到结果大于x，则取上一次的数。
>
> 案例2：判断是否为质数
>
> 需求：键盘录入一个正整数，判断其是否为质数。
>
> 题解：从2开始，直到其平方根（小于等于平方根），一个数一个数的判断能否被该数字整除，如果都不能则为质数。

## 4、数组

### 4.1 数组介绍

数组：一种容器，可以用来存储 **同种类型** 的多个值。

* 数组在容器存储的时候，关于数据类型限制，需要结合隐式转换。

### 4.2 数组的定义与静态初始化

数组的定义

* 范式一：`数据类型[] 数组名`（常用）
* 范式二：`数据类型 数组名[]`

数组的初始化：就是在内存中，为数组容器开辟空间，并将数据存入容器中的过程。

* 静态初始化：`数据类型[] 数组名 = new 数据类型[]{ 元素1, 元素2, 元素3... };`

  简化格式：`数据类型[] 数组名 = { 元素1, 元素2, 元素3... };`

  例：`int[] arr = new int[]{11, 22, 33};`

* 数组的地址值：定义好数组后，使用print函数打印到控制台，会得到一个地址值（例`[I@73846619`），这个地址值就表示数组容器在内存中的位置。

  解释一下地址值中各个部分的含义，以`[I@73846619`为例：

  ① `[`：表示数据位一个数组

  ② `I`：表示数组数据类型为`int`

  ③ `@`：间隔符号，固定格式

  ④ `73846619`：真正的地址值（十六进制）

### 4.3 数组元素访问

格式：`数组名[索引];`，索引也叫做下标，角标，从0开始，逐个+1增长，连续不间断。

利用索引对数组中的元素进行访问：

* 获取数组中的元素：`数组名[索引]`，数组索引范围为`0~数组长度-1`。
* 把数据存到数组中：`数组名[索引] = 具体数据/变量`，赋值一旦覆盖，原数据就不在数组中了。

### 4.4 数组遍历

数组遍历：就是取出数组中所有数据的过程，取出后方便加以应用（例如计算、判断以及最简单的打印等）。

```java
public class Demo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        // 利用循环遍历数组，开始条件为索引0，结束条件为数组最大索引（长度-1），条件控制为每次索引+1
        for (int i = 0; i < arr.length - 1; i++) {
            System.out.println(arr[i]);
        }
        // arr.length为数组长度，length是数组的一个属性，其值为数组长度，调用方式：数组名.length
    }
}
```

### 4.5 数组动态初始化

动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。

* 格式：`数据类型[] 数组名 = new 数据类型[数组长度];`，例`int[] arr = new int[3];`

* 数组默认初始化值的规律：

  ① 整数类型：0

  ② 小数类型：0.0

  ③ 字符类型：`/u0000`（空格）

  ④ 布尔类型：`false`

  ⑤ 引用数据类型：`null`

动态初始化和静态初始化区别：

* 动态初始化需手动指定数组长度，由JVM分配默认初始化值，适用于只明确个数，不确定初始化值；
* 静态初始化需手动指定元素值，JVM根据所给出的初始化值计算数组长度，适用于明确了具体操作数据的情况。

### 4.6 数组内存图

Java的内存分配：

* 栈：方法运行时使用的内存，比如`main`方法运行，进入栈中执行

* 堆：存储对象或者数组，`new`来创建的，都存储在堆内存

  在堆中每开辟一块内存，它都会有一个自己的地址值。

* 方法区：存储可以运行的`.class`文件

  **注意**：① 在jdk7以前，方法区和堆空间逻辑上是放在一起的，物理上也是一块连续的内存区域；② 从jdk8开始，取消了方法区，新增元空间，把原来方法区的多种功能进行拆分，有的功能放到了堆中，有的功能放到了元空间中（包括加载字节码文件的功能也放到了元空间）。

* 本地方法栈：JVM在使用操作系统功能的时候使用，与我们Java开发无关

* 寄存器：给CPU使用，与我们无关![JDK7（左）JDK8（右）](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/c6109c41f1da02b7aee8efcf37f7b8f9-image-20251223145053004.png)

<div style="clear: both;"></div>

只涉及到基本数据类型的方法运行内存图（逐行）：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/89b4a23777bdafd0da0c6cb5043d0a3c-image-20251223150425735.png" alt="image-20251223150425735" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

数组内存图：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/6cf3d763b8dd10986eaef6211c78e41d-image-20251223150801275.png" alt="image-20251223150801275" align="left"/>

<div style="clear: both;"></div>

> **总结**
>
> ① 只要是new出来的一定是在堆里面开辟了一个小空间；
>
> ② 如果new了多次，那么在堆里面有多个小空间，每个小空间中都有各自的数据。

两个数组指向同一块内存空间的内存图：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/eca539cf3435b5b810c6a5e9b5c6efe8-image-20251223151214800.png" alt="image-20251223151214800" align="left"/>

<div style="clear: both;"></div>

> **总结**
>
> 当两个数组指向同一块内存区域时，其中一个数组对内存区域中的值进行修改，那么其他数组再次访问时都是修改后的结果。

### 4.7 数组常见问题

常见问题：数组越界异常，当访问了数组中不存在的索引，就会引发索引越界异常。（超出最大索引或者小于0）

### 4.8 数组常见操作

求最值、求和并统计个数、交换数据、打乱数据等。

```java
import java.util.Arrays;
import java.util.Random;

public class MyArrayUtils {
    // 求最大值
    public static int getMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            max = arr[i] > max ? arr[i] : max;
        }
        return max;
    }
    
    // 求和并统计个数
    /*
    需求：生成10个1~100之间的随机数存入数组
    1）求出所有数据之和
    2）求所有数据的平均数
    3）统计有多少个数据比平均值小
    */
    public static void statisticsSum() {
        // 1. 定义数组
        int[] arr = new int[10];
        // 2. 生成随机数据
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(100) + 1;
        }
        System.out.println("生成的随机数组：" + Arrays.toString(arr));

        // 3. 求和
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        System.out.println("求和：" + sum);

        // 4. 求平均数
        double avg = (double) sum / arr.length;
        System.out.println("平均数：" + avg);

        // 5. 统计有多少个数据比平均值小
        int leThanAvgCount = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < avg) {
                leThanAvgCount++;
            }
        }
        System.out.println("比平均数小的元素个数：" + leThanAvgCount);
    }
    
    // 交换数组中的数据：定义一个数组，反转整个数组
    public static void reverse(int[] arr) {
        // 两种方式都行
//        for (int i = 0; i < arr.length / 2; i++) {
//            int temp = arr[i];
//            arr[i] = arr[arr.length - i - 1];
//            arr[arr.length - i - 1] = temp;
//        }

        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    // 打乱数组数据
    public static void shuffle(int[] arr) {
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            // 获取数组索引范围内的随机数
            int index = random.nextInt(arr.length);
            int temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;
        }
    }
}
```

## 5、方法

### 5.1 什么是方法

概念：方法（method）是程序中最小的执行单元。例如Java程序的入口就是main方法。

创建：重复的、具有独立功能的代码逻辑可以抽象/提取到方法中。

作用：可以代码的复用性，也可以提高代码的可维护性（同一逻辑出现问题，只需修改方法体即可，调用方法的地方不用修改）

### 5.2 方法的格式

方法本质就是将一些代码**打包**在一起，用到的时候就**调用**。

定义方法：把一些代码打包到一起，该过程称为方法定义。

方法调用：方法定义完成后并不会主动运行，需要手动调用才能执行，该过程称为方法调用。（方法必须先定义后调用）

#### 最简单的方法定义

```java
public class MethodDemo {
    // 格式：
    // public static void 方法名() {
    //     方法体（就是打包起来的代码）;
    // }
    
    public static void main(String[] args) {
        // 调用定义好的方法
        playLKL();
        // 多次调用
        playLKL();
        playLKL();
        playLKL();
    }
    
    // 定义一个方法
    public static void playLKL() {
        System.out.println("选英雄");
        System.out.println("准备开局");
        System.out.println("对线");
        System.out.println("崩盘");
        System.out.println("骂队友");
        System.out.println("送人头");
        System.out.println("GG");
    }
}
```

#### 带参数的方法定义

```java
public class MethodDemo {
    // 格式：
    // public static void 方法名(参数列表（多个参数用逗号隔开）) {
    //     方法体;
    // }
    // 调用：方法名(参数1, 参数2, ...);
    // 注意：方法调用时，参数的数量与类型必须与方法中定义中小括号里面的变量一一对应，否则程序将报错
    
    public static void main(String[] args) {
        // 调用方法
        getSum(10, 11); // 21
    }
    // 定义方法
    public static void getSum(int num1, int num2) {
        System.out.println(num1 + num2);
    }
}
```

形参和实参：形参即形式参数，指的是方法定义中参数列表中的参数；实参即实际参数，指的是方法调用时传入方法的参数。方法调用时方法的形参和实参必须一一对应，否则程序将报错（编译时报错）。

#### 带返回值的方法定义

需要返回值的原因：方法返回的结果在调用处可能会有别的用途。（有返回值也不是一定会使用的哦）

方法的返回值其实就是方法运行的最终结果，如果在调用处要根据方法的结果去编写另一端代码逻辑，为了在调用处拿到方法产生的结果，就需要定义带有返回值的方法。

```java
public class MethodDemo {
    // 格式：
    // public static 返回值类型 方法名(参数列表) {
    //     方法体;
    //     return 返回值;
    // }
    
    public static void main(String[] args) {
        // 直接调用
        getSum(10, 11);
        // 赋值调用
        int sum = getSum(11, 12);
        // 直接使用运行结果
        System.out.println(getSum(12 + 13)); // 25
    }
    
    public static int getSum(int num1, int num2) {
        return num1 + num2;
    }
}
```

:::info Tips

方法定义技巧：

* 我需要什么？（参数列表）
* 我具体要做什么？（方法体）
* 我要返回什么？（返回值）

:::

方法的注意事项：

* 方法不调用就不执行
* 方法与方法之间是平级关系，不能互相嵌套定义
* 方法的编写顺序与执行顺序无关，只看调用顺序
* 方法的返回值类型为void，标识该方法没有返回值，没有返回值的方法可以省略不写，但是可以使用return语句（后面不跟任何内容）直接结束方法

### 5.3 方法的重载

在同一个类中，方法名相同，参数列表不同的方法就构成重载。重载与返回值无关。

参数列表不同：个数/类型/顺序不同，JVM通过参数的不同来区分调用的是哪个方法。顺序不同虽然可以构成重载，但是不建议这么做。

### 5.4 方法的内存

方法被调用后就会进栈执行，执行完成后出栈，丢弃方法作用域中的所有数据。

#### 方法调用的基本内存原理

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/823caa81431e9e530c45a0cb8c2a1554-image-20251223165127297.png" alt="image-20251223165127297" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

以上代码执行顺序：

1. main方法先入栈开始执行；
2. main方法中执行eat方法，于是eat方法入栈开始执行；
3. eat方法中执行study方法，于是study方法入栈开始执行；
4. study方法打印“学习”，方法执行结束，方法出栈，栈帧回到eat方法继续执行后续代码；
5. eat方法打印“吃饭”，开始执行sleep方法，于是sleep方法入栈；
6. sleep方法打印“睡觉”，方法执行结束，方法出栈，栈帧回到eat方法继续执行后续代码；
7. eat方法执行完毕，eat方法出栈，栈帧回到main方法继续执行后续代码；
8. main方法执行完毕，main方法出栈，程序运行结束。

#### 方法传递基本数据类型的内存原理

基本数据类型和引用数据类型：

![image-20251223170035726](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/f802314367767184c6fe12be4f1887d6-image-20251223170035726.png)

![image-20251223170131056](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/89288b433e5b0350b2ee98123ac42462-image-20251223170131056.png)

<div style="clear: both;"></div>

* 基本数据类型：数据存储在自己的空间中，赋值给其他变量，也是赋的真实值。
* 引用数据类型：数据值是存储在其他空间中，自己空间中存储的是地址值。赋值给其他变量，赋的也是地址值。

演示代码：

```java
public class MethodDemo {
    public static void main(String[] args) {
        int number = 100;
        System.out.println("调用change方法前：" + number); // 100
        change(number);
        System.out.println("调用change方法后：" + number); // 100
    }
    public static void change(int number) {
        number = 200;
    }
}
```

#### 方法传递引用数据类型的内存原理

演示代码：

```java
public class MethodDemo {
    public static void main(String[] args) {
        int[] nums = { 10, 20, 30 };
        System.out.println("调用change方法前：" + nums[1]); // 20
        change(nums);
        System.out.println("调用change方法后：" + nums[1]); // 200
    }
    
    public static void change(int[] arr) {
        arr[1] = 200;
    }
}
```

> 说明：对于JavaSDK中，使用`native`关键字修饰的方法是没有方法体的，因为它是调用其他语言来实现的。

## 6、面向对象

面向对象思想（Object Oriented）是一种以对象为核心的程序设计范式，其核心要素包括对象封装、类划分、继承机制及消息传递机制，要求程序系统直接映射现实世界的问题域结构。

具体操作思维是将现实世界中存在的事务归类(`class`)，并将其各项特点作为属性(`field`)抽象出来，然后根据属性的取值特点类赋予不同的值。例如，人可以归为一个大类，他有年龄、喜好、性别等属性，每个具体的人就是一个对象，每个对象各个属性值的差别就是代表了不同的人。

面向对象方法论逐步成为软件开发主流范式，衍生出Booch方法、Coad方法、OMT方法等建模体系。1997年左右[统一建模语言（UML）](https://baike.baidu.com/item/统一建模语言/3160571?fromModule=lemma_inlink)整合了多种方法，形成标准化建模工具，应用范围从编程扩展至需求分析、系统设计等领域，推动了面向对象技术在分布式系统、人工智能等领域的广泛应用。

> 做面相对象的软件开发，至少需要能够看懂UML，否则不好编写文档，也不好看懂需求。当然，不同的公司和不同的开发团队不一定会使用UML。

### 6.1 设计对象并使用

#### 类和对象

类：是“生产”对象的设计图，是对象共同特征的描述。

对象：是真实存在的具体的东西。

在Java中，必须先设计类，才能获取相应对象。

```java
// 如何定义类：
public class ObjDemo {
    // 1、成员变脸（代表属性，一般是名词）
    // 2、成员方法（代表行为，一般是动词）
    // 3、构造器（后续章节学习）
    // 4、代码块（后续章节学习）
    // 5、内部类（后续章节学习）
    
    public static void main(String[] args) {
        // 获取对象：类名 对象名（变量名） = new 类名();
        Phone phone = new Phone();
        
        // 使用对象
        // 访问属性：对象名.成员变量
        phone.brind = "xiaomi";
        phone.price = 1999;
        System.out.println(phone.brind);
        System.out.println(phone.price);
        // 访问行为：对象名.方法名(...)
        phone.call();
        phone.playGame();
        
        // 创建多个对象同理即可
        // Phone newPhone = new Phone();
        // ……
    }
}

// 样例：创建手机类
class Phone {
    // 属性
    /** 品牌 */
    String brand;
    /** 价格 */
    double price;
    
    // 行为：
    public void call() {
        System.out.println("手机在打电话");
    }
    public void playGame() {
        System.out.println("手机在玩游戏");
    }
}
```

#### 定义类的补充注意事项

* 用来描述一类事务的类，专业叫做`JavaBean类`。在JavaBean中，是不写main方法的。（事实上，在一个项目中，程序的入口只需要一个就够了）

* 在之前编写的main方法的类，本质作用来看叫做测试类（用来运行每次演示的Demo），我们可以在测试类中创建JavaBean类的对象并进行赋值和调用。

* 类名首字母建议大写，需要见名知意，大驼峰。

* 一个Java文件中可以定义多个class类，且只能一个类是public修饰，public修饰的类名必须和文件名相同。实际开发中还是只建议一个文件中只定义一个class。

* 成员变量的完整定义格式是：`修饰符 数据类型 变量名称 = 初始化值;`，一般无需指定初始化值，存在默认值，当然，如果需要为成员（属性）赋一个优先级高于构造方法的值，也可以定义这个初始化值。

* 对象的成员变量的默认值规则：

  <table style="text-align: center; vertical-align: middle;">
    <thead style="width: 100%;">
      <tr>
        <th>数据类型</th>
        <th>明细</th>
        <th>默认值</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="3">基本类型</td>
        <td>byte、short、int、long</td>
        <td>0</td>
      </tr>
      <tr>
        <td>float、double</td>
        <td>0.0</td>
      </tr>
      <tr>
        <td>boolean</td>
        <td>false</td>
      </tr>
      <tr>
        <td>引用类型</td>
        <td>类、接口、数组、String</td>
        <td>null</td>
      </tr>
    </tbody>
  </table>

### 6.2 封装

封装是面向对象的三大特征之一（另外两个是继承和多态），它的作用在于告诉我们如何正确的设计对象的属性和方法。**对象代表什么，就得封装对应的数据，并提供数据对应的行为。**

>  案例：人画圆，需要定义两个类——人和圆，那么画圆这一方法应该定义在人这个类还是圆这个类中？
>
> 题解：由于画圆这个行为的数据来自于圆，画圆是圆这个类自我描述的行为，所以这个方法应该定义在圆这个类中。

#### 封装的作用

* 对象代表什么，就得封装对应的数据，并提供数据对应的行为（最典型的案例就是JDK自身提供的调用各种功能的类都是基于这个思想实现的）。
* 可以极大地降低学习成本，可以少学、少记，或者压根不用学，不用记对象有哪些方法，有需要时再去找就行。（命名规范中见名知意的重要作用）

#### private关键字

`private`是一个权限修饰符，可以修饰成员（成员变量和方法），被`private`修饰的成员只能在本类中访问。

一个设计好的`Person`类，如果它有一个属性为`age`，如果它的某一个对象被随意的将`age`属性设置为负数或者一个远超人类寿命限制的数，设计成这样的类被认为是不安全的，需要给每个成员（属性）的访问设计一套统一的标准。

利用`private`关键字来修饰类所有需要被定义标准的成员，然后再提供对外可访问的`public`关键字修饰的方法来对成员进行访问（和`private`一样，`public`也是一个权限修饰符，它修饰的成员变量和方法可以在对象上访问），这即是`getter/setter`方法了。

`getter/setter`方法名称有统一的命名标准，取值方法用`getXxx`，赋值方法用`setXxx`，如果是布尔型的成员，取值方法也可以是`isXxx`。

事实上，几乎所有的JavaBean（包括数据流转的类、数据库表对应的类等）在项目中，都需要遵循这个设计标准。

如此，上述的年龄设值问题就可以在`Person`类`age`属性的`setter`方法中添加判断了（这里只是举例，实际开发过程中，一般情况下，调用`setter`已经是经过所有校验的最后一步了设值保存/传入下一步继续流转处理了）。

案例：设计Person类。

```java
public class Person {
    /** 姓名 */
    private String name;
    /** 性别 */
    private char gender;
    /** 年龄 */
    private int age;
    
    // getter/setter，这里的this关键字后面再说，这里如果形参名与属性名不同则可以省略
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public char getGender() {
        return gender;
    }

    public void setGender(char gender) {
        this.gender = gender;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

:::info Tips

① 一些序列化框架是通过`gettter/setter`方法来获取属性的（例如Alibaba Fastjson）。

② 项目中可以考虑引用`lombok`组件来省略代码中的`getter/setter`方法（组件会根据组件中的注解会在编译的时候自动生成）。

```java
import lombok.Getter;
import lombok.Setter;

/**
 * 类描述：面向对象Demo：人类设计
 *
 * @author Triabin
 * @date 2020-12-24 14:28:20
 */
@Getter
@Setter
public class Person {
    /**
     * 姓名
     */
    private String name;
    
    /**
     * 性别
     */
    private char gender;
    
    /**
     * 年龄
     */
    private int age;
}
```

③ 如果求稳且项目组中有成员使用了不适配`lombok`的代码编辑器（Eclipse、vscode等），也可以使用JetBrains IDEA的自动生成功能。

* 设计好成员变量后，在文件中任意地方右键单击呼出弹窗，在弹窗中选择`Generate`，也可以使用快捷键`Alt + Insert`。(macOS为`Command + N`)

  <img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/24/89b2e6b97704e500362c8c4808918f24-image-20251224143930007.png" alt="image-20251224143930007" style="zoom:80%;" align="left" />

  <div style="clear: both;"></div>

* 然后在弹窗中选择`Getter and Setter`（左），再在之后的弹窗（右）中选中类的所有字段（聚焦到类上面后，`Ctrl + A`，或者选中第一个字段后按住`Shift`再点击最后一个字段，或者按住`Ctrl`键，然后一个一个的用鼠标点），选中后回车/点击OK。（macOS则将`Ctrl`键换成`Command`键即可）

  <img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/24/282560d545063b3ac1d05ea90de64cd2-image-20251224144408102.png" alt="image-20251224144408102" align="left"/>

  <div style="clear: both;"></div>

  > 关于Setter template，如果选择Builder，那么生成的`setter`方法会返回对象本身`return this;`，这样做的作用是可以让你链式调用，例如前文中的Person类，如果设置的是Builder模板，那么赋值可以这样：`person.setName("张三").setGender('M').setAge('20');`。当然，实际开发时为了方便修改和代码可读性，可能会换行：
  > ```java
  > public class Demo {
  >     public static void main(String[] args) {
  >         Person person = new Person()
  >             .setName("张三")
  >             .setGender('M')
  >             .setAge('20');
  >     }
  > }
  > ```

:::

### 6.3 this关键字

成员变量与局部变量

上一节Person类设计案例中说，如果Setter方法形参名与属性名不同则this关键字可以省略。其实如果相同且省略this关键字，则会导致Setter方法无法给属性赋值，这牵涉到了成员变量与局部变量的概念。

在类中，如果把变量定义在方法中，则该变量为（该方法的）局部变量，定义在类中，则该变量为（该类的）成员变量。

```java
public class ThisDemo {
    public static void main(String[] args) {
        method(); // 30
    }
    
    private int age;
    public void method() {
        int age = 30;
        System.out.println(age);
    }
}
```

就近原则：上述代码中，最终打印结果为30，因为局部变量的age离打印语句更近，所以最终打印结果为局部变量的值，如果想要使用成员中的age，就可以在age前面添加`this.`，这个this就表示当前类（对象）。这就是就近原则。

如此就可以解释上一节Person类中如果Setter方法形参名与成员变量名相同且省略this关键字导致Setter方法无法给属性赋值的原因了，在这种情况下，Setter方法中的属性名用的是离自己较近的形参，语句作用为形参将自己的值赋值给自己，压根没有访问到成员变量，所以也就无法给对象属性赋值。

> 在类的设计过程中，只要涉及到访问对象自身属性的情况下，不管局部变量中有没有同名的变量，最好都在前面添加`this.`，因为你不确定哪一天可能就会因为bug修改或者特性添加或者业务逻辑变更等各种原因在这个方法中添加同名的局部变量，一方面能避免多处修改，另一方面是**人的记忆是最不靠谱的**，这样设计可以避免因为忘记修改或者别人修改你的代码时没注意成员变量与局部变量的冲突导致的谬误。

### 6.4 构造方法

构造方法也叫作构造器、构造函数，用于在创建对象的时候给成员变量初始化。

```java
// 构造方法格式
public class StructorDemo {
    修饰符 类名(参数列表) {
        方法体;
    }
}
```

特点：

* 方法名与类名相同
* 没有返回值类型，连void都没有
* 没有具体的返回值（不能由return带回结果数据）

执行时机：

* 创建对象的时候**由JVM调用**，不能手动调用构造方法；
* 每创建一次对象，就调用一次构造方法。

一般样例（以前面的Person类为例）：
```java
/**
 * 类描述：面向对象Demo：人类设计
 *
 * @author Triabin
 * @date 2020-12-24 14:28:20
 */
public class Person {
    /**
     * 姓名
     */
    private String name;

    /**
     * 性别
     */
    private char gender;

    /**
     * 年龄
     */
    private int age;

    /**
     * 空参构造
     */
    public Person() {}

    /**
     * 全参构造
     * @param name 姓名
     * @param gender 性别，M男，F女
     * @param age 年龄
     */
    public Person(String name, char gender, int age) {
        this.name = name;
        this.gender = gender;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public Person setName(String name) {
        this.name = name;
        return this;
    }

    public char getGender() {
        return gender;
    }

    public Person setGender(char gender) {
        this.gender = gender;
        return this;
    }

    public int getAge() {
        return age;
    }

    public Person setAge(int age) {
        this.age = age;
        return this;
    }
}
```

构造方法注意事项：

* 构造方法的定义：如果没有写构造方法的情况下，JVM会默认创建一个无参构造方法；如果定义了构造方法，系统将不再提供默认的构造方法。
* 构造方法的重载：带参构造方法，和无参构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载。
* 推荐的使用方式：无论是否使用，都手动书写无参和全参的构造方法。

:::info Tips

与之前所述的利用IDEA生成`getter/setter`方法的相同，也可以通过`Alt + Insert`（macOS为`Command + N`），进入`Generate`选项菜单，选择生成构造方法，并且具体要初始化哪些参数也直接可选，亦或者使用`lombok`组件的`@AllArgsConstructor`与`@NoArgsConstructor`注解生成全参构造与无参构造方法。

:::

### 6.5 标准JavaBean

① 类名要见名知意

② 成员变量使用`private`修饰

③ 提供至少两个构造方法，即无参构造方法和全参构造方法

④ 成员方法：提供每一个成员变量对应的`getter/setter`方法，如果还有其他行为，也需要写上。

### 6.6 对象内存图

![JDK7（左）JDK8（右）](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/c6109c41f1da02b7aee8efcf37f7b8f9-image-20251223145053004.png)

<div style="clear: both;"></div>

回顾：Java代码运行时，先将字节码文件(`.class`)加载进入方法区（元空间）这块内存，然后在栈内存中运行字节码文件中的方法，方法中定义的变量也是存在栈内存中，占内存中的方法运行过程中new出来的内容都会在堆内存中开辟一块内存区域，并产生内存区域相对应的地址。

#### 一个对象的内存图

`Student s = new Student();`：

1. 加载字节码文件（加载`Student.class`到方法区）
2. 声明局部变量（在栈内存中声明局部变量`s`）
3. 在堆内存中开辟一块内存空间（`new Student()`的过程）
4. 默认初始化（`Student`类成员变量对应数据类型的默认值）
5. 显式初始化（定义`Student`类时给成员变量的字面量初始化值）
6. 构造方法初始化（调用`Student`构造函数时，函数中给成员变量的初始化值）
7. 将堆内存中开辟空间的地址值赋值给左边声明的局部变量

图解：

![image-20251225142956508](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/58cf27c291d5d8a725dc66c1df14e049-image-20251225142956508.png)

<div style="clear: both;"></div>

* 上图左边的代码运行时，首先会将`TestStudent.class`加载到方法区，开始执行后将`main`方法加载到栈内存；
* 运行`main`方法第一行，需要创建`Student`对象，于是将`Student.class`加载到方法区；
* 开始创建`Student`对象，现在`main`方法中创建一个局部变量`s`，然后开始在堆内存中开辟一块内存空间（假设内存地址为`001`），根据方法区加载的`Student.class`内容创建对象；
* 先开始对`Student`对象的成员变量进行默认初始化，`name`为`String`类型，默认初始化值为`null`，同理，`age`默认初始化值为`0`;
* 从左边`Student`类的代码来看，没有对成员变量进行显式初始化；（如果定义过程中显式设置了`String name = "张三"`，则会在这一步将值赋给堆内存中对象的`name`属性）
* 由于调用了空参构造器，并且`Student`类的空参构造器并没有手动指定，所以构造方法也没有再对成员变量进行覆盖初始化；
* 堆内存中的`Student`对象创建完成，将内存地址`001`赋值给栈内存中的局部变量`s`；
* 代码继续执行，此时打印`s`的值为`001`，打印`s`中`name`和`age`属性值分别为`null`和`0`；
* 通过`s`访问堆内存相应的内存空间，并修改对象成员变量值后，再打印则为修改后的值；
* 此时再通过`s`调用其中的`study`方法，通过堆内存中记录的方法地址，将方法区中的方法加载到栈空间中，运行方法；
* `study`运行完成后，出栈；
* `main`方法也运行完成，出栈；
* 此时堆内存中地址为`001`区域的对象已无变量指向自己，将在垃圾回收时被回收掉这块内存。

以上就是一个对象在方法运行中创建到销毁（内存释放）的全过程，如果是同一个类的多个对象，也同理，唯一的区别就是**当第二次创建同一个类的对象时，不需要再重新加载字节码文件到方法区**。并且，每次建对象开辟的内存空间之间是相互独立，互不影响的。

#### 两个变量指向同一个对象的内存图

![image-20251225145419891](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/60c23ed540d30dc3f2da47722f6d267c-image-20251225145419891.png)

<div style="clear: both;"></div>

如图，在洞悉了局部变量与堆内存中开辟的内存空间之间的关系之后，多个局部变量指向同一块内存区域的情况就很好理解了，当多个变量指向同一个对象时，只要有其中任何一个变量访问并修改了对象的属性，则所有变量获取到的都是修改后的对象，因为大家（所有变量）记录的都是同一个内存地址值。

将变量的值设为`null`以后，则是掐断了其与堆内存中对象所在内存空间的联系，它将无法访问该对象，当所有的变量都不指向该内存区域时，该内存区域将变成垃圾，然后被GC回收。

#### 基本数据类型和引用数据类型的区别

前文 [1.5  数据类型](#1.5- 数据类型)中对基本数据类型做了介绍，引用数据类型则是只简单归类为除基本数据类型之外的其他。现在结合前两节对与对象的内存图可以从内存的角度对基本数据类型和引用数据类型做一个更加详细解释：

* 基本数据类型数据的值是存储在自己的空间中的，赋值给其他变量赋的是真实的值（例如直接将内存中的补码赋给另一个变量）；
* 引用数据类型数据值则是存储在其他空间中或者空间中的其他内存位置，自己空间中存储的是地址值，赋值给其他变量赋的是地址值（注意这里存储地址值变量的空间并不单单指栈空间，堆空间中的对象成员变量也会存储其他引用数据的地址值）。

#### this的内存原理

this本质：所在方法调用者的地址值。
![image-20251225151847436](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/deb1b64c7ce1196745ef9247d53c2d1d-image-20251225151847436.png)

### 6.7 补充知识：成员变量、局部变量区别


|      区别      |                  成员变量                  |                    局部变量                    |
| :------------: | :----------------------------------------: | :--------------------------------------------: |
| 类中的位置不同 |                类中、方法外                |           方法内、方法声明上（形参）           |
|  初始化值不同  |               有默认初始化值               |           没有，使用之前需要完成赋值           |
|  内存位置不同  |                   堆内存                   |                     栈内存                     |
|  生命周期不同  | 随着对象的创建而存在，随着对象的消失而消失 | 随着方法的调用而存在，随着方法的运行结束而消失 |
|     作用域     |                整个类中有效                |                 当前方法中有效                 |

### 6.8 static

`static`：表示静态，是Java中的一个修饰符，可以修饰成员方法也可以修饰成员变量。被`static`修饰的成员变量叫做静态变量，同理，被修饰的方法叫做静态方法。

#### 静态变量

特点：

* 变量被该类所有对象共享
* 随着类的加载而加载，是优先于对象出现的（类字节码文件加载到方法区的时候它就出现了，此时还没创建对象）

调用方式：

* 类名调用（推荐）：`类名.变量名`
* 对象调用：`对象变量名.变量名`

静态变量内存图：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/28/85f4434fd3de2366602551d2b42ad5cd-image-20251228134033472.png" alt="image-20251228134033472"/>
<div style="clear: both;"></div>

运行过程简述：

* `main`方法第一行，将`Student.class`加载到方法区，发现该类有静态成员变量，于是将静态成员加载到堆内存的**静态区**，并且将其赋一个对应数据类型的默认值；

  静态区：静态存储位置，在JDK8以前，这个分区存放在方法区，JDK8开始将其挪到了堆内存中。

* 将“阿玮老师”赋给静态变量`teacherName`；

* 内存中开辟一块空间存放`Student`对象，给成员变量赋默认初始值；

* 分别给成员变量赋值；

* 调用`show()`方法，方法入栈，然后通过对象访问到静态成员变量和类成员变量打印到控制台，方法运行结束，出栈；

* `Student = s2`类似。

#### 静态方法和工具类

特点：

* 多用在测试类和工具类中
* JavaBean中很少使用（就算用到，也多涉及到一些设计模式，例如单例）

调用方式：

* 类名调用（推荐）：`类名.方法名`（类外部，内部可以直接调用，不用类名）
* 对象调用：`对象变量名.方法名`

工具类：帮助我们做一些事情（最好是能归为一类的那种），但是不描述任何事物（对象）的类。

工具类与其他类对比：

* JavaBean类：用来描述一类事物的类，比如，`Teacher`、`Student`、`Dog`，`Cat`等。
* 测试类：用来检验其他类是否书写正确，带有程序入口的类。
* 工具类：不是用来描述一类事物的，而是帮我们做一些事（里面多是一些静态方法，用于实现具体的功能）。

工具类要遵守的规则：

* 类名见名知意，例如数组工具类叫`ArrayUtil`（这里只是举例，实际上JDK提供的数组工具类叫做`Arrays`），数学工具就叫`MathUtil`；
* 私有化构造方法，防止外界创建这个类的对象，因为工具类不是用来描述事物的，创建它的对象没有意义，只需要类名来调用工具方法就行了；
* 方法都定义为静态的，方便调用（否则私有化了构造方法的类无法调用成员方法）。

#### `static`的注意事项

* 静态方法只能访问静态变量和静态方法（否则加载到静态区的时候其他内容都还没加载出来，无法访问）；
* 非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法（也是和加载顺序相关）；
* 静态方法中没有`this`关键字。

总结：静态方法中只能访问静态；非静态方法可以访问所有。静态方法中没有`this`关键字。

静态成员变量随着类的加载而加载到静态区，此时的普通成员变量和成员方法因为不一定有调用者（创建的类对象），所以无法调用，但是静态成员变量已经加载到静态区，静态方法因为不需要`this`作为调用者，所以也可以直接调用。

重新认识`main`方法：

* public：被JVM调用，权限够大
* static：被JVM调用，不用创建对象，直接访问类名（因为main方法是静态的，如果以main方法作为入口的测试类，那么测试类中其他方法也需要是静态的）
* void：被JVM调用，不需要给JVM返回值
* main：一个通用的名称，虽然不是关键字，但是能被JVM识别，是Java规定的主入口名称
* `String[] args`：用于接收键盘录入的数据，现在几乎不用（编译后的结果在命令行调用的时候后面跟的参数列表）

### 6.9 继承

继承是面向对象的三大特征之一，之前已经学过了封装，在将事物零散的属性和行为封装到一起成为一个对象的过程中，出现了许多属性高度重合的类。

例如`Student`（学生）和`Teacher`（老师）两个类都有诸如姓名、年龄、性别、住址等相同的属性以及吃饭睡觉等相同的方法，为了解决这个问题，于是将这些重合的属性和方法写到了第三个类中，给这个类取名为`Person`。学生和老师两个类只需要去**继承**这个类即可获取到这些共有的属性和方法，再根据自身特添加一些独属于自己的属性和方法（或者重写父类方法）即可。

* Java中提供一个关键字`extends`，用这个关键字就可以让一个类和另一个类建立起继承关系。

  `public class Student extends Person {}`

* 上述案例中，`Student`称为子类（派生类），`Person`称为父类（基类或超类）。

#### 继承继承的好处

* 可以把多个子类中重复的代码抽取到父类中，提高了代码的复用性。
* 子类可以在父类的基础上，增加其他功能，使子类更强大。

继承要学习的点：自己设计父类，使用别人设计好的类。

**自己设计继承**：当类与类之间存在相同的内容，并满足子类时父类中的一种，就可以考虑使用继承来优化代码。

#### 继承的特点

Java只支持单继承，不支持多继承，但支持多层继承：

* 单继承：一个子类只能继承一个父类

* 不支持多继承：子类不能同时继承多个父类

* 多层继承：子类A继承父类B，父类B可以继承父类C，其中，C是A的间接父类，B是A的直接父类，C是B的直接父类

  > 在Java中，每一个类都直接或间接的继承于`java.lang.Object`类（万物皆对象，所以给最大基类命名为Object）。如果在定义类的时候，没有明确使用`extends`关键字指定父类，那么JVM会自动默认给类加上一个父类`Object`。

#### 子类能继承父类中的哪些内容

| 父类中的内容 |  非私有  | 私有`private` |
| :----------: | :------: | :-----------: |
|   构造方法   | 不能继承 |   不能继承    |
|   成员变量   |  能继承  |    能继承     |
|   成员方法   |  能继承  |   不能继承    |

① 构造方法如果可以被继承会将会导致构造方法的命名规则，即构造方法名与类名相同。

```java
public class ExtendsDemo {
    public static void main(String[] args) {
        Son son1 = new Son();
        Son son2 = new Son("张三", 18); // 报错
    }
}
    
class Parent {
    private String name;
    private int age;

    public Parent() {}
    public Parent(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Son extends Parent {}
```

② 私有的成员变量虽然可以被继承下来，但是不能直接使用，只能通过`public`的`getter/setter`方法访问属性。继承的内存图：

![image-20251228151814410](https://gitee.com/triabin/img_bed/raw/master/2025/12/28/1aabdd22e90e31619b6eadb04da62456-image-20251228151814410.png)
<div style="clear: both;"></div>

运行时内存分析：

* 首先加载`TestStudent.class`到方法区，然后`main`方法进栈，开始运行；
* 第一行发现要使用`Zi`类，于是将`Zi.class`加载到方法区，加载过程发现它集成了`Fu`类，于是将`Fu.class`也加载到方法区；
* 第一行等号左边，在栈中定义了一个类型为`Zi`的`main`方法局部变量`z`；
* 第一行等号右边，在堆空间中开辟一块内存区域，地址为`001`（假设），内存氛围两块（逻辑上），一块存放`Fu`类的成员变量，一块存放`Zi`类的成员，然后分别进行默认初始化，然后将内存地址赋值给左边的局部变量`z`，然后继续执行下一行；
* 打印出内存地址`001`，继续执行下一行；
* 三行都是赋值语句，不同的是每次赋值，都会现在`Zi`类的那块内存中找成员变量，找不到才会去父类中找，三行依次赋值后继续执行下一行；
* 打印完成，`main`方法运行完毕，方法出栈。

在该过程中，如果`Fu`类中，将成员变量都用`private`修饰，那么在子类中赋值时，将无法直接访问，除非父类提供可被子类继承的`public`的`getter/setter`供子类访问相应成员变量。

③ **虚方法表**：对于方法的继承，如果每次调用父类方法都需要逐级往父类中去查找的话，那么那些继承关系比较复杂的类将会大大降低Java代码的执行效率，于是Java在底层做了一些优化，它会从最顶级的父类开始，设置一个虚方法表，将这个类中可能会经常用到的方法（非`private`、非`static`、非`final`）单独抽离出来，每次继承，父类都会将虚方法表交给子类，然后子类会再将自己的常用方法加入到这个虚方法表中，如此就避免了每次调用父类方法时的逐级查找（同时也方便方法重写）。**只有父类中的虚方法才能被子类继承。**内存图演示：

![image-20251228154537300](https://gitee.com/triabin/img_bed/raw/master/2025/12/28/52194bc6dbea119ec26220084bcf36d1-image-20251228154537300.png)
<div style="clear: both;"></div>

运行过程内存分析：

* 首先加载字节码文件`TestStudent.class`，然后`main`方法入栈开始执行；
* 第一行，需要加载`Zi.class`，由于`Zi`类继承了`Fu`类，于是加载`Fu.class`，由于`Fu`类继承了`java.lang.Object`类（以前的内存分析由于不涉及到它的内容，为了简化分析，于是略过了这一步），于是加载`Object.class`到方法区。加载完成，首先在栈中定义变量`z`，然后开始在堆空间开辟内存区间，内存区域间在逻辑上分为两块，但是由于父类和子类都没有成员变量，所以只开辟，不需要默认初始化赋值，然后将开辟出来的内存地址返回给`z`；
* 第二行，打印出内存地址`001`；
* 第三行，调用`ziShow()`方法，先去`Zi`类的虚方法表中查找该方法，没找到再去查找自己的成员方法，还找不到就逐级向上查找，找到了直接运行；
* 第四行，调用`fuShow1()`方法，先去`Zi`类的虚方法表中查找该方法，找到了直接运行；
* 第五行，调用`fuShwo2()`方法，先去`Zi`类的虚方法表中查找该方法，没找到，再去查找自己的成员方法，也没找到，于是去`Fu`类中查找成员方法，找到了发现是`private`的方法，于是报错，栈帧弹出。

#### 继承中成员变量的访问特点

就近原则：谁离我近，我就用谁。当前方法作用域内找，找不到就去成员变量里面找，成员变量找不到再去父类找。

```java
public class ExtendsDemo {
    public static void main(String[] args) {
        Son son = new Son();
        son.show(); // Show Son Parents
    }
}

class Parent {
    String name = "Parents";
}

class Son {
    String name = "Son";
    public void show() {
        String name = "Show"
        System.out.println(name); // 访问离我近的
        System.out.println(this.name); // 访问本类
        System.out.println(super.name); // 访问父类
    }
}
```

#### 继承中成员方法的访问特点

直接调用满足就近原则，谁离我近我就用谁，`super`调用，访问父类。

调用方法过程：现在本类中查看，有无此方法，没有则去父类中查找。但是如果子类重写了父类方法，那么在子类的虚方法表中的该方法名对应的方法为子类重写后的方法。

```java
public class ExtendsDemo {
    public static void main(String[] args) {
        Student s1 = new Student();
        s1.lunch();
        
        InternationalStudent s2 = new InternationalStudent();
        s2.lunch();
    }
}

class Person {
    public void eat() {
        System.out.println("吃米饭");
    }
    public void drink() {
        System.out.println("喝开水");
    }
}

class Student extends Person {
    public void lunch() {
        this.eat();
        this.drink();
        
        super.eat();
        super.drink();
    }
}

class InternationalStudent {
    public void lunch() {
        this.eat();
        this.drink();
        
        super.eat();
        super.drink();
    }
    
    @Override
    public void eat() {
        System.out.println("吃面包");
    }
    
    @Override
    public void drink() {
        System.out.println("喝凉水");
    }
}
```

方法的重写：当父类（做同一件事情的）的方法不能满足子类需求时，需要进行方法重写。

* 书写格式：在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。
* `@Override`重写注解：用于放在重写后的方法上，校验子类重写时语法是否正确。（关于注解的知识以后再详述）
* 在添加虚方法表过程中，如果发生了方法重写，那么子类的方法会覆盖父类的方法。

方法重写注意事项和要求：

* 重写的方法名称、参数列表必须与父类保持一致；
* 子类在重写父类方法时，访问权限子类必须大于等于父类（暂时了解：`private < default（空着不写） < protected < public`；
* 子类重写父类方法是，返回值类型必须小于等于父类；
* 建议：重写方法时，方法尽量与父类保持一致（访问权限、参数列表、返回值类型等，绝大部分场景都是一致的）；
* 私有方法不能被重写；
* 子类不能重写父类的静态方法，重写将会报错。**只有被添加到虚方法表中的方法才能被重写。** 方法重写本质就是覆盖虚方法表中的方法，因此那些不能被添加到虚方法表中的方法都无法被重写。

#### 继承中构造方法的特点

* 父类中的构造方法不会被子类继承；

* 子类中所有构造方法默认先访问父类中的无参构造，再执行自己。

  ```java
  public class ExtendsDemo {
      public static void main(String[] args) {
          Child child = new Child("Triabin");
          System.out.println(child); // Child{name='Triabin', age=18}，toString()方法为java.lang.Object中的方法，因此每个类其实都有该方法，打印到控制台时，引用对象打印的其实都是该方法的返回值
      }
  }
  
  class Parent {
      String name;
      int age;
  
      public Parent() {
          this.age = 18;
      }
  }
  
  class Child extends Parent {
      public Child(String name) {
          this.name = name;
      }
  
      @Override
      public String toString() {
          return String.format("Child{name='%s', age=%d}", name, age);
      }
  }
  ```

  原因：子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据，因此子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。

  调用方式：子类构造方法的第一行语句默认都是`super();`，即使不写也存在，并且必须在第一行。（如果调用父类的有参构造则必须手动调用`super(参数列表);`）

#### this、super使用总结

* `this`：可以理解为一个变量，表示当前方法调用者的地址值；从虚拟机打印的对象中方法的内存信息来看，它就是一个存在每个对象方法中的局部变量，当方法被调用的时候它才有值。
* `super`：代表父类存储空间。

| 关键字  |              访问成员变量              |                访问成员方法                 |                         访问构造方法                         |
| :-----: | :------------------------------------: | :-----------------------------------------: | :----------------------------------------------------------: |
| `this`  | `this.成员变量`<br />访问本类成员变量  | `this.成员方法(...)`<br />访问本类成员方法  | `this(...)`<br />访问本类构造方法，如果是在构造方法中，这个语句必须写在第一行 |
| `super` | `super.成员变量`<br />访问父类成员变量 | `super.成员方法(...)`<br />访问父类成员方法 |              `super(...)`<br />访问父类构造方法              |

### 6.10 多态

多态是面向对象的三大特征之一，前面已经依次介绍了封装和继承。在继承的使用过程中，出现了一种使用情况，假如在设计一个学生管理系统时，将所有用户重复的属性放在`User`类中，然后分别继承出`Administrator`类，`Teacher`类和`Student`类，然后再设计一个注册接口的方法，为了设计这个方法，就需要重写出`register(Administrator admin)`、`register(Teacher teacher)`和`register(Student student)`三个方法，这样的场景又造成了代码逻辑的重复，调用起来也很不方便，于是设计了多态来解决这样的问题。

在创建对象时，可以将子类对象赋值给父类，例如`User user = new Student()`，这样**同类型的对象，表现出的不同形态，即为多态**。可以看出，继承是多态的前提条件，没有继承，就没有多态。根据多态的特性，上述问题中的注册方法可以写成`register(User user)`，这样就可以接收所有继承自`User`类的对象了，并且根据各个子类中方法实现的逻辑不同，调用同一个方法时，其运行逻辑也可以不同。

#### 多态的基本使用

多态的表现形式：`父类类型 变量名 = 子类对象;`

多态的前提：
* 有继承/实现关系（实现关系到后面的接口章节再介绍）
* 有父类引用指向子类对象
* 有方法重写

多态的好处：使用父类作为参数，可以接收所有子类对象，体现多态的扩展性与便利。

代码演示：

```java
public class PolymorphismDemo {
    public static void main(String[] args) {
        User student = new Administrator();
        User teacher = new Teacher();
        User admin = new Student();

        register(admin); // Administrator
        register(teacher); // Teacher
        register(student); // Student
    }

    public static void register(User user) {
        user.show();
    }
}

class User {
    public void show() {
        System.out.println("User");
    }
}

class Administrator extends User {
    @Override
    public void show() {
        System.out.println("Administrator");
    }
}

class Teacher extends User {
    @Override
    public void show() {
        System.out.println("Teacher");
    }
}

class Student extends User {
    @Override
    public void show() {
        System.out.println("Student");
    }
}
```

#### 多态调用成员的特点

* 变量调用：编译看左边，运行也看左边

* 方法调用：编译看左边，运行看右边

代码演示：

```java
public class PolymorphismDemo {
    public static void main(String[] args) {
        Animal animal = new Cat();
        Cat cat = new Cat();

        // 编译代码的时候，会看左边的父类中有没有这个变量，如果有就编译成功，没有就编译失败，运行的时候也看左边，实际获取的就是左边父类中的成员变量的值
        System.out.println(animal.name); // 动物
        System.out.println(cat.name); // 猫

        // 编译的时候，会看左边的父类中有没有这个方法，如果有就编译成功，没有就编译失败，运行的时候实际运行的是子类中的方法
        animal.show(); // Animal --- show方法
        cat.show(); // Cat --- show方法
    }
}

class Animal {
    String name = "动物";

    public void show() {
        System.out.println("Animal --- show方法");
    }
}

class Dog extends Animal {
    String name = "狗";

    @Override
    public void show() {
        System.out.println("Dog --- show方法");
    }
}

class Cat extends Animal {
    String name = "猫";

    @Override
    public void show() {
        System.out.println("Cat --- show方法");
    }
}
```

多态调用成员内存图解：

![image-20251230160445552](https://gitee.com/triabin/img_bed/raw/master/2025/12/30/f2fdfad65a6cf856297f7c46bcaf6fce-image-20251230160445552.png)
<div style="clear: both;"></div>

执行步骤解析：

* 首先加载`Test.class`到方法区，然后`main`方法入栈开始执行；
* 第一行，先加载字节码文件，涉及到继承关系，都是先加载父类再加载子类，所以这一行加载顺序为`Object.class -> Animal.class -> Dog.class`，加载完毕后在栈内存中定义一个类型为`Animal`的变量`a`，然后在堆内存中开辟一块内存区间来存储`Dog`对象，这块内存区间分为两个区间（逻辑上），一个存储父类成员变量，一个存储子类成员变量，给所有成员变量初始化完成后继续执行下一部；
* 第二行，调用成员变量，先去父类中找成员变量`name`，找到了后打印到控制台，然后继续执行下一步（当然，如果父类中没有这个成员变量，直接编译都无法通过，这就是编译看左边，运行也看左边）；
* 第三行，调用成员方法，直接在需方发表中找到了`show()`方法，直接入栈运行即可（因为此时子类中的`show()`方法已经在加载字节码文件的时候就被子类`Dog`中的`show()`方法覆盖了，所以运行的是子类中的`show()`方法，这就是运行看右边）；
* 运行完毕，`main`方法出栈。

看着整个运行逻辑有点复杂，其实总结下来就是为了确保多态使用过程中，不会调用到不存在的成员变量（所以要求成员变脸必须是父类中存在的）以及能够调用到真正要运行（子类中）的方法。只要明确了这个目的，整个加载调用过程的设计也就能够理解了。

#### 多态的优势和弊端

优势：
* 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。例如，`Person p = new Student(); p.work(); ...`，在代码中，如果后续不想学生工作了，想要换老师工作，只需要将第一行改成`Person p = new Teacher();`即可，后续的代码不用变更。
* 定义方法的时候，使用父类作为参数，可以接收所有子类对象。

弊端：在执行子类特有方法时，无法调用子类的特有功能。解决方案：这种问题在设计方法的时候就需要考虑到，如果确实有需求，可以使用`instanceof`来判断类型从属关系然后进行强转再调用，`instanceof`关键字的使用格式`变量名 instanceof 类名`，返回结果为布尔类型，代码演示：

```java
public class PolymorphismDemo {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        test(a1);
        test(a2);
    }

    public static void test(Animal animal) {
        animal.eat();

        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.watchDog();
        }
        if (animal instanceof Cat cat) { // JDK14加入的新特性，将判断和强转合到一起
            cat.mouseKiller();
        }
    }
}

class Animal {
    public void eat() {
        System.out.println("吃东西");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗啃骨头");
    }

    public void watchDog() {
        System.out.println("看家狗");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }

    public void mouseKiller() {
        System.out.println("猫抓老鼠");
    }
}
```

如果不先判断类型就直接强转（例如将狗转成猫），可能会出现类型转换异常`ClassCastException`。

### 6.11 包、final、权限修饰符、代码块

#### 包

包就是文件夹，用来管理各种不同功能的Java类，方便后期代码维护。包名使用`package`关键字声明在一个Java文件的第一行。

包的命名规则：公司域名反写+包的作用，需要全部英文小写，见名知意。例如`com.microsoft.office.word`、`com.microsoft.office.powerpoint`、`com.microsoft.office.excel`。

在使用一个类的时候，真正的使用方式，其实是将其包名加类名才对，这种`包名.类名`的形式叫做类的**全类名**（也叫做全限定名，只不过一般不用，至少口语上不用）。平时在编写代码时，因为使用了导入语句将类导入，所以避免了在每一个使用类的地方都写上全类名，当类名冲突的时候，就可以通过给其中一个类使用的地方加上全类名来区分。

使用其他类的规则：

* 使用同一包中的类时，不需要导包（默认到本包中找）
* 使用`java.lang`包中的类时，不需要导包
* 其他情况都需要导包
* 如果同事使用两个包中的同名类，需要用全类名（很少碰到）

:::info Tips

在编写Java程序的时候，如果使用JetBrains IDEA，默认情况下，导入同一个包中的类如果超过5个，它就会自动改成`import com.identifier.*`，这个星号就表示导入这个包下的所有类。这种导入方式虽然省事儿，但是在项目中是及其不推荐的，首先代码编写需要的是确保使用明确声明的东西，其次这回很容易造成命名空间污染以及出现不必要的导入，因此需要避免使用`*`号导入。IDEA设置自动导包自动使用`*`同包数量：`File -> New Projects Setup -> Settings for New Projects... -> Editor -> Code Style -> Java -> Imports`，进入界面后将`Class count to use import whith '*'`和`Names count to use static import whith '*'`改为一个几乎不可能达到的数字（一般直接改为9999😅），然后保存即可。

**注意：一定要在`Settings for New Projects...`中设置，不然你重新打开一个项目又恢复默认你了，所有需要全部项目生效的设置都在这里设置一遍。**

:::

#### `final`关键字

final，翻译成中文就是`最终的`，即不可变，在Java中，`final`关键字可以修饰方法、类和变量：

* 方法：表名该方法是最终方法，不能被重写
* 类：表名该类是最终类，不能被继承
* 变量：声明常量，只能被赋值一次（注意是赋值指向值的指向不可变，对于引用数据类型，赋值的地址不可变，但是地址对应的引用数据类型自身是可变的，例如指向一个对象，那么这个指向确实不可变，但是可以调用这个对象本身的成员变量/成员方法修改自身属性）

常量：实际开发中，一般作为系统的配置信息，方便维护，提高可读性，并且常量有自己的命名规范：单词全部大写，单词之间用下划线`_`隔开。

细节：

* `final`修饰的变量是基本类型，那么变量存储的数据值不能发生改变；
* `final`修饰的变量是引用类型，那么变量存储的地址值不能发生改变，对象内部的可以改变。 

:::info 说明
**① 字符串不可变的原因：`java.lang.String`类使用了字节数组存储字符串内容，该字节数组使用了`final`关键字进行修饰：`private final byte[] value;`；**

**② 在项目中，一般会用`Constants.java`这个类定义全局常量，定义格式：`public static final 数据类型 常量名 = 常量值;`，使用：`Constants.常量名`；**

**③ 项目中的每个类中获取日志对象时，也常用`final`关键字：`private static final Logger logger = LogManager.getLogger(当前类名.class);`。**
:::

#### 权限修饰符

权限修饰符就是用来控制一个成员能够被访问的范围的，可以用来修饰成员变量、方法（包括构造方法）、内部类。

权限修饰符有四种，作用范围从小到大依次是：`private < default（空着不写，缺省/默认） < protected < public`。

|   修饰符    | 同一个类中 | 同一个包中其他类 | 不同包下的子类 | 不同包下无关类 |
| :---------: | :--------: | :--------------: | :------------: | :------------: |
|  `private`  |     ✓      |                  |                |                |
|  空着不写   |     ✓      |        ✓         |                |                |
| `protected` |     ✓      |        ✓         |       ✓        |                |
|  `public`   |     ✓      |        ✓         |       ✓        |       ✓        |

* `private`：只能自己用
* `default`：只能本包中使用
* `protected`：其他包中的子类也能用
* `public`：公共的

使用规则：实际开发中，一般只用`private`和`public`。
* 成员变量私有

* 方法公开

* <span id="6-11-权限修饰符-共性代码">特例</span>：如果方法中的代码是抽取其他方法中共性代码，这个方法一般也私有
  
  例如在类的方法中，如果有多个需要暴露到外界使用的方法都有相同的代码逻辑，那么这部分代码就称之为共性代码。共性代码一般会被抽取出来，封装成一个私有方法，供类中的其他方法调用。（因为这相当于类中方法的一部分，不希望暴露到外界被其他地方调用）

:::info Tips
在实际开发中，其实并没有那么统一的标准，大多根据项目功能开发需求和语言特性，自由发挥使用，尽量避免屎山代码的形成即可。
:::

#### 代码块

代码块：在类中，使用`{}`括起来的代码，称为代码块。

根据代码块出现的位置不同，可以将代码块分为三类，分别是出现在方法中的局部代码块、方法外类里面的构造代码块以及使用`static`关键字修饰的静态代码块。

局部代码块：写在方法中的`{}`，用于限制变量的生命周期，定义的变量只在该代码块中有效，出了代码块就释放内存。其最为本质的作用就是节约内存，秉承用完内存立马回收的思想，但是随着计算机硬件的发展，内存的成本逐步降低，现在基本不用这个技术了。

```java
public class LocalCodeBlockDemo {
    public static void main(String[] args) {
        {
            int a = 10;
            System.out.println(a);
        }
        System.out.println(a); // Cannot resolve symbol 'a'
    }
}
```

构造代码块：写在类中的`{}`下的代码片段，一般用于存放构造方法中重复的代码，执行时机为每次创建对象时，在构造方法执行之前。这个特性由于其灵活性等原因，现在已经基本不常用了。

```java
public class ConstructorCodeBlockDemo {
    private String name;
    private int age;

    // 构造代码块
    {
        System.out.println("这是构造代码块");
    }
    public ConstructorCodeBlockDemo() {
        System.out.println("这是无参构造方法");
    }
    public ConstructorCodeBlockDemo(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("这是有参构造方法");
    }
}
```

静态代码块：使用`static`关键字修饰的代码块（格式：`static { ... }`），一般用于初始化静态变量，随着类的加载而加载，并且自动触发，**只执行一次**。这个特性在项目中的应用十分广泛，例如在项目中，我们可以使用静态代码块来初始化数据库连接池、加载配置文件等。

```java
public class StaticCodeBlockDemo {
    public static void main(String[] args) {
        System.out.println(StaticCodeBlock.count);
    }
}

class StaticCodeBlock {
    // 静态变量
    private static int count = 0;

    // 静态代码块
    static {
        System.out.println("这是静态代码块");
        count = 100;
    }
}
```

“只执行一次”是静态代码块的重要特性，也是某些数据的的初始化不能写在`main`方法中的原因（因为只要是方法，就有被重复调用的可能，包括`main`方法）。

### 6.12 抽象类和抽象方法

在之前的面相对象三大特征中，我们首先提出了继承来解决代码重复的问题，继承算是解决了属性复用的问题，但是方法复用过程中又出现了新的问题，即父类中的方法不能满足所有子类需求，于是又设计了方法重写的概念，但是方法重写只是一种软性的规定，即在使用过程中即使不重写方法也不会报错，加之前面说的父类方法不能穷尽子类方法需求的问题，于是引入了抽象的概念。

> 说明：抽象也算是面向对象的特性

可以说，类是对事物的抽象，抽象类则是对类的抽象，对类行为（方法）的规定。

抽象方法：将**共性的**行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的（该行为在每个子类中必须要有），父类中不能确定具体的方法体，该方法就可以定义为抽象方法。
* 定义格式：`public abstract 返回值类型 方法名(参数列表);`，没有方法体，方法权限修饰符要确保在子类中能继承到该方法（不能是`private`）

抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类。
* 定义格式：`public abstract class 类名 { ... }`，抽象类中可以包含抽象方法和非抽象方法。

抽象里和抽象方法的注意事项：
* 抽象类不能实例化（不能创建对象），只能被继承。
* 抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类。
* 可以有构造方法（给子类调用）。
* 抽象类的子类要么重写抽象类中的所有抽象方法，要么声明为抽象类。

抽象类和抽象方法的意义：在多人协作的项目中，对类的行为（包括方法名）进行统一强制规定，避免了多人协作过程中忘记实现某种行为的情况以及对同一行为的方法命名迥异的情况。

### 6.13 接口

在有了面向对象的三大特征以及抽象的概念后，实际使用过程中出现了一种情况，就是在规定的诸多类中，有许多**不同的**类（不是同一个父类）之间却存在着相同的一些列的行为（方法），并且这些行为是每一个类都必须要拥有的，但是由于项目是多人协作，在开发过程中每个人每次分配到的需求不一，这一些列的方法不一定都能记得去一一实现，并且即使是同一个方法，每个人每次的命名也不一定能够统一，这给方法的调用带来一定负担。由于只能继承一个类的特性，这些方法又不能定义在另一个抽象类之中，于是就引入了接口的概念来解决这一个问题。

与抽象类不同，抽象类是对类的抽象，接口是对行为的抽象，抽象类中定义了同一种（同一个继承体系）类必须要有的行为，而接口中则是定义不同类中必须要有的行为。

#### 接口的基本使用

接口的定义和使用：

* 接口用关键字`interface`来定义：`public interface 接口名 {}`
* 接口不能实例化
* 接口和类之间是实现关系，通过`implements`关键字表示：`权限修饰符 class 类名 implements 接口1, 接口2... {}`
* 接口的实现类要么重写接口中所有的抽象方法，要么是抽象类
* 实现和继承可以同时存在

#### 接口中成员的特点

* 成员变量：只能是常量，默认修饰符`public static final`（默认，就算你没写，Java也会自动给你加上），因为接口是一种规则，规则是不能改变的，所以只能是常量。

  ```java
  public class InterfaceDemo {
      public static void main(String[] args) {
          System.out.println(InterF.a); // 10
          InterF.a = 20; // Cannot assign a value to final variable 'a'
      }
  }
  
  public interface InterF {
      int a = 10;
  }
  ```

* 构造方法：没有构造方法，因为接口是行为的规则，不能创建对象也不需要给实现类初始化成员变量，所以没有给接口设计构造方法。

* 成员方法：只能是抽象方法，默认修饰符为`public abstract`（默认，就算你没写，Java也会自动给你加上）。

  ① JDK7及以前，接口中只能定义抽象方法；

  ② JDK8新特性：接口中可以定义有方法体的方法`default`和`static`，可以定义方法的默认实现以及静态方法；

  ③ JDK9新特性：接口中可以定义私有方法。

> ① 接口中，所有方法前面的`public abstract`都可以省略，项目开发过程中都是不会去写这部分内容的，所以其格式可以归结为`返回值类型 方法名(参数列表);`。
>
> ② 在IDEA中，编写实现类时，在写完要实现的接口时会出现编译报错，此时按下`Ctrl+I`（macOS为`Command+I`）即可快速呼出方法重写弹窗，窗口中会列出所有还需要重写的方法，选中即可快速生成空实现方法。

#### 接口和类之间的关系

* 类和类的关系：继承关系，只能单继承，不能多继承，但是可以多层继承。
* 类和接口的关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口，如果多个接口中有同名方法，则只需要重写一次即可。
* 接口和接口的关系：继承关系，可以单继承，**也可以多继承**。

#### 接口扩展

接口新增特性：

* JDK8新增的有默认实现的接口方法：有默认实现的方法，使用关键字`default`修饰，一般用于解决接口升级又不需要在所有实现类中去实现或者调用的情况，又或者所有实现类对于该的方法体都完全一致的情况，格式为`default 返回值类型 方法名(参数列表) { 方法体 }`。

  注意事项：① 默认方法不是抽象方法，所以不强制重写，但是如果重写，重写的时候不需要`default`关键字。

  ② 如果实现的多个接口中，有同名的`default`方法，那么实现类就必须重写该方法。

* JDK8新增的接口中可以定义静态方法：接口中定义静态方法与类中的静态方法一样，需要用`static`关键字修饰，格式为`public static 返回值类型 方法名(参数列表) { 方法体 }`。

  注意事项：① 静态方法只能通过接口名去调用，不能通过实现类名或者实现类的对象名去调用。

  ② `public`关键字可以省略，`static`关键字不可以省略。

* JDK9开始，接口中可以定义私有方法：其实在接口中定义私有方法的目的与前文[权限修饰符](#权限修饰符)中所述的**[共性代码](#6-11-权限修饰符-共性代码 "共性代码")**的目的一致，因为静态方法的存在，所有也和普通类一样，包含静态私有方法。

接口的应用：

* 接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类事项对应的接口就可以了。
* 当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态，接口多态的引用于继承多态的应用一致。

#### 适配器模式

设计模式（Design pattern）：是一套反复使用、多数人知晓的、经过分类编目的、代码设计经验总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

适配器设计模式：解决接口于接口实现类之间的矛盾问题。[见23种设计模式-适配器模式](../common/important/23种设计模式.md#13、适配器模式)

问题：一个接口中抽象方法太多，而实际使用只需要其中一部分方法，但是由于接口必须全部实现的限制，需要在实现类中对一些方法做空实现，造成代码可读性下降，代码结构复杂等问题。

解决：

1. 编写中间类`XxxAdapter`实现对应接口；
2. 对接口中的抽象方法进行空实现；
3. 让真正的实现类继承中间类，重写实际需要使用到的方法；
4. 为了避免其他类去创建适配器类对象，中间的适配器类使用`abstract`关键字修饰。

### 6.14 内部类

内部类：类的五大成员之一（五大成员：属性、方法、构造方法、代码块、内部类），在一个类中再定义另一个类即为内部类。内部类表示的是外部类的一部分，内部类单独出现没有任何意义。（Tips：我的开发印象中，内部类在定义一些前端接收的JSON数据时，为了保持结构一致并且方便类的管理时使用过）

内部类的访问特点：

* 内部类可以直接访问外部类的成员，包括私有（类内部）；
* 外部类要访问内部类的成员，必须创建对象。

以下为一个内部类使用样例：

```java
public class InnerClassDemo {
    public static void main(String[] args) {
        Car car = new Car("BMW", 2010, "red", "V8", 20); // 要想在外面使用内部类，需要给内部类加static关键字修饰
        car.show(); // Car{carName='BMW', age=2010, color='red', engine=Engine{name='V8', age=20}}
    }
}

/**
 * 类描述：内部类演示对象
 *
 * @author Triabin
 * @date 2020-10-03 16:08:38
 */
public class Car {
    /**
     * 车名
     */
    private String carName;
    /**
     * 使用年限
     */
    private int age;
    /**
     * 车辆颜色
     */
    private String color;
    /**
     * 引擎
     */
    private Engine engine;

    /**
     * 类描述：发动机引擎
     */
    static class Engine {
        /**
         * 引擎名称
         */
        private String name;
        /**
         * 引擎使用年限
         */
        private int age;

        public Engine() {
        }

        public Engine(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return "Engine{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }

        public String getName() {
            return name;
        }

        public Engine setName(String name) {
            this.name = name;
            return this;
        }

        public int getAge() {
            return age;
        }

        public Engine setAge(int age) {
            this.age = age;
            return this;
        }

        public void show() {
            System.out.println(this);
        }
    }

    public Car() {
    }

    public Car(String carName, int age, String color) {
        this.carName = carName;
        this.age = age;
        this.color = color;
    }

    public Car(String carName, int age, String color, String engineName, int engineAge) {
        this(carName, age, color);
        this.engine = new Engine(engineName, engineAge);
    }

    @Override
    public String toString() {
        return "Car{" +
                "carName='" + carName + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                ", engine=" + engine +
                '}';
    }

    public String getCarName() {
        return carName;
    }

    public Car setCarName(String carName) {
        this.carName = carName;
        return this;
    }

    public int getAge() {
        return age;
    }

    public Car setAge(int age) {
        this.age = age;
        return this;
    }

    public String getColor() {
        return color;
    }

    public Car setColor(String color) {
        this.color = color;
        return this;
    }

    public Engine getEngine() {
        return engine;
    }

    public Car setEngine(Engine engine) {
        this.engine = engine;
        return this;
    }

    public void show() {
        System.out.println(this);
    }
}

```

内部类的分类：根据类位置的不同以及功能作用的差异内部类可以分为成员内部类、静态内部类、局部内部类和匿名内部类，在实际的使用过程中，前三种几乎不用我们自己手动写，匿名内部类则在开发过程中会经常用到。

#### 成员内部类

成员内部类写在成员位置，属于外部类的成员，例如前面案例中`Car`类的内部类`Engine`。

成员内部类可以被一些修饰符修饰，比如`private`、`默认`、`protected`、`public`、`static`等，只要可以用来修饰成员变量的，都可以用来修饰成员内部类。当然，一旦使用`static`进行修饰以后，就不叫成员内部类了，而是叫做静态内部类。

在成员内部类中，JDK16之前是不能定义静态变量的，JDK16开始才可以定义静态变量。

获取成员内部类对象：

* 在外部类编写方法，对外提供内部类的对象：在外部类创建对外暴露的成员方法，方法返回该内部类对象实例即可。
* 直接创建格式：`外部类名.内部类名 对象名 = 外部类对象.内部类对象;`，示例：`Outer.Inner inner = new Outer().new Inner();`

:::info Tips

① Java打印地址值的时候，如果是内部类，地址值为以下格式：`外部类名$内部类名@地址值`，这也是之前命名规范中不建议使用美元符号命名的原因之一。

② 使用`private`关键字修饰的内部类外部无法直接访问，需要跟私有属性一样，提供对外暴露的方法使用内部类。

:::

成员内部类访问外部类：

```java
public class FieldInnerClassDemo {
    public static void main(String[] args) {
        Outer.Inner inner = new Outer().new Inner();
        inner.show();
    }
}

class Outer {
    private int a = 10;
    
    class Inner {
        private int a = 20;
        
        public void show() {
            int a = 30;
            System.out.println(a); // 30
            System.out.println(this.a); // 20
            System.out.println(Outer.this.a); // 10
        }
    }
}
```

内存分析：

![image-20260103173029787](https://gitee.com/triabin/img_bed/raw/master/2026/01/03/83747366ff930cd5e29ab98a566c5cd7-image-20260103173029787.png)
<div style="clear: both;"></div>

* JVM将`Test.class`字节码文件加载到方法区，开始执行该文件夹，将`main`方法加载到栈内存，开始执行；
* `main`方法第一行，需要用到`Outer.class`和`Outer$Inner.class`等字节码文件，将它们分别加载到方法区，然后在栈空间中定义一个类型为`Inner`，名为`oi`的变量；然后在堆空间中开辟一块空间用于存储`Outer`类对象，假设地址为`001`，成员变量为`a`，默认初始化为0，然后再进行字面量初始化为10；再在堆空间中开辟一块内存区域用于存储`Inner`对象，假设地址为`002`，成员变量为`a`，默认值为0，字面量初始化后值为20；然后再在该对象内初始化一个类型为`Outer`的`this`指向前面开辟的`Outer`对象所在内存地址`001`；最后将`Inner`对象所在地址`002`返回并赋值给栈内存中的`oi`；
* `main`方法第二行，调用`oi`对象的`show()`方法，方法入栈，开始执行；
* `show`方法第一行，在栈内存中定义局部变量`a`并给它赋值为30；
* `show`方法第二行，打印变量`a`的值，由于就近原则，直接取局部变量`a`的值30；
* `show`方法第三行，打印`this.a`，由于`show`方法的调用者为`Inner`类对象`oi`，所以`this`指向`002`，所以此处`a`的值为`oi`的成员变量，值为20；
* `show`方法第四行，打印`Outer.this.a`，由于在堆空间中开辟`Inner`对象内存空间时，在该对象中初始化了一个`Outer`的`this`指向外部类，所以这里的`a`为外部类中的成员变量，值为10；
* `show`方法`mian`方法相继执行完毕，方法出栈，程序运行结束。

#### 静态内部类

静态内部类中的一种，算是一种特殊情况，当成员内部类前面使用`static`关键字修饰，该成员内部类就称为静态内部类。静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象。

创建静态内部类对象的格式：`外部类名.内部类名 变量名 = new 外部类名.内部类名();`；

调用非静态方法的格式：先创建对象，对象调用；

调用静态方法的格式：`外部类名.内部类名.方法名(参数列表);`

#### 局部内部类

将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量；

外接无法直接使用，需要在方法内部创建对象并使用；

该类可以直接访问外部类的成员，也可以访问方法内的局部变量。

#### 匿名内部类

匿名内部类本质就是隐藏了名字的内部类，格式为：`new 类名或者接口名 { 重写方法; }`，这当中包含了三个部分，继承/实现、方法重写、创建对象。

举例：有一个接口`Inter`，它有一个抽象方法名为`show()`，那么使用匿名内部类可以直接写成`new Inter() { 直接写重写方法 }`，对于一些接口/父类的直接使用（只用一次）的场景，不需要额外再去新建一个实现类，可以在使用的地方利用匿名内部类直接实现。

代码演示：

```java
public class AnonymousInnerClassDemo {
    public static void main(String[] args) {
        Swim swim = new Swim() {
            @Override
            public void swim() {
                System.out.println("在匿名内部类中重写了swim方法");
            }
        };
        swim.swim();
    }
}

public interface Swim {
    void swim();
}
```

`new 接口名()`后面的花括号中的内容就是那个“没有名字的类”的内容，这些匿名内部类在编译后都会被虚拟机赋予一个名字，字节码文件为`外部类名$数字序号.class`，其内容为常规的实现类编译后的样子。

使用场景：当方法的参数是接口或者类时，以几口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以使用匿名内部类简化代码。

## 7、Lambda表达式和方法引用

### 7.1 Lambda表达式

上一章节匿名内部类中的使用，可以使用Lambda表达式进一步简化代码：

```java
public class AnonymousInnerClassDemo {
    public static void main(String[] args) {
        // Swim swim = () -> {
        //     System.out.println("在匿名内部类中重写了swim方法");
        // };
        // 或
        Swim swim = () -> System.out.println("在匿名内部类中重写了swim方法");
        swim.swim();
    }
}

public interface Swim {
    void swim();
}
```

这就是Lambda表达式的应用。

#### 函数式编程

函数式编程（Functional programming）是一种思想特点。在面向对象中，要做一件事情，首先是先找到对应的对象，然后再让对象去做事情。而函数式编程的思想，则是忽略面向对象复杂的语法，只强调做什么，而不是谁去做。可以简单的理解为我在乎的只有接口里面的方法逻辑，而不是谁去实现了这个接口。

Lambda表达式就是在Java中函数式编程思想的具体实现。

#### Lambda表达式的标准格式

Lambda是JDK8新加入的特性，它由`()`、`->`和`{}`三部分组成：

* `()`：对应方法的形参
* `->`：固定格式
* `{}`：对应方法体，当方法体只有一行代码时，可省略

注意点：

* Lambda表达式可以用来简化匿名内部类的书写
* Lambda表达式只能简化**函数式接口**的匿名内部类的写法
* 函数式接口：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加`@FunctionalInterface`注解验证，如果报错就不是函数式接口

#### Lambda表达式的省略写法

神略核心：可推导，可省略。（凡是可以推导出来的东西，都可以省略）

Lambda的省略规则：

* 参数类型可以省略不写；
* 如果只有一个参数，参数类型可以省略，`()`也可以省略；
* 如果Lambda表达式的方法体只有一行，大括号、分号，`return`可以省略不写，需要同时省略。

```java
import java.util.Arrays;
import java.util.Comparator;

public class LambdaDemo {
    public static void main(String[] args) {
        // Lambda省略规则演示，以Arrays自带的排序方法为例
        Integer[] arr = { 3, 5, 4, 1, 6, 2 };

        // 原生写法
        Arrays.sort(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1 - o2;
            }
        });

        // Lambda表达式
        Arrays.sort(arr, (Integer o1, Integer o2) -> {
            return o1 - o2;
        });
        
        // 省略参数类型
        Arrays.sort(arr, (o1, o2) -> {
            return o1 - o2;
        });
        
        // 省略括号略
        
        // 只有一行，省略大括号、分号、return关键字
        Arrays.sort(arr, (o1, o2) -> o1 - o2);
    }
}
```

:::info Tips

函数式编程思想是JDK8才引入的的，为此，JDK8还提供了一些函数式接口来供方便我们更好地在Java开发中使用函数式编程，详见[Java四大函数式编程接口](./random-notes/Java四大函数式编程接口)。在实际开发中，熟悉了函数式编程后，就会觉得Lambda表达式非常好用，但是在刚开始接触开发的时候，往往意识不到哪些地方该使用函数式编程。以我的经验来看，**只要觉得某个地方传递的参数实际上是函数**，就立马考虑是否使用函数式编程，一使用函数式编程，就先看看在Java提供的四大函数式编程接口中，是否有现成可用的接口，避免自己重复创建函数式接口。四大函数式编程接口基本涵盖了80%以上的使用场景了，极少需要自己手动创建这样的接口。

:::

### 7.2 方法引用

方法引用：把已有的方法拿过来用，当做函数式接口中抽象方法的方法体。

#### 方法引用的基本使用

方法引用的要求：
* 引用处必须是函数式接口
* 被引用的方法必须已经存在
* 被引用方法的形参和返回值需要跟抽象方法保持一致
* 被引用方法的功能要满足当前需求

下面通过一个方法引用的实际使用案例来说明如何使用方法引用：

```java
import java.util.Arrays;
import java.util.Comparator;

public class MethodRefDemo {
    public static void main(String[] args) {
        // 创建一个数组，进行倒序排序
        Integer[] arr = { 3, 5, 4, 1, 6, 2 };
        System.out.println("原数组：" + Arrays.toString(arr));

        // 原生写法
        Arrays.sort(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });

        // Lambda表达式
        Arrays.sort(arr, (Integer o1, Integer o2) -> {
            return o2 - o1;
        });
        
        // Lambda表达式简化格式
        Arrays.sort(arr, (o1, o2) -> o2 - o1);

        // 方法引用
        Arrays.sort(arr, MethodRefDemo::subtact);

        System.out.println("倒序后：" + Arrays.toString(arr));
    }

    // 可以是Java自带的，也可以是第三方的
    public static int subtact(int num1, int num2) {
        return num2 - num1;
    }
}
```

在上述排序的案例中，`MethodRefDemo::subtact`表示引用`MethodRefDemo`类中的`subtact`方法来作为`Arrays.sort`方法第二个参数的接口中抽象方法的方法体。（`::`是方法引用符）

方法引用的分类：方法引用可以分为引用静态方法、引用成员方法和引用构造方法，其中，引用成员方法还可以细分为应用其他类的成员方法、引用本类的成员方法和引用父类的成员方法。

#### 引用静态方法

格式：`类名::静态方法名`，例`Integer::parseInt`。

#### 引用成员方法

格式：`对象::成员方法名`，例`System.out::println`。
* 其他类：`其他类对象::方法名`
* 本类：`this::方法名`
* 父类：`super::方法名`

注意：本类和父类的方法引用使用过程中，方法引用处不能是静态方法内，因为静态方法中没有`this`，如果非要在静态方法中使用，那么只能新建一个对象来完成方法引用。

#### 引用构造方法

格式：`类名::new`，例`Random::new`。

练习：集合里面存储姓名和年龄，比如：张无忌，15，要求：将数据封装成`Student`对象并收集到`List`集合中。

题解：

```java
// 学生类设计
package com.triabin.ideasy_server;

/**
 * 类描述：学生类
 *
 * @author Triabin
 * @date 2020-10-04 00:36:40
 */
public class Student {
    /**
     * 学生姓名
     */
    private String name;

    /**
     * 学生年龄
     */
    private int age;

    public Student() {}

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Student(String strItem) {
        String[] items = strItem.split("，");
        this.name = items[0];
        this.age = Integer.parseInt(items[1]);
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public Student setName(String name) {
        this.name = name;
        return this;
    }

    public int getAge() {
        return age;
    }

    public Student setAge(int age) {
        this.age = age;
        return this;
    }
}
```

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class StudentSeloution {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        Collections.addAll(list, "张无忌，15", "赵敏，18", "周芷若，16", "张三丰，107", "周伯通，19", "张翠山，36");
        List<Student> students = list.stream()
                .map(Student::new)
                .toList();
        System.out.println(students);
    }
}
```

说明：
①`list.stream()`意为将`list`集合转换为一个流，流是Java8中新增的一个概念，它可以对集合中的元素进行操作，例如筛选、映射、排序等。可以理解为它能将一个可迭代对象中的元素放到流水线上然后通过流式调用的方式可以对这些流水线上的元素进行操作。这里只做一个简单介绍，后续章节再详细学习。

② `流.map(Function<T,R>)`，这个`map`方法接收一个`Function<T,R>`函数式接口作为参数，用于将接受到的`T`类型参数转换为`R`类型参数。（详见[Java四大函数式编程接口](./random-notes/Java四大函数式编程接口)），将`List<String>`转为流之后调用`map`方法时可以就可以将流水线上的每个元素按照提供的`Function<T,R>`函数式接口中的抽象方法进行转换，将每个元素转换为`Student`对象。

#### 其他调用方式

**使用类名引用成员方法**，格式：`类名::成员方法`，例`String::substring`。

> 题目：集合里面有一些字符串，将它们变成大写后输出。
>
> ```java
> import java.util.ArrayList;
> import java.util.Collections;
> import java.util.List;
> 
> public class MethodRefDemo {
>     public static void main(String[] args) {
>         List<String> list = new ArrayList<>();
>         Collections.addAll(list, "aaa", "bbb", "ccc", "ddd");
>         
>         list.stream().map(String::toUpperCase).forEach(System.out::println);
>     }
> }
> ```

从上面的案例可以看到，`类名::方法名`这样的方式调用到了`String`类中的成员方法`public String toUpperCase()`（注意不是静态方法）。这种方法引用其实是根据函数式接口中抽象方法的第一个参数决定的，必须是该抽象方法参数列表中的**第一个参数**所属类的成员方法才可以这样调用。

上述案例中，`map`的函数式接口`Function<T,R>`的抽象方法`apply(T t)`接收的第一个参数`T`是`String`，而`toUpperCase`是`String`的成员方法，所以可以这么调用。

注意：成员方法的参数列表需要与所需接口的抽象方法参数列表中第二个参数到最后一个参数保持一致，如果只有一个参数，那么成员方法为无参。

**引用数组的构造方法**，格式：`数据类型[]::new`，例`int[]::new`。

> 题目：集合中存储一些整数，收集到数组中。
>
> ```java
> import java.util.Arrays;
> import java.util.Collections;
> import java.util.List;
> 
> public class MethodRefDemo {
>     public static void main(String[] args) {
>         List<Integer> list = new ArrayList<>();
>         Collections.addAll(list, 1, 2, 3, 4, 5);
>         // Integer[] arr = list.toArray(new IntFunction<Integer[]>() {
>         //     @Override
>         //     public Integer[] apply(int value) {
>         //         return new Integer[0];
>         //     }
>         // });
>         // 改为使用方法引用
>         Integer[] arr = list.toArray(Integer[]::new);
>         System.out.println(Arrays.toString(arr));
>     }
> }
> ```
>
> 注意：数组的类型需要跟流中的类型保持一致。

## 8、API&字符串

面向对象其实就学两部分，如何使用别人写好的东西？自己如何设计一个类？

### 8.1 API

API：Application Programming Interface，即应用程序编程接口。简单理解就是别人已经写好的东西，我们不需要自己编写，直接使用即可。例如前文中使用的`Random`对象，就是Java中已经编写好的一个工具类。

JavaAPI：指的就是JDK中提供的各种功能的Java类。这些类将底层的功能实现逻辑封装了起来，我们不需要关心这些类是如何实现的，只需要学习使用这些类即可。

Java帮助文档使用：在Oracle官网，有完整的接口文档，将这些接口文档下载下来，然后打包成了`.CHM`文件，就可以离线进行文档的传递了。该文档中，有JDK全部的类以及类的详细说明文档，如果需要查询某个类，直接搜索类名或者到相应的包下查找即可。

![image-20251225173013380](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/110192666ed55e2c04d1cbd432330307-image-20251225173013380.png)

<div style="clear: both;"></div>

说明：`java.lang`包中存放的是Java的基础类，因此在使用这个包下的类的时候，不需要写`import`导包语句。

一般使用步骤：
* 打开API文档
* 点击显示，并找到索引下面的输入
* 在输入框中输入类名并点击显示
* 查看类所在包
* 查看类的描述
* 查看构造方法
* 查看成员方法

例如查看之前生成随机数所用的`java.util.Random`类：

![image-20251226134113331](https://gitee.com/triabin/img_bed/raw/master/2025/12/26/5aea4428e973b4924787460ffeaa55ce-image-20251226134113331.png)

<div style="clear: both;"></div>

:::warning 注意

① `.CHM`文件在Windows系统中可以直接打开，并正常显示；

② 在macOS中可以去AppStore免费下载`CHM Viewer`，用它打开，但是如果文档中有中文，有可能会遇到乱码，此时需要在软件顶部`工具栏-文本编码`中选择`Unicode (UTF-8)`（每次打开都需要选择一次）；

③ JDK各个版本几乎都比较通用，所以国内使用比较广的就是JDK1.8的中文版本，因为这个版本的中文翻译做得相对详尽（虽然也是机翻，但是够看了😅），真正遇到有差异的工具类时再去官网找对应版本的文档即可（一般几乎遇不到这种情况）；

④ 目前比较流行的中文版本是JDK1.8的一个帮助文档，其他版本大同小异，有需要可取Oracle官网下载，例如[JDK21](https://www.oracle.com/java/technologies/javase-jdk21-doc-downloads.html)，[JDK8中文版本](https://www.123865.com/s/VBJ0Td-0qni)。

:::

### 8.2 字符串

字符串，在Java中可以通过双引号字面量直接获取到字符串对象，对于字符串的操作，前文运算符中一节中已经介绍过拼接，此外，字符串的其他常用的操作还有比较、替换、截取、查找、切割、检索、加密、打乱内容、大小写转换等。

字符串在开发中有着极其广泛的应用，尤其在C端，可以说这是最接近C端直接输入和现实的东西，为了方便对字符串的操作，Java中提供了`java.lang.String`、`java.lang.StringBuilder`、`java.lang.StringBuffer`、`java.util.StringJoiner`、`java.util.regex.Pattern`、`java.util.regex.Matcher`等类对方便对字符串进行操作。

#### String

概述：`java.lang.String`类代表字符串，Java程序中的所有字符串文字（例如"abc"）都为此类对象。

注意点：字符串的内容是不会发生改变的，它的对象在创建后不能被更改。如果将两个字符串拼接，那么它将会产生一个新的字符串。

```java
public class StringDemo {
    public static void main(String[] args) {
        String name = "尼古拉斯·阿伟";
        String schoolName = "迦南学院";
        System.out.println(name + schoolName);
        // 以上三行代码共计产生了三个字符串对象

        Sting str = "String1";
        str = "String2";
        // 以上两行代码共计产生两个字符串对象
    }
}
```

创建字符串对象的两种方式：
* 直接赋值：`String name = "尼古拉斯·阿玮";`

* `new`关键字：
  
  |             构造方法             |                            说明                            |
  | :------------------------------: | :--------------------------------------------------------: |
  |        `public String()`         |               创建空白字符串，不包含任何内容               |
  | `public String(String original)` |              根据传入的字符串，创建字符串对象              |
  |  `public String(char[] value)`   |                根据字符数组，创建字符串对象                |
  |  `public String(byte[] bytes)`   | 根据字节数组，创建字符串对象（有重载方法可传入字符集参数） |
  
  这四种方式，前两种几乎不用，第三种一般用于变更字符串的场景，第四种则在网络编程中有较为广泛的应用，在网络环境中传输的数据一般都是字节信息，包括字符串，在将字节信息转为字符串时，就需要用到这个构造方法。

字符串对象创建的内存模型：目前为止，关于Java的内存模型，已经了解了栈内存、堆内存以及方法区三个逻辑分区，而通过**直接使用双引号字面量赋值的字符串**都存在一个新的分区中——`StringTable`（串池，或者字符串常量池），这个分区在JDK7之前是独立的，但是从JDK7开始，这个分区被挪到了堆内存中，但是其核心逻辑并没有改变。

串池工作原理：当通过双引号字面量直接赋值的方式创建字符串对象的时候，JVM会先检查串池中是否存在该字符串，如果存在直接返回该字符串地址，不存在则创建一个字符串再返回其地址。

`public String(char[] value)`创建字符串对象内存模型：

![image-20251226142037671](https://gitee.com/triabin/img_bed/raw/master/2025/12/26/0875ea3a0e2ba411b8332af30f03be11-image-20251226142037671.png)

<div style="clear: both;"></div>

如上图所示，每`new`一次，都会在堆内存中开辟一块空间来存储相同的字符串，完全没有字符串常量池的复用逻辑。

字符串的比较：

```java
public class StringDemo {
    public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "abc";
        System.out.println(s1 == s2); // true
        
        String s3 = "aaa";
        String s4 = "bbb";
        System.out.println(s3 == s4); // false
        
        String s5 = new String("abc");
        String s6 = "abc";
        System.out.println(s5 == s6); // false
    }
}
```

`==`号比较的内容：基本数据类型比较的是具体的值，引用数据类型比较的是地址值。因此则可以解释上述代码的运行结果了。

在`java.lang.String`中，一共提供了两个方法来实现字符串之间的比较功能：

* `public boolean equals("要比较的字符串")`：完全一样的结果才是`true`，否则为`false`，其实现逻辑如下：

  ```java
  public final class String {
      // ...
      
      public boolean equals(Object anObject) {
          if (this == anObject) {
              return true;
          }
          return (anObject instanceof String aString)
                  && (!COMPACT_STRINGS || this.coder == aString.coder)
                  && StringLatin1.equals(value, aString.value);
      }
  }
  
  final class StringLatin1 {
      @IntrinsicCandidate
      public static boolean equals(byte[] value, byte[] other) {
          if (value.length == other.length) {
              for (int i = 0; i < value.length; i++) {
                  if (value[i] != other[i]) {
                      return false;
                  }
              }
              return true;
          }
          return false;
      }
  }
  ```

* `public boolean equalsIgnoreCase("要比较的字符串")`：功能与`equals`相同，只是忽略大小写（见名知意）。

:::info Tips

在编程过程中难免会遇到未知字符串变量与已知字符串进行比较的情况，例如方法传入的字符串参数`value`与已知字符串`"targetValue"`进行比较，此时应该写成`"targetValue".equals(value)`，因为如果反过来写成`value.equals("targetValue")`，虽然代码能编译通过，但是如果调用方法的时候传入的字符串为`null`，那么这种写法将导致空指针异常（`NullPointerException`，算是Java程序员最常见的异常之一了😅）。

:::

`java.lang.String`类中的常用方法（这里只列举方法名，参数和返回值都可见名知意）：

* 长度：`length`

* 检索：检索则需要了解字符串的索引下标这一个概念，类似数组，第一个字符下标为0，从0开始到`length-1`

  ① `charAt`：用于定位指定字符索引

  ② `indexOf`：用于定位指定字符串在字符串中的起始索引

  ③ `contains`：用于判断是否存在指定字符串，返回布尔值

* 比较：`equals`、`equalsIgnoreCase`、`matches`，`matches`参数为正则表达式
* 替换：`replace`、`replaceAll`，`replaceFirst`，注意后两个方法都是匹配的正则表达式
* 截取：`substring`，注意第一参数为截取的起始索引，第二个参数为截取的结束索引后一位（左闭右开区间），第二个参数如果不填，则从起始索引开始截取全部
* 大小写转换：`toUpperCase/toLowerCase`
* 判空：`isEmpty()`
* 其余方法则在使用到的时候再查即可

#### StringBuilder

String的缺陷：

```java
public class StringDemo {
    public static void main(String[] args) {
        // 拼接百万字符串
        String res = "";
        for (int i = 0; i < 1000000; i++) {
            res += "abc";
        }
        System.out.println(res);
    }
}
```

当运行以上代码时，由于字符串常量池中的字符串不可变，将会短时间内在`StringTable`中产生百万个只在一次循环中使用后就丢弃的字符串常量，造成了内存的大量浪费。`java.lang.StringBuilder`就是为了解决这种问题而设计的。

概述：`StringBuilder`可以看成是一个容器，创建之后，里面的内容是可变的，这将大大提高字符串的操作效率。

构造方法：

* `public StringBuilder()`：创建一个空白可变字符串对象，不含有任何内容
* `publci StringBuilder(String str)`：根据字符串内容创建可变字符串对象

常用方法：

* `public StringBuilder append(任意类型)`，拼接数据并返回对象本身（类似前面介绍的方便链式调用的`setter`方法），参数可以是任意类型，会自动调用对应类型的`toString()`方法（该方法每一个对象一定会有，基本数据类型会自动装箱为包装类，然后调用包装类的`toString`方法）
* `public StringBuilder reverse()`：反转容器中的内容
* `public int length()`：与`java.lang.String`类中的一样，返回字符串长度
* `public String toString()`：将`StringBuilder`转为`String`

> 说明：Java底层对`StringBuilder`、`StringBuffer`等类做了特殊处理，在使用`println`方法打印时，不需要另转为`String`，可以直接打印。

#### StringJoiner

```java
public class StringDemo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3 };
        StringBuilder sb = new StringBuilder("[]");
        for (int i = 0; i < arr.length; i++) {
            if (i == arr.length - 1) {
                sb.append(arr[i]);
            } else {
                sb.append(arr[i]).append(", ");
            }
        }
        sb.append("]");
        System.out.println(sb);
    }
}
```

对于以上代码，拼接类似这样的可迭代的数组，还需要判断索引以确定分隔符“, ”是否添加，繁琐且易出错，于是为了解决这种问题就设计了`java.util.StringJoiner`类，上述代码可以使用它进行改写：

```java
import java.util.StringJoiner;

public class StringDemo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3 };
        StringJoiner sj = new StringJoiner(", ", "[", "]");
        for (int i = 0; i < arr.length; i++) {
            sj.add(arr[i] + "");
        }
        System.out.println(sj);
    }
}
```

概述：

* `StringJoiner`与`StringBuilder`一样，都可以看成是一个容器，创建之后里面的内容是可变的；
* 作用：提高字符串的操作效率，而且代码编辑十分简洁，但是由于是JDK8新特新，实际项目中很少人使用，主要是`StringBuilder`使用习惯了，新生代沿用了下来，并且`String`自身也有一个静态方法`String.join()`用来拼接可迭代对象。

构造方法：

* `public StringJoiner("间隔符号")`：创建一个`StringJoiner`对象，只指定拼接时的间隔符号；
* `public StringJoiner(间隔符号, 开始符号, 结束符号)`：创建一个`StringJoiner`对象，指定拼接时的间隔符号、开始符号、结束符号。

常用方法：

* `public StringJoiner add(String "添加的内容")`：添加数据，并返回对象本身
* `public int length()`
* `public String toString()`

#### 字符串原理

回顾：

* 字符串存储的内存原理：直接复制会复用字符串常量池中的，`new`出来的不会复用，而是开辟一个新的内存空间
* `==`号比较的到底是什么：基本数据类型比较数据值，引用数据类型比较内存地址

字符串拼接的底层原理：

* 等号右边无变量参与

  ```java
  public class StringDemo {
      public static void main(String[] args) {
          String s = "a" + "b" + "c";
          System.out.println(s);
      }
  }
  ```

  这种情况会触发编译器的优化机制，在编译时会将它编译成最终结果“"abc"”。

* 等号右边有变量参与

  ```java
  public class StringDemo {
      public static void main(String[] args) {
          String s1 = "a";
          String s2 = s1 + "b";
          String s3 = s2 + "c";
          System.out.println(s3);
      }
  }
  ```

  <img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/26/00f4bf18c82d44586e2dd1e189d5ebf8-image-20251226154057595.png" alt="image-20251226154057595" align="left"/>
  
  <div style="clear: both;"></div>
  在JDK8以前，会自动使用`StringBuilder`进行拼接，因此在运行类似`String s2 = s1 + "b";`这样一行代码的时候，会创建一个`StringBuilder`对象，然后运行`append`方法将`"b"`拼接到字符串后面，再将`StringBuilder`对象转为`String`对象（通过`new String()`的方式），因此每运行一次这样的拼接以后，都会产生至少一个`String`对象以及在字符串常量池中产生一个拼接目标的字符串常量。这就是直接使用字符串拼接性能低下的原因。
  
  在JDK8中，针对这一情况，对于拼接代码等号右边有变量的情况都会对拼接结果进行一次长度预估，然后创建对应长度的数组，将拼接变量与字符串分别填入数组后再拼接，但是预估以及面对上面这种一个变量就拼接一次的情况，还是会触发多次预估和数组创建，仍浪费时间、内存和性能。

总之，面对多变量字符串拼接的情况，不要直接使用`String`进行拼接，改为使用`StringBuilder`、`StringBuffer`、`StringJoiner`等专门设计的类来进行拼接更为合适。

`StringBuilder`提高效率的原理：所有要拼接的内容都会往`StringBuilder`中存放，不会开辟新的内存空间，节约内存。

`StringBuilder`原码分析：

* 默认创建一个长度为16的字节数组`value`

* 添加的内容长度小于16，直接存

* 添加的内容大于16会扩容（`原来容量 * 2 + 2`）

* 如果扩容后还不够，以实际长度为准进行扩容

* 代码演示：

  ```java
  public class StringBuilderDemo {
      public static void main(String[] args) {
          StringBuilder sb = new StringBuilder();
          System.out.println(sb.capacity()); // 16
          System.out.println(sb.length()); // 0
  
          sb.append("abc");
          System.out.println(sb.capacity()); // 16
          System.out.println(sb.length()); // 3
  
          sb.delete(0, sb.length());
          sb.append("abcdefghijklmnopqrstuvwxyz");
          System.out.println(sb.capacity()); // 34
          System.out.println(sb.length()); // 26
  
          sb.delete(0, sb.length());
          sb.append("abcdefghijklmnopqrstuvwxyz0123456789");
          System.out.println(sb.capacity()); // 36
          System.out.println(sb.length()); // 36
      }
  }
  ```

> 习题：给定两个字符串，A和B。A的旋转操作就是将A最左边的字符移动到最右边，例如，A='abcde'，旋转之后就是'bcdea'，如果在若干次旋转操作之后，A能变成B，返回true，不能则返回false。
>
> 题解：
>
> ```java
> public class Answers {
>     public boolean isRotateMatch(String strA, String strB) {
>         if (strA == null || strB == null) return false;
>         if (strA.length() != strB.length()) return false;
>         if (strA.equals(strB)) return true;
>         for (int i = 0; i < strA.length(); i++) {
>             strA = strA.substring(1) + strA.charAt(0);
>             if (strA.equals(strB)) return true;
>         }
>         return false;
>     }
> }
> ```

## 9、集合

数组的弊端：
* 长度一旦确定，不管索引位置上是否需要存放数据都需要占用内存空间，并且长度一旦固定就不可变；
* 只能使用连续的内存区域，对于那些离散的、分布在物理内存各个位置的空间无法很充分的使用；
* 一个数组只能存放一种数据类型（当然，这应该算优点）。

集合与数组区别：
* 数组可以存基本数据类型和引用数据类型，集合只能存储引用数据类型；
* 数组长度固定，集合长度可变

### 9.1 集合的基本使用

<img src="https://yanglukuan.github.io/images/arrayList/Collections.png" alt="Java集合框架" align="left" />

<div style="clear: both;"></div>

在Java中，所有集合均实现自接口`java.util.Collection`，并且默认实现了很多种集合，每种集合都有其各自功能和特点，在节中，首先学习使用以后应用最广泛集合之一的`java.util.ArrayList`。

结合JDK API文档中关于这个类的构造方法和类方法列表，可以初步了解该类的使用：

| 构造方法和方法描述                                           |
| ------------------------------------------------------------ |
| `ArrayList()`  构造一个初始容量为十的空列表。                |
| `ArrayList(Collection<? extends E> c)`  构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 |
| `ArrayList(int initialCapacity)`  构造具有指定初始容量的空列表。 |

> 泛型：可以限定集合中要存储的数据类型，格式为在类名后面使用`<E>`，尖括号中的`E`就是要存储的数据类型，并且这个泛型只能是引用数据类型，基本数据类型只能用它们的包装类型。

```java
public class CollectionDemo {
    public static void main(String[] args) {
        // ArrayList<String> list = new ArrayList<String>(); // JDK7以前
        ArrayList<String> list = new ArrayList<>(); // JDK7以后
        
        System.out.println(list); // []
        // 由于这个类底层已经做了一些处理（实现了toString()方法），打印对象不是地址值，而是集合中存储的数据内容，并且在展示时会使用中括号包裹。
    }
}
```

成员方法：

| 返回值类型        | 方法名和方法描述                                             |
| ----------------- | ------------------------------------------------------------ |
| `boolean`         | `add(E e)`  将指定的元素追加到此列表的末尾。                 |
| `void`            | `add(int index, E element)`  在此列表中的指定位置插入指定的元素。 |
| `boolean`         | `addAll(Collection<? extends E> c)`  按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 |
| `boolean`         | `addAll(int index,  Collection<? extends E> c)`  将指定集合中的所有元素插入到此列表中，从指定的位置开始。 |
| `void`            | `clear()`  从列表中删除所有元素。                            |
| `Object`          | `clone()`  返回此 `ArrayList`实例的浅拷贝。                  |
| `boolean`         | `contains(Object o)`  如果此列表包含指定的元素，则返回 `true` 。 |
| `void`            | `ensureCapacity(int minCapacity)`  如果需要，增加此 `ArrayList`实例的容量，以确保它可以至少保存最小容量参数指定的元素数。 |
| `void`            | `forEach(Consumer<? super E> action)`  对 `Iterable`的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。 |
| `E`               | `get(int index)`  返回此列表中指定位置的元素。               |
| `int`             | `indexOf(Object o)`  返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 |
| `boolean`         | `isEmpty()`  如果此列表不包含元素，则返回 `true` 。          |
| `Iterator<E>`     | `iterator()`  以正确的顺序返回该列表中的元素的迭代器。       |
| `int`             | `lastIndexOf(Object o)`  返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。 |
| `ListIterator<E>` | `listIterator()`  返回列表中的列表迭代器（按适当的顺序）。   |
| `ListIterator<E>` | `listIterator(int index)`  从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 |
| `E`               | `remove(int index)`  删除该列表中指定位置的元素。            |
| `boolean`         | `remove(Object o)`  从列表中删除指定元素的第一个出现（如果存在）。 |
| `boolean`         | `removeAll(Collection<?> c)`  从此列表中删除指定集合中包含的所有元素。 |
| `boolean`         | `removeIf(Predicate<? super E> filter)`  删除满足给定谓词的此集合的所有元素。 |
| `protected void`  | `removeRange(int fromIndex,  int toIndex)`  从这个列表中删除所有索引在 `fromIndex` （含）和  `toIndex`之间的元素。 |
| `void`            | `replaceAll(UnaryOperator<E> operator)`  将该列表的每个元素替换为将该运算符应用于该元素的结果。 |
| `boolean`         | `retainAll(Collection<?> c)`  仅保留此列表中包含在指定集合中的元素。 |
| `E`               | `set(int index, E element)`  用指定的元素替换此列表中指定位置的元素。 |
| `int`             | `size()`  返回此列表中的元素数。                             |
| `void`            | `sort(Comparator<? super E> c)`  使用提供的 `Comparator`对此列表进行排序以比较元素。 |
| `Spliterator<E>`  | `spliterator()`  在此列表中的元素上创建late-binding和故障快速Spliterator。 |
| `List<E>`         | `subList(int fromIndex,  int toIndex)`  返回此列表中指定的 `fromIndex` （包括）和  `toIndex`之间的独占视图。 |
| `Object[]`        | `toArray()`  以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 |
| `<T> T[]`         | `toArray(T[] a)`  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;  返回的数组的运行时类型是指定数组的运行时类型。 |
| `void`            | `trimToSize()`  修改这个 `ArrayList`实例的容量是列表的当前大小。 |

可以看到，`ArrayList`的成员方法非常多，但是总的来说，（对于这些用于存储多条数据的数据结构）其成员方法可以归咎与四类，分别是增、删、改、查，将这四类方法学会使用后，其余方法可以在使用到的时候再去查看方法注释即可（并且，这类方法连名字都大同小异）。

演示说明代码：

```java
/*
     boolean add(E e)       增
     
     boolean remove(E e)    删
     E remove(int index)
     
     E set(int index, E e)  改
     
     E get(int index)       查
     int size()             获取长度
 */
public class CollectionDemo {
    public static void main(String[] args) {
        // 1、创建一个集合
        ArrayList<String> list = new ArrayList<>();
        
        // 2、添加元素
        boolean addRes = list.add("aaa");
        System.out.println(addRes); // true，这个返回值一般不使用
        System.out.println(list);
        list.add("ccc");
        list.add("aaa");
        list.add("bbb");
        
        // 3、删除元素
        boolean delRes = list.remove("aaa");
        System.out.println(delRes);
        System.out.println(list); // 第一个“"aaa"”元素被删除
        System.out.println(list.remove("ddd")); // false，元素不存在，删除失败
        // ArrayList是有索引的，与数组一样，索引也是从0开始
        String delEle = list.remove(0);
        System.out.println(delEle); // ccc
        System.out.println(list);
        
        // 4、修改元素
        String setRes = list.set(1, "BBB");
        System.out.println(setRes); // bbb，它会将被覆盖的值返回
        System.out.println(list);
        
        // 5、查询
        String getRes = list.get(0);
        System.out.println(getRes); // aaa
        // 遍历
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
}
```

> 一旦访问到`ArrayList`中不存在的索引，也会报索引越界异常`java.lang.IndexOutOfBoundsException`

## 10、常用API

Java写好的各种功能的Java类，不需要刻意记忆，只需要记得类名和类的作用即可，需要的时候再通过API文档去查询即可。

### 10.1 Math

`java.lang.Math`是一个专门用于数学计算的**工具类**，构造方法私有化，所有类都是静态的，对外使用的成员变量也定义为了常量。（自然对数的基数`E`和圆周率`PI`）

`Math`类的常用方法：

|                     方法名                     |                  说明                  |
| :--------------------------------------------: | :------------------------------------: |
|         `public static int abs(int a)`         |            获取参数的绝对值            |
|     `public static double ceil(double a)`      |                向上取整                |
|     `public static double floor(double a)`     |                向下取整                |
|       `public static int round(float a)`       |                四舍五入                |
|     `public static int max(int a, int b)`      |          获取两个数中的较大值          |
| `public static double pow(double a, double b)` |              返回$a^{b}$               |
|        `public static double random()`         | 返回范围为`[0.0, 1.0)`的`double`随机值 |

使用说明：

* 使用`public static int abs(int a)`时，如果传入-2147483648（`int`类型的最小值），由于`int`型的数值最大值为2147483647，该方法将会失效。如果要避免这样的问题，可以使用`public static int absExact(int a)`代替（JDK15新特性），使用该方法，如果传入了`int`最小值，它将会报错`ArithmeticException`，源码：

  ```java
  public static int absExact(int a) {
      if (a == Integer.MIN_VALUE)
          throw new ArithmeticException(
              "Overflow to represent absolute value of Integer.MIN_VALUE");
      else
          return abs(a);
  }
  ```

* `public static double ceil(double a)`功能为数值大小进一，在项目中一般用于类似文件分块这种场景，例如一个文件传输过程中，打算对文件进行分块传输，每个文件块为128MB，对于要传输的文件，你是无法保证其大小始终是128MB的整数倍的，所以需要对`fileSize / blockSize`的结果进行向上取整。

* 对于`public static int max(int a, int b)`，很自然的提供了一个功能相反的方法`public static int min(int a, int b)`。

* 对于`public static double pow(double a, double b)`的使用，一般利用数学的变换将指数转换为一个大于等于1的正整数传入；对开根号，`Math`类提供了`public static double sqrt(double a)`方法来开平方，`public static double cbrt(double a)`来开立方。

* `public static double random()`方法本质上底层使用的也是`Random`类，可能是为了与其他语言保持一致，也有可能是为了`Math`类的完整性，但是它获取整数范围内的数值比较麻烦，例如获取`[10, 90]`之间的数值：`Math.floor(Math.random() * (90 - 10 + 1)) + 10`，解析，`[0, 1)`乘以`90 - 10 + 1`得到`[0, 81)`，向下取整得到`[0, 80]`，再加10，得到范围`[10, 90]`，所以得到如果要取正数区间`[min, max]`之间的随机整数，公式为`Math.floor(Math.random() * (max - min + 1) + min)`。如果是取`[0, max]`则可简化为`Math.floor(Math.random() * (max + 1))`。如果使用`java.util.Random`类取`[0, max]`则可以直接`random.nextXxx(max)`（`Xxx`为具体的基本数据类型），取`[min, max]`则可以使用公式`random.nextXxx(max - min + 1) + min`，推导原理是一样的。

### 10.2 System

`java.lang.System`也是一个工具类，提供了一些与系统相关的方法。

常用方法：

|                            方法名                            |           说明           |
| :----------------------------------------------------------: | :----------------------: |
|            `public static void exit(int status)`             | 终止当前运行的Java虚拟机 |
|       `public static native long currentTimeMillis()`        | 返回当前系统时间的毫秒值 |
| `public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)` |         数组拷贝         |

使用说明：

* `public static void exit(int status)`，状态码`status`为0说明虚拟机是正常停止，非0（一般传1）说明虚拟机异常停止。

* 返回的是**计算机时间原点**（1970年1月1日 00:00:00）到到当前计算机系统时间总共经过了多少毫秒的值，项目中使用非常非常广泛，多用于计算某块代码执行时间，以打印日志。一般使用形式：`long startTime = System.currentTimeMillis();`，要记录的代码块运行结束位置`log.info("xxx总共耗时{}毫秒", System.currentTimeMillis() - startTime)`。

  > 关于计算机时间原点
  >
  > 1969年8月，贝尔实验室的程序员肯汤普逊利用妻儿离开一个月的机会，开始着手创造了一个全新的革命性的操作系统。使用B编译语言在老旧的PDP-7机器上开发出了Unix的一个版本。随后，汤普逊和同事丹尼斯里奇改进了B语言，开发出了C语言，重写了Unix。
  >
  > 于是，就将1970年1月1日零时作为计算机的时间原点，之后的所有时间戳都是以此为时间原点进行计算。
  >
  > 中国处于东八区，所以获取到的时间原点为1970年1月1日 08:00:00，如果要将时间戳转为人眼查看的时间格式，需要注意时区问题，这个之后时间API再详述。

* `public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`参数说明：

  ① `Object src`：数据源（要拷贝的数组）

  ② `int srcPos`：要拷贝数据源数组的起始索引（要从第几个元素开始拷贝），索引不在源数组范围报数组索引越界异常。

  ③ `Object dest`：拷贝数据的目的地（要拷贝到哪个数组），如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错，如果源数组和目标数组都是引用数据类型，那么子类类型可以赋值个父类类型。

  ④ `int destPos`：拷贝数据目的地数组的起始索引（从目的地数组的第几个元素开始放置拷贝的数据），索引不在目的地数组范围，报数组索引越界异常。

  ⑤ `int length`：拷贝数组的数量（从源数组的srcPos开始，要拷贝多少个元素），一旦超过超过目标数组或者源数组长度，就会报数组索引越界异常`ArrayIndexOutOfBoundsException`。

### 10.3 Runtime

`java.lang.Runtim`类表示当前虚拟机的运行环境，这个类里面的方法不是静态的，并且这个类不能创建，只能通过它提供的`getRuntime()`方法获取。

|                方法名                 |                    说明                     |
| :-----------------------------------: | :-----------------------------------------: |
| `public static Runtime getRuntime()`  |            当前JVM的运行环境对象            |
|    `public void exit(int status)`     |                 停止虚拟机                  |
|  `public int abailableProcessors()`   |               获取CPU的线程数               |
|       `public long maxMemory()`       |  JVM能从系统中获取总内存大小（单位：Byte）  |
|      `public long totalMemory()`      | JVM已经从系统中获取总内存大小（单位：Byte） |
|      `public long freeMemory()`       |        JVM剩余内存大小（单位：Byte）        |
| `public Process exec(String command)` |                运行系统命令                 |

使用说明：

* `public static Runtime getRuntime()`，当前虚拟机运行环境唯一，所以运行环境设计成单例模式，所以将构造函数虚拟化，并在类中创建静态私有化实例，再提供此方法对外暴露使用，确保任意位置获取到的都是同一个虚拟机实例。
* `public void exit(int status)`作用与`System`类中的`exit`方法一致，`System.exit(int status)`其实底层就是这个方法。

### 10.4 Object和Objects

#### Object

`java.lang.Object`是Java中的顶尖父类，所有类都直接或间接地继承于`Object`类。它的方法可以被所有的子类访问，所以它的特性非常重要。

|               方法名                |           说明           |
| :---------------------------------: | :----------------------: |
|          `public Object()`          | 空参构造（没有成员变量） |
|     `public String toString()`      |   返回对象的字符串形式   |
| `public boolean equals(Object obj)` |   比较两个对象是否相等   |
|   `protected Object clone(int a)`   |         对象克隆         |

* 关于构造方法，由于无法给所有对象规定统一的成员变量，它没有成员变量，也就只有空参构造，这也是子类构造方法默认调用`super()`的原因之一，因为如果直接父类是`Object`，那么它是没有成员变量的。

* `public String toString()`，这个方法默认返回的是对象的地址值，地址值对于人（运维人员/程序员）来说，没有多大意义，人真正关心的是它的属性值，因此一般都需要手动重写这个方法。`toString`的应用极其广泛，项目中，几乎所有的类都要重写`toString()`方法，重写的内容为将对象的所有属性转为字符串（通过编辑器生成即可），并且这个方法是JavaSDK或者一些第三方包需要打印对象时的默认调用方法，例如Java的`System.out.println`，第三方日志`log4j2`的日志打印函数，底层都会调用对象的`toString`方法，把对象变成字符串然后再打印。

  ```java
  // 案例：
  public class Student {
      /**
       * 学生姓名
       */
      private String name;
  
      /**
       * 学生年龄
       */
      private int age;
  
      @Override
      public String toString() {
          return "Student{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  '}';
      }
  }
  ```

* `public boolean equals(Object obj)`方法底层比较的是地址值，前文已经提到，地址值对于人来说，是没有多大意义的，因此对于那些主要关注属性值的类，需要重写`equals`方法，例如`java.lang.String`、包装类以及其他主要关注数值的类。项目中不常重写，但是一旦重写，就需要连同`public native int hashCode()`一起重写（也都是代码编辑器生成）。

* `protected Object clone(int a)`，把A对象的属性值完全拷贝给B对象，也叫做对象拷贝、对象复制。关于这个方法的使用，由于方法是`protected`的，所有无法直接调用（我们不可能在`java.lang`包下写代码），需要每个类自己去重写方法，此外，还需要在可以被克隆的JavaBean上实现`java.lang.Cloneable`接口，该接口中没有内容，主要作用是标记此类可被克隆，不实现该接口的类即使重写了`clone`方法，调用的时候也会报错`CloneNotSupportedException`。

深克隆与浅克隆：

* 浅克隆：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来；（`java.lang.Object#clone`就是浅克隆）
* 深克隆：基本数据类型拷贝过来，字符串复用串池中的内容，**引用数据类型会重新创建新的**。

深浅克隆代码演示：

```java
public class CloneDemo {
    public static void main(String[] args) throws IOException {
        CloneBean bean = new CloneBean(1, "cloneDemo", new int[] { 1, 3, 5 });
        CloneBean cloneBean = bean.clone();
        System.out.println("修改克隆对象前原对象：" + bean); // 修改克隆对象前原对象：CloneBean{id=1, name='cloneDemo', scores=[1, 3, 5]}
        cloneBean.id = 2;
        cloneBean.name = "cloneDemo2";
        cloneBean.scores[0] = 2;
        cloneBean.scores[1] = 4;
        cloneBean.scores[2] = 6;
        System.out.println("修改克隆对象后原对象：" + bean); // 修改克隆对象后原对象：CloneBean{id=1, name='cloneDemo', scores=[2, 4, 6]}
    }

    static class CloneBean implements Cloneable {
        int id;
        String name;
        int[] scores;

        @Override
        public String toString() {
            return "CloneBean{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", scores=" + Arrays.toString(scores) +
                    '}';
        }

        public CloneBean(int id, String name, int[] scores) {
            this.id = id;
            this.name = name;
            this.scores = scores;
        }

        @Override
        public CloneBean clone() {
            try {
                return (CloneBean) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new AssertionError();
            }
        }
    }
}
```



:::warning 注意

① 如果在Java接口中，里面没有任何抽象方法以及其他内容，那么这个接口就是一个标记接口。

② 如果要深克隆，可以考虑将对象转为JSON再通过JSON获取新对象。

:::

#### Objects

`java.util.Objects`是一个工具类，提供了一些常用方法。

|                       方法名                       |                           说明                            |
| :------------------------------------------------: | :-------------------------------------------------------: |
| `public static boolean equals(Object a, Object b)` |               先做非空判断，再比较两个对象                |
|     `public static boolean isNull(Object obj)`     | 判断对象是否为`null`，为`null`返回`true`，反之返回`false` |
|    `public static boolean nonNull(Object obj)`     |        判断对象是否为`null`，跟`isNull`的结果相反         |

使用说明：

* `public static boolean equals(Object a, Object b)`，方法的底层会判断`a`是否为空，为空直接返回`false`，不为空就利用`a`调用`equals`方法。

### 10.5 BigInteger和BigDecimal

#### BigInteger

在Java中，整数有四种类型：`byte`、`short`、`int`、`long`，这几种数据类型，最多占用8个字节，尽管能表示的数非常大，但是终归是有数值范围限制，因此Java设计了`java.math.BigInteger`类来解决这种问题。

构造方法：

|                    方法名                    |                  说明                  |
| :------------------------------------------: | :------------------------------------: |
|   `public BigInteger(int num, Random rnd)`   | 获取随机大整数，范围$[0, 2^{num - 1}]$ |
|       `public BigInteger(String val)`        |             获取指定大整数             |
|  `public BigInteger(String val, int radix)`  |          获取指定进制的大整数          |
| `public static BigInteger valueOf(long val)` |      静态方法获取`BigInteger`对象      |

使用说明：

* 构造方法参数中的`String val`必须是整数字符串，否则报错`NumberFormatException`。
* `BigInteger`对象一旦创建，里面存储的值不可变。
* 对于`public BigInteger(String val, int radix)`，其中字符串必须与`radix`指定的进制匹配，否则报错`NumberFormatException`。
* `public static BigInteger valueOf(long val)`，能获取的范围有限，只能获取`long`类型的数值范围内的数。对于常用数字`-16~16`有内部有优化，提前将这些数字的`BigInteger`对象创建好，如果多次获取，不会创建新的。
  ```java
  import java.math.BigInteger;
  
  public class BigIntegerDemo {
      public static void main(String[] args) {
          BigInteger num1 = BigInteger.valueOf(16);
          BigInteger num2 = BigInteger.valueOf(16);
          System.out.println(num1 == num2); // true
  
          BigInteger num3 = BigInteger.valueOf(-17);
          BigInteger num4 = BigInteger.valueOf(-17);
          System.out.println(num3 == num4); // false
          System.out.println(num3.equals(num4)); // true
      }
  }
  ```
* 对象一旦创建，不会发生改变，即使调用加减乘除等方法进行了运算，返回的也是一个新的`BigInteger`对象。

常见成员方法：

|                          方法名                          |                说明                 |
| :------------------------------------------------------: | :---------------------------------: |
|         `public BigInteger add(BigInteger val)`          |                加法                 |
|       `public BigInteger subtract(BigInteger val)`       |                减法                 |
|       `public BigInteger multiply(BigInteger val)`       |                乘法                 |
|        `public BigInteger divide(BigInteger val)`        |                除法                 |
| `public BigInteger[] divideAndRemainder(BigInteger val)` |         除法，获取商和余数          |
|            `public boolean equals(Object x)`             |            比较是否相同             |
|            `public BigInteger(int exponent)`             |                次幂                 |
|       `public BigInteger max/min(BigInteger val)`        |           返回较大/较小值           |
|                 `public int intValue()`                  | 转为`int`类型整数，超出范围数据有误 |

使用说明：

* 加减乘除省略，对于`public BigInteger[] divideAndRemainder(BigInteger val)`返回的数组，索引0是商，1是余数。
* 对于`public BigInteger max/min(BigInteger val)`，返回的就是原对象，并没有创建新的对象。
* `public int invValue(BiigInteger val)`，如果值超出`int`取值范围，数据有误（不报错）。除了`int`类型之外，也可以转为其他数值类型，包括浮点型`xxxValue`，其中`xxx`就是需要的基本数值类型。

`BigInteger`底层存储方式：对于计算机而言，是没有数据类型的概念的，数据类型是编程语言自己规定的。在`BigInteger`中，利用`final int signum;`来表示符号，`signum`为1表示正数，为-1表示负数，为0表示0，然后将要存储的数值转为补码后，再以每32位为一组，再将每组补码转回10进制（32位，即4个字节，刚好是一个`int`型数字），存储在`final int[] mag;`数组中。

`BigInteger`存储上限：根据`BigInteger`的底层存储方式可知，它使用`int`数组存储数据，而数组的索引是有上限的，上限值为`Integer.MAX_VALUE`，即$2^{31} - 1$，`int`型数值的最大值。（不过达到这个数值几乎不太可能了）

#### BigDecimal

计算机中，小数运算不精确的问题：

```java
public class BigDecimalDemo {
    public static void main(String[] args) {
        System.out.println(0.09 + 0.01); // 0.09999999999999999
        System.out.println(0.216 - 0.1); // 0.11599999999999999
        System.out.println(0.226 * 0.01); // 0.0022600000000000003
        System.out.println(0.09 / 0.1); // 0.8999999999999999
    }
}
```

小数的存储：计算机中，数值的运算都是在二进制下进行，`float`和`double`等浮点型数据用于存储小数的比特位是有限的，当十进制的小数转为二进制时，其小数位数很有可能超出浮点型数据类型的存储位数（如下图），超出部分只能舍去。

![image-20260106151801918](https://gitee.com/triabin/img_bed/raw/master/2026/01/06/1c62091efcc0d8b204736358c858f220-image-20260106151801918.png)
<div style="clear: both;"></div>

在计算机项目开发中，有些场景对于数据的精确度有着很高的要求，例如银行、金融以及航空航天等，所以Java设计了`java.math.BigDecimal`类，用于高精度的小数运算以及表示很大的小数。

构造方法的使用说明：
* 对于`public BigDecimal(double val)`，不建议使用这个构造方法，因为`double`在存储阶段就有可能已经出现了谬误（位数超出截取问题），此时再用它来获取到的`BigDecimal`对象，只能是一个不准确的对象，因此和`BigInteger`一样，还是推荐使用`public BigDecimal(String val)`构造方法，更为简单易用。

  ```java
  import java.math.BigDecimal;
  
  public class BigDecimalDemo {
      public static void main(String[] args) {
          BigDecimal num1 = new BigDecimal(0.09);
          BigDecimal num2 = new BigDecimal(0.01);
          System.out.println(num1); // 0.0899999999999999966693309261245303787291049957275390625
          System.out.println(num2); // 0.01000000000000000020816681711721685132943093776702880859375
      }
  }
  ```
  
* 也可以通过静态方法`public static BigDecimal valueOf(long/double val)`获取实例。内存优化：如果传入`long`型，并且数值范围为`[0, 10]`，则可以直接返回提前创建好的对象（缓冲区/缓存），不会创建新对象。

* 如果要表示的数字不大，没有超出`double`的取值范围，建议使用静态方法，如果超出范围，建议使用构造方法。

常见成员方法：

|                            方法名                            |               说明               |
| :----------------------------------------------------------: | :------------------------------: |
|        `public static BigDecimal valueOf(double val)`        |             获取对象             |
|           `public BigDecimal add(BigDecimal val)`            |               加法               |
|         `public BigDecimal subtract(BigDecimal val)`         |               减法               |
|         `public BigDecimal multiply(BigDecimal val)`         |               乘法               |
|         `public BigDecimaol mdivide(BigDecimal val)`         |               除法               |
| `public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)` | 除法，指定保留小数位数和舍入模式 |

方法使用说明：
* `public static BigDecimal valueOf(double val)`，由于传入的不是`long`型数据，即使数值范围在`[0, 10]`，也不会直接返回缓存中的对象，而是先将其转为`String`型，再调用`public BigDecimal(String val)`构造方法。
* `public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)`，在JDK9已经标记为过时，因为考虑到舍入模式不应该定义在`java.math.BigDecimal`类中，于是将其单独定义为一个枚举类`java.math.RoundingMode`（枚举类为一种特殊的类，现在可以暂时理解为它的对象无法手动创建并且都是常量），并重新定义一个舍入模式为枚举对象的方法来完成同样的功能，方法为`public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)`，而关于`RoundingMode`中，也定义了几种舍入模式，常用的还是四舍五入`HALF_UP`。

`java.math.RoundingMode`枚举常量：

|   枚举常量    | 名称 |                             作用                             |
| :-----------: | :--: | :----------------------------------------------------------: |
|     `UP`      |向上舍入|                        向远离零的方向舍入。无论正负，都向数值变大的方向进一位。                        |
|    `DOWN`     |向下舍入|                         向接近零的方向舍入。无论正负，都向数值变小的方向舍弃。                         |
|   `CEILING`   |向正无穷大舍入|                      向正无穷方向舍入。正数时相当于UP，负数时相当于DOWN。                      |
|    `FLOOR`    |向负无穷大舍入|                      向负无穷方向舍入。正数时相当于DOWN，负数时相当于UP。                      |
|   `HALF_UP`   |四舍五入| 最经典的四舍五入。舍弃部分`>= 0.5`时向上(UP)，否则向下(DOWN)。 |
|  `HALF_DOWN`  |五舍六入| 舍弃部分`> 0.5`时向上(UP)，否则向下(DOWN)。0.5被舍弃。 |
|  `HALF_EVEN`  |四舍六入五成双| 银行家舍入法。若舍弃部分左边的数字是奇数，则HALF_UP；若是偶数，则HALF_DOWN。 |
| `UNNECESSARY` |不舍入|   断言操作结果是精确的，无需舍入。若需要舍入，则抛出`ArithmeticException`。   |

`BigDecimal`底层存储方式：由于一些小数的二进制很长很长，如果`BigDecimal`使用和`BigInteger`相同的方式来存储数据的话，操作起来效率较低切浪费内存，所以`BigDecimal`设计了一套自己的存储方案。`BigDeciaml`在创建对象的时候，都会将数值转为字符串，然后再将字符串拆分为一个个字符（包括负号`-`和小数点`.`），然后将这些字符转为ASCII码后，按照顺序存储到`byte`数组中。

`BigDecimal`存储的数值上限：与`BigInteger`一样，也是受限于数组的长度`Integer.MAX`，近乎无限。

### 10.6 正则表达式

在Java中关于正则表达式的应用参见[正则表达式（Java）](../common/正则表达式（Java）)。

### 10.7 时间日期类

> 关于时间的一些地理知识
>
> 以前，以地球0度经线位的时间为标准时间（本初子午线），英国伦敦的格林威（尼）治天文台就在这条线上，因此以前的世界时间也叫格林威治时间（Greenwich Mean Time，即**GMT**）。
>
> 对于地球上的每一个地方来说，太阳直射时为正午12点，地球上的时间需要一个统一的计算标准，而计算的核心就是地球的自转，地球自转一周是24小时，于是将地球从经度方向分为24个不同的时区，本初子午线所在时区为零时区，往西为西时区共12个，与本初子午线每差一个时区时间就早一个小时；往东为东时区也是12个，东西十二区重叠在一起（注意，重叠在一起，不代表时间相同，因为时间实际上是人为规定的），时区与本初子午线每差一个时区时间就往后晚一个小时。中国所使用的时间北京时间就是东八区时间，而东八区的标准时间实际上在上海，因此Linux系统或者一些地方表示中国时间的时候只能选`Asia/Shanghai`。
>
> 由于东西十二区重叠，为了避免该时区内的人日期混乱，于是规定了一条国际日期变更线（日界线），变更线东侧日期减一天，西侧日期加一天。为了避免同一个国家/地区两个时间的尴尬情况，该变更线从180度经线附近延伸出来后多处采用曲折走向避开陆地，并且也经过多次变更。
>
> 然而，实际上地球的自转并不是均匀的，这就会导致出现记录的实际时间与自转时间出现误差的情况，据统计，最大误差长达16分钟。
>
> 2012年1月，取消用了将近130年的格林威治标准时间，标准时间改为使用原子钟提供。原子钟是利用铯原子的震动频率计算出来的时间，作为世界标准时间（**UTC**），铯原子每震动9192631770次等于1秒。

需要了解的前置知识：

* 以前的标准时间为格林威治时间（Greenwich Mean Time，即**GMT**），现在的标准时间为原子钟提供的时间**UTC**。
* 中国处于东八区，时间为标准时间加8小时。
* 1秒＝1000毫秒，1毫秒＝1000微秒，1微秒＝1000纳秒
* 时间原点：`1970-01-01 00:00:00.000`

#### `Date`时间

`java.util.Date`是一个Java写好的JavaBean类，用来描述时间，精确到毫秒。利用空参构造创建对象，默认表示系统当前时间，利用有参构造则表示创建指定时间。

根据以上初步功能再结合之前学过的面向对象的设计，其实可以推测`Date`类的核心设计：定义一个字段来存储当前时间戳，空参构造使用`System.currentTimeMillis()`获取当前时间戳，有参构造则传入一个`long`型的数字。再配合存储时间戳的变量的`getter/setter`即可初步完成对`Date`类的设计与使用。事实上，`java.util.Date`类的设计确实差不多就是这样：

<img src="https://gitee.com/triabin/img_bed/raw/master/2026/01/06/227eb354150a62d7e9648a9b290fcf69-image-20260106172442407.png" alt="image-20260106172442407" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

> 通过练习题熟悉这些方法特性的使用：
>
> 需求1：打印时间原点开始一年之后的时间。
>
> 需求2：定义任意两个`Date`对象，比较一下哪个时间在前，哪个时间在后。
>
> ```java
> import java.util.Date;
> import java.util.Random;
> 
> public class DateDemo {
>     public static void main(String[] args) {
>         solution1(); // 时间原点一年以后的时间为：Fri Jan 01 08:00:00 CST 1971
>         solution2();
>     }
> 
>     /**
>      * 题解1
>      */
>     public static void solution1() {
>         Date date = new Date(0L);
> 
>         long time = date.getTime() + 365 * 24 * 60 * 60 * 1000L;
>         date.setTime(time);
>         System.out.println("时间原点一年以后的时间为：" + date);
>     }
> 
>     public static void solution2() {
>         Random random = new Random();
>         long currentTime = System.currentTimeMillis();
>         Date date1 = new Date(random.nextLong(currentTime));
>         Date date2 = new Date(random.nextLong(currentTime));
>         if (date1.getTime() >  date2.getTime()) {
>             System.out.println("在前面的时间为：" + date2);
>             System.out.println("在后面的时间为：" + date1);
>         } else if (date2.getTime() >  date1.getTime()) {
>             System.out.println("在前面的时间为：" + date1);
>             System.out.println("在后面的时间为：" + date2);
>         } else {
>             System.out.println("时间相同：" + date1);
>         }
>     }
> }
> ```

关于`Date`类中的其他方法，不管是静态方法还是成员方法，都比较见名知意，属于一看就知道怎么用的那种，就不详细介绍了。

#### `SimpleDateFormat`格式化时间

从前面的联系中可以看到，默认的`Date`类`toString`方法返回的结果是不利于直接查看的`Fri Jan 01 08:00:00 CST 1971`，对于时间对象的使用，每个国家所需的显示标准是不一样的，而且在开发过程中，也有将字符串转为`Date`对象的需求，于是就设计了`java.text.SimpleDateFormat`来格式化或者解析时间。例，使用`SimpleDateFormat`可以将`Date`对象转为诸如`2017-09-01 08:56:16`、`2020年6月`这样格式的字符串，也可以将对应格式字符串转为`Date`对象。

|                 构造方法                  |                     说明                     |
| :---------------------------------------: | :------------------------------------------: |
|        `public SimpleDateFormat()`        | 构造一个`SimpleDateFormat`对象，使用默认格式 |
| `public SimpleDateFormat(String pattern)` | 构造一个`SimpleDateFormat`对象，使用指定格式 |

|                常用方法                 |            说明            |
| :-------------------------------------: | :------------------------: |
| `public final String format(Date date)` | 格式化（`Date -> String`） |
|   `public Date parse(String source)`    |  解析（`String -> Date`）  |

格式化的时间形式常用的模式对应关系：

* `y`：年，如果使用`yy`，则取后两位，如果是`yyyy`，则是完整的年份
* `M`：月，如果取`MM`，则月份小于10的时候，补0，`M`不补0
* `d`：日，日期在当前月份中的第几天，补0规则同上
* `H`：时，24小时制的时间，补0规则同上，如果是小写的`h`，则采用12小时制，使用12小时制时可以使用`a`来显示`AM/PM`（具体显示上下午的内容取决于系统语言，中文的话显示的是`上午/下午`）
* `m`：分，补0规则同上
* `s`：秒，补0规则同上
* `S`：毫秒，只需要一个`S`，就可以显示三位数的毫秒数，或者也可以使用`SSS`，这样不足位数的时候也会补0
* `E`：星期，会显示系统语言本地对于星期的名称，例如中文的`周几`

以上为开发过程中会用到的几乎全部匹配符了，如果还有其他需求，可以查阅JDK的API文档`java.text.SimpleDateFormat`。以下是关于它的基本使用演示：

```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class SDFDemo {
    public static void main(String[] args) throws ParseException {
        long currentTimeMillis = System.currentTimeMillis();
        System.out.println("当前时间戳：" + currentTimeMillis); // 1610005955415L

        // 创建Date对象
        Date date = new Date(currentTimeMillis);
        // 将其格式化为：yyyy-MM-dd HH:mm:ss
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format = sdf.format(date);
        System.out.println("格式化后的时间：" + format); // 2021-01-07 15:52:35
        // 将格式化后的字符串解析回去
        Date parse = sdf.parse(format);
        System.out.println("解析后的时间戳：" + parse.getTime()); // 1610005955000
    }
}
```

说明：上述时间戳前后不一致的原因是因为格式`yyyy-MM-dd HH:mm:ss`中不包含对毫秒数的格式化，导致了字符串转回日期对象的时候丢失了毫秒数，所以转换回来的时间戳最后三位全部归零。另外，在调用`parse`方法的时候，如果要解析的时间字符串与格式字符串格式不匹配，可能会抛出`ParseException`异常。

:::info Tips

① `SimpleDateFormat`中文系统语言下，默认的匹配模式为Windows系统：`yyyy/M/d aH:mm`，Unix系统：`yyyy/M/d HH:mm`，不过最好不要用这个，不确定性太强；

② 开发过程中最好在项目中规划好常用的几种格式化模式（例如`yyyy-MM-dd HH:mm:ss`、`yyyy/MM/dd`、`yyyy年MM月dd日 HH:mm:ss`等），然后将其作为常量规定好，之后所有人在使用时间格式化的时候都先去常量中找，找不到再考虑自定义或扩充常量，这样既能方便使用，又能统一项目中的时间格式化格式。

:::

#### `Calendar`日历

在有了`Date`类之后，关于日期的使用，又遇到了新的问题，比如，如果我只想给当前日期对象的月份加一，那样并不是简单的给时间戳加上`30 * 24 * 60 * 60 * 1000L`就行了的，还需要判断大小月份、是否为2月等一系列关于日历的复杂问题，于是就设计了`java.util.Calendar`日历类来专门解决这些问题。

`Calendar`代表了系统当前时间的日历对象，可以单独修改、获取时间中的年、月、日。此外，`Calendar`是一个抽象类，不能直接创建对象，只能通过它提供的静态方法`public static Calendar getInstance()`获取子类实例，并且这个静态方法还能通过传入对应的地区或者时区对象获取指定地区的日历实例，不传则获取系统所在地区的日历实例。

`public static Calendar getInstance()`底层实现细节：会根据系统时区来获取不同的日历对象（默认为当前时间），目前（截至JDK21）只有三个选项，分别是佛教日历`BuddhistCalendar`、日本历`JapaneseImperialCalendar`以及格林威治日历`GregorianCalendar`，一般都是返回第三个，会将时间中的纪元、年、月、日、时、分、秒、星期等信息都放到一个数组中。

常用方法：

|                   方法名                   |            说明             |
| :----------------------------------------: | :-------------------------: |
|       `public final Date getTime()`        |        获取日期对象         |
|     `public final setTime(Date date)`      |   给日历对象设置日期对象    |
|      `public long getTimeInMillis()`       |  获取日历日期的时间毫秒值   |
| `public void setTimeInMillis(long millis)` |    给日历设置时间毫秒值     |
|        `public int get(int field)`         |   获取日历中某个字段信息    |
|  `public void set(int field, int value)`   |   修改日历的某个字段信息    |
|  `public void add(int field, int amount)`  | 为某个字段增加/减少指定的值 |

使用说明：

* 关于日历对象中时间的获取与修改，可以通过`Date`对象来操作也可以通过时间戳来操作（即上表中的前四个方法）；

* `public int get(int field)`：对于属性的获取，传参虽然是一个数字（底层使用数组存放数据），但是一般不会使用数字字面量，而是已经在`Calendar`中定义了大量的`int`常量，这些常量名基本都见名知意。

  要关注的点：

    ① 月份的取值范围是`[0, 11]`，0表示1月（坑爹玩意儿😒）；

    ② 星期的数值，1为星期天，7为星期六（老外认为星期天是一周的起点）。

    ③ 常用的属性：`1:Calendar.YEAR`、`2:Calendar.MONTH`、`5:Calendar.DATE/Calendar.DAY_OF_MONTH`（开发者认为`DATE`不够见名知意就改了）、`7:Calendar.DAY_OF_WEEK`

* `public void add(int field, int amount)`，`amount`可以传负数，传入负数代表减。

> 由于时间相关的这三个类功能各异以及比较分散，项目中，一般会创建一个`DateUtils`之类的工具类，里面会整合三个类以及放置时间格式化所需格式常量等，以方便项目中关于时间的各种公共方法调用。
>
> 对于星期和月份的问题，可以定义类似这样的数组`String[] weeks = { "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" };`，然后就能直接将`Calendar`类返回的值与数组索引对应上了。

#### JDK8新增时间相关类

在之前的时间日期类使用中，对于两个时间字符串之间的比较，涉及到解析、以及格式化模式字符串这种魔法值的管理，最终比较还需要使用毫秒值进行比较。还有计算时间间隔也需要转为毫秒值再转为其他单位，操作过于繁琐。并且，对于`Date`对象的修改，如果在多线程情况下操作，还涉及到数据安全问题。于是JDK8中，重新设计了时间类，提供了比较先后、计算时间间隔等方法，并且创建时间类也是通过具体的年月日时分秒等整数类型。此外，为了解决线程安全问题，新设计的时间类创建的对象都是不可变的。

JDK8新增了10个时间相关的类，可以分为四个种类，时间日期类`Date`、格式化类`SimpleDateFormat`、日历类`Calendar`以及工具类。

① **时间日期类**：

* `java.time.ZoneId`：时区
  时区格式：`大洲英文名/城市英文名`，例如`Asia/Shanghai`、`Asia/Taipei`、`Asia/Chongqing`、`America/New_York`等。
  
  |                      方法名                       |           说明           |
  | :-----------------------------------------------: | :----------------------: |
  | `public static Set<String> getAvailableZoneIds()` | 获取Java中支持的所有时区 |
  |      `public static ZoneId systemDefault()`       |     获取系统默认时区     |
  |     `public static ZoneId of(String zoneId)`      |     获取一个指定时区     |
  
  使用说明：
  
  * `public static Set<String> getAvailableZoneIds()`，返回的是一个`java.util.Set`集合类对象，`Set`后续再学习，现在只需要知道他是一个类似于`ArrayList`的类即可，区别就是`ArrayList`元素可以重复而`Set`的元素不可以重复（重复添加无效），并且`Set`查找元素效率一般较高。
  *  `public static ZoneId of(String zoneId)`，如果传入的参数不在Java的支持列表中，则抛出`ZoneRulesException`异常，如果不指定时区ID，则报`DateTimeException`异常。
  
* `java.time.Instant`：时间戳

  |                      方法名                      |                  说明                   |
  | :----------------------------------------------: | :-------------------------------------: |
  |          `public static Instant now()`           | 获取当前时间的`Instant`对象（标准时间） |
  |  `public static Instant ofXxx(long epochMilli)`  |  根据（秒/毫秒/纳秒）获取`Instant`对象  |
  |    `public ZonedDateTime atZone(ZoneId zone)`    |                指定时区                 |
  |   `public boolean isXxx(Instant otherInstant)`   |             判断系列的方法              |
  | `public Instant minusXxx(long millisToSubtract)` |           减少时间系列的方法            |
  | `public Instant plusXxx(long millisToSubtract)`  |           增加时间系列的方法            |

  使用说明：

  * `public static Instant now()`获取到的是一个**不带时区的**标准时间。
  * `public static Instant ofXxx(long epochMilli)`，根据方法名见名知意，`ofEpochMilli(long epochMilli)`为通过毫秒值获取时间戳的方法，`ofEpochSecond(long epochSecond)`为通过秒获取时间戳的方法，`ofEpochSecond(long epochSecond, long nanoAdjustment)`为通过秒和纳秒获取时间戳对象的方法（若只想通过纳秒数获取，确保参数`epochSecond`为0即可）。
  * `public ZonedDateTime atZone(ZoneId zone)`，获取到一个没有时区的时间戳对象之后，调用这个方法可以返回一个带时区的`ZonedDateTime`对象。
  *  `public boolean isXxx(Instant otherInstant)`，与传统的`Date`对象一样，主要有两个方法`isAfter`和`isBefore`，用于判断时间先后的。
  * `minusXxx`和`plusXxx`都有三个方法，分别是纳秒、毫秒和秒，用于增减时间，由于`Instant`对象不可变，因此操作后返回的是一个新的对象。

* `java.time.ZonedDateTime`：带时区的时间

  |                方法名                 |                         说明                          |
  | :-----------------------------------: | :---------------------------------------------------: |
  |  `public static ZonedDateTime now()`  |           获取当前时间的`ZoneDateTime`对象            |
  | `public static ZonedDateTime of(...)` | 重载了多个方法，用于获取指定时间的`ZonedDateTime`对象 |
  | `public ZonedDateTime withXxx(时间)`  |                  修改时间系列的方法                   |
  | `public ZonedDateTime minusXxx(时间)` |                  减少时间系列的方法                   |
  |  `public ZoneDateTime plusXxx(时间)`  |                  增加时间系列的方法                   |

  使用说明：

  * `public static ZonedDateTime of(...)`，参数列表可以传递时分秒和时区以及`LocalDate`系列值以及`Instant`值等来获取指定时间的`ZonedDateTime`对象，总之见名知意即可。
  * `public ZonedDateTime withXxx(时间)`，修改年月日时分秒等一系列的参数，具体看参数列表和`with`后面的单词，都是见名知意的。由于`ZonedDateTime`对象一经创建不可更改，所以修改后会返回一个新的对象。
  * `public ZonedDateTime minusXxx(时间)`与`public ZoneDateTime plusXxx(时间)`一样，具体增减的值也都是看`Xxx`具体是哪个单词。由于`ZonedDateTime`对象一经创建不可更改，所以修改后会返回一个新的对象。

② **日期格式化类**：

* `java.time.format.DateTimeFormatter`：用于时间的格式化和解析

  |                           方法名                            |        说明        |
  | :---------------------------------------------------------: | :----------------: |
  | `public static DateTimeFormatter ofPattern(String pattern)` |    获取格式对象    |
  |                   `public String format`                    | 按照指定方式格式化 |

③ **日历类**：

* `java.time.LocalDate`：年、月、日
* `java.time.LocalTime`：时、分、秒
* `java.time.LocalDateTime`：年、月、日、时、分、秒

三个类常用方法：

|           方法名            |                   说明                   |
| :-------------------------: | :--------------------------------------: |
|  `public static Xxx now()`  |            获取当前时间的对象            |
| `public static Xxx of(...)` |            获取指定时间的对象            |
|       `get`开头的方法       | 获取日历中的年、月、日、时、分、秒等信息 |
|    `isBefore`、`isAfter`    |        比较两个对象代表的时间先后        |
|        `with`开头的         |            修改时间系列的方法            |
|      `plusminus`开头的      |            增减时间系列的方法            |

`LocalDateTime`转为`LocalDate`和`LocalTime`的方法：

|              方法名              |                说明                |
| :------------------------------: | :--------------------------------: |
| `public LocalDate toLocalDate()` | `LocalDateTime`转为`LocalDate`对象 |
| `public LocalDate toLocalTime()` | `LocalDateTime`转为`LocalTime`对象 |

④ **工具类**：

* `java.time.Duration`：时间间隔（秒、纳秒）

  ```java
  public class DurationDemo {
      public static void main(String[] args) {
          // 当前本地年月日
          LocalDateTime now = LocalDateTime.now();
          System.out.println("现在：" + now);
          // 生日
          LocalDateTime birthday = LocalDateTime.of(1998, 5, 2, 0, 28, 53, 822324);
          System.out.println("生日：" + birthday);
          // 计算年龄
          Duration duration = Duration.between(birthday, now);
          System.out.println("Duration: " + duration);
          System.out.println("天数：" + duration.toDays());
          System.out.println("小时数：" + duration.toHours());
          System.out.println("分钟数：" + duration.toMinutes());
          System.out.println("秒数：" + duration.getSeconds());
          System.out.println("毫秒数：" + duration.toMillis());
          System.out.println("纳秒数：" + duration.toNanos());
      }
  }
  ```

  

* `java.time.Period`：时间间隔（年、月、日）

  ```java
  public class PeriodDemo {
      public static void main(String[] args) {
          // 当前本地年月日
          LocalDate today = LocalDate.now();
          System.out.println("今天：" + today);
          // 生日
          LocalDate birthday = LocalDate.of(1998, 5,2);
          System.out.println("生日：" + birthday);
          // 计算年龄
          Period period = Period.between(birthday, today);
          System.out.println("Period: " + period);
          System.out.println("年龄：" + period.getYears());
          System.out.println("月数：" + period.getMonths());
          System.out.println("天数：" + period.getDays());
  
          System.out.println("总月数：" + period.toTotalMonths());
      }
  }
  ```

* `java.time.temporal.ChronoUnit`：时间单位枚举（所有单位），并且提供了计算时间差的方法

  ```java
  public class ChronoUnitDemo {
      public static void main(String[] args) {
          // 当前本地年月日
          LocalDateTime now = LocalDateTime.now();
          System.out.println("现在：" + now);
          // 生日
          LocalDateTime birthday = LocalDateTime.of(1998, 5, 2, 0, 28, 53, 822324);
          System.out.println("生日：" + birthday);
          // 计算时间差
          System.out.println("相差的纪元数：" + ChronoUnit.ERAS.between(birthday, now));
          System.out.println("相差的千年数：" + ChronoUnit.MILLENNIA.between(birthday, now));
          System.out.println("相差的世纪数：" + ChronoUnit.CENTURIES.between(birthday, now));
          System.out.println("相差的十年数：" + ChronoUnit.DECADES.between(birthday, now));
          System.out.println("相差的年数：" + ChronoUnit.YEARS.between(birthday, now));
          System.out.println("相差的月数：" + ChronoUnit.MONTHS.between(birthday, now));
          System.out.println("相差的周数：" + ChronoUnit.WEEKS.between(birthday, now));
          System.out.println("相差的天数：" + ChronoUnit.DAYS.between(birthday, now));
          System.out.println("相差的小时数：" + ChronoUnit.HOURS.between(birthday, now));
          System.out.println("相差的分钟数：" + ChronoUnit.MINUTES.between(birthday, now));
          System.out.println("相差的秒数：" + ChronoUnit.SECONDS.between(birthday, now));
          System.out.println("相差的毫秒数：" + ChronoUnit.MILLIS.between(birthday, now));
          System.out.println("相差的微秒数：" + ChronoUnit.MICROS.between(birthday, now));
          System.out.println("相差的纳秒数：" + ChronoUnit.NANOS.between(birthday, now));
      }
  }
  ```

### 10.8 包装类

![image-20260109142609483](https://gitee.com/triabin/img_bed/raw/master/2026/01/09/0cfbb34ed7dd4ba17d9d92d3c3ed2b10-image-20260109142609483.png)

<div style="clear: both;"></div>

在Java中，万物皆对象，然而八大基本数据类型却是例外，它们的数据存储在栈内存中，不利于集合的存储，也不利于离散堆内存的使用，于是就为每一个基本数据类型设计了一个用来描述它的类，这些类就是包装类（包装类作为基础类，都存放在`java.lang`包下）。

|  byte  |  short  |    int    |  long  |  float  |  double  |  boolean  |    char     |
| :----: | :-----: | :-------: | :----: | :-----: | :------: | :-------: | :---------: |
| `Byte` | `Short` | `Integer` | `Long` | `Float` | `Double` | `Boolean` | `Character` |

可以看得出来，除了`int`和`char`的包装类名字特殊一点外，其余标桩类均为基本数据类型首字母大写即可。以后使用最多的类为`java.lang.Integer`，因此以它来举例讲解即可，其余都大同小异。

获取`Integer`对象的方式（JDK5以前，JDK5做了优化，因此了解即可）：

|                        方法名                        |                    说明                     |
| :--------------------------------------------------: | :-----------------------------------------: |
|             `public Integer(int value)`              |     根据传递的整数创建一个`Integer`对象     |
|              `public Integer(String s)`              |    根据传递的字符串创建一个`Integer`对象    |
|        `public static Integer valueOf(int i)`        |     根据传递的整数创建一个`Integer`对象     |
|      `public static Integer valueOf(String s)`       |    根据传递的字符串创建一个`Integer`对象    |
| `public static Integer valueOf(String s, int radix)` | 根据传递的字符串和进制创建一个`Integer`对象 |

**缓冲区/缓存**：与`BigDecimal`和`BigInteger`一样，`Integer`也有缓冲区的概念，它的缓存范围为`[-128, 127]`，也是调用`valueOf`方法的时候会优先走缓存，如果在这个区间内的值，就直接返回静态代码块中初始化的值。

**自动拆/装箱（JDK5优化）**：之前对于包装类的运算，需要先将其转为基本数据类型，运算结束后再将结果转为包装类，这使得包装类的使用非常麻烦，于是就引入了自动装箱和自动拆箱的概念。

* 自动装箱：把基本数据类型自动变成对应的包装类，例，`Integer i = 10;`等价于`Integer i = Integer.valueOf(10);`。
* 自动拆箱：把包装类自动变成对应的基本数据类型，例，`int i = new Integer(10);`等价于`int i = new Integer(10).intValue();`。

由于自动拆/装箱的引入，JDK5以后，`Integer`和`int`基本可以看成是同一个东西。

`Integer`成员方法：

|                    方法名                    |                 说明                  |
| :------------------------------------------: | :-----------------------------------: |
| `public static String toBinaryString(int i)` |              得到二进制               |
| `public static String toOctalString(int i)`  |              得到八进制               |
|  `public static String toHexString(int i)`   |             得到十六进制              |
|    `public static int parseInt(String s)`    | 将字符串类型的整数转为`int`类型的整数 |

## 11、常见算法

### 11.3 排序算法

### 11.4 字符串匹配算法

### 11.5 常见算法的API-Arrays

## 12、Stream流

## 13、异常

## 14、File

## 15、IO流

## 16、多线程&JUC

## 17、网络编程

## 18、反射
