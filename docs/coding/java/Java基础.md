---
title: Java基础
order: 2
---

# Java基础

> 带\*号的章节不重要

## 1、Java基础概念

### 1.1 注释

单行注释：`// 单行注释信息`

多行注释：`/* 多行注释信息 */`

文档注释：`/** 文档注释信息 */`

> 说明
>
> 注释内容不会参与编译和运行，仅仅是对代码的解释说明。
>
> 不管是单行注释还是多行注释，在书写的时候都不要嵌套。
>

### 1.2 关键字

关键字：被Java赋予特定含义的英文单词。

关键字特性：

* 关键字的字母全部小写
* 常用代码编辑器针对关键字有特殊的颜色标记，非常直观

> Java中大约有50多个关键字，不必刻意记忆，见官网：[Oracle官网](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)

常见关键字：

* `class`：用于创建/定义一个类，类是Java最基本的组成单元。

### 1.3 字面量

字面量用于告诉程序员数据在程序中的书写格式。

在代码中，一般会书写一下六种字面量：

| 字面量类型 |                   说明                   |            举例             |
| :--------: | :--------------------------------------: | :-------------------------: |
|  整数类型  |             不带小数点的数字             |        `666`，`-88`         |
|  小数类型  |              带小数点的数字              |      `13.14`，`-5.21`       |
| 字符串类型 |           用双引号括起来的内容           | `HelloJava`，`new一个对象`  |
|  字符类型  | 用单引号括起来的内容，内容只能有一个字符 |    `'A'`、`'0'`、`'我'`     |
|  布尔类型  |             布尔值，标识真假             | 只有两个值：`true`、`false` |
|   空类型   |            一个特殊的值，空值            |           `null`            |

用例：

```java
public class ValueDemo {
    public static void main(Stringp[] args) {
        // 整数
        System.out.println(121);
        System.out.println(-33);
      
        // 小数
        System.out.println(3.14);
        System.out.println(-6.98);
      
        // 字符串
        System.out.println("str");
        System.out.println("字符串");
      
        // 布尔
        System.out.println(true);
        System.out.println(false);
      
        // 空
        System.out.println(null);
    }
}
```

**特殊字符类型的字面量：**

* `\t`：制表符，在打印的时候，把前面字符串的长度补齐到8或8的整数倍。最少补一个空格，最多补8个空格。

  ```java
  public class Demo {
    public static void main(String[] args) {
      // 不用制表符的版本全都拼接在一起
      System.out.println("name" + "age");
      System.out.println("tom" + 23);
      
      // 使用制表符后自动对齐
      System.out.println("name" + '\t' + "age");
      System.out.println("tom\t23");
    }
  }
  ```

* `\n`：换行符略

### 1.4 变量

变量：在程序中存储数据的标识。

变量定义：`数据类型 变量名 = 数据值;`

* 数据类型：为存储数据的（内存）空间中存储的数据添加的类型限制（整数、小数、字符串等）。
* 变量名：为存储数据的空间起的名字（标识）。
* `=`：赋值符号，标识将右侧的字面量值赋给左侧的变量名所对应的内存空间。
* 数据值：存储在内存空间中的值。

变量的基本用法：

* 输出打印

  ```java
  int a = 10;
  System.out.println(a); // 10
  ```

* 参与计算

  ```java
  int a = 10;
  int b = 20;
  System.out.println(a + b);
  ```

* 修改记录的值

  ```java
  int a = 10;
  System.out.println("修改前变量a = " + a);
  a = 20;
  System.out.println("修改后变量a = " + a);
  ```

变量使用的注意事项：

* 只能存一个值

* 变量名不允许重复定义

* 一条语句可以定义多个变量（逗号隔开即可）

  ```java
  int a = 1, b = 2, c = 3, d = 4;
  ```

* 变量在使用之前一定要进行赋值

* 变量的作用域范围

### 1.5  数据类型

**基本数据类型：** 分为4类8种

* 整数

  ① byte：内存占用1个字节，即8个比特位，取一位作为符号位，其取值范围为`-128~127`，多用它的数组来存取流转文件内容。

  ② short：内存占用2个字节，去一位作为符号位，其取值范围为`-32768~32767`。

  ③ int：整数字面量的默认类型，内存占用4个字节，取值范围为`-2147483648~2147483647`。

  ④ long：内存占用8个字节，取值范围：`-9223372036854775808~9223372036854775807`，定义字面量时需要在字面量后面加一个`L`或`l`，但是一般建议使用大写的`L`，因为小写的`l`辨识度没有大写的高。

* 浮点数

  ① float：内存占用4个字节，共计32个比特位，第一位用来表示符号位；2\~9位为指数（阶码）；10\~32位为有效数字（尾数）。所以它的取值范围为`-3.401298e-38~3.402823e+38`。定义float字面量时也需要在末尾加一个`F`或`f`，一般建议使用大写。

  （TODO：关于浮点数的存储原理，还需另做文章解读）

  ② double：浮点数字面量的默认类型，内存占用8个字节，`-4.9000000e-324~1.797693e+308`。

* 字符：char，内存占用2个字节，取值范围为`0~65535`，字面量为单个字符，使用单引号括起来。

* 布尔：boolean，内存占用1个字节，值为`true`、`false`。

**引用数据类型**：数组、字符串、其他对象。

### 1.6 标识符

标识符：给类、方法、变量等取的名字。

命名规则：

* 由数字、字母、下划线和美元符号组成；
* 不能以数字开头
* 不能是关键字
* 区分大小写

命名规范：

* 方法和变量使用小驼峰命名法，即第一个单词首字母小写，其余大写；
* 类名使用大驼峰命名法，即每个单词首字母大写；
* 尽可能的见名知意

:::warning 注意

① 下划线开头的标识符：在早期代码中，有时用 `_`开头表示“私有”或“内部”成员（如 `_count`），但这不是强制规范，Oracle 官方编码规范不鼓励使用下划线开头，并且Java 9+ 中，单独的下划线 `_`是关键字（受限标识符），不能作为变量名；

② 美元符号开头的标识符：$常见于编译器自动生成的类或变量名（反编译class文件后可见），手动编写的代码中要尽可能的避免，以免与编译器生成的名称冲突。

:::

### 1.7 键盘录入\*

*观前提醒：常规开发工作过程中，这玩意儿几乎用不到，常见于公司内部自己写的命令行小工具，极少使用，常规上线的大型项目中我从来没见过使用。*

Java自带了`java.util.Scanner`类，用于处理键盘的输入。

```java
import java.util.Scanner;

public class Demo {
  Scanner sc = new Scanner(System.in);
  
  int input = sc.nextInt(); // 接收int型的数据，其他数据类型同理
  
  System.out.println("输入内容：" + input);
}
```

## 2、运算符

运算符和表达式：对字面量或者变量进行操作的符号即为运算符；用运算符把字面量或者变量连接起来，符合Java语法的式子就可以称为表达式。不同运算符连接的表达式体现的是不同类型的表达式。

### 2.1 算数运算符

加`+`、减`-`、乘`*`、除`/`、取模（余）`%`（运算符作用略或参见小学数学🐶）

在代码中，如果有小数参与计算，计算结果有可能不精确，所以在银行项目中涉及到小数点后几位一般要么用要么用BigDecimal对象，要么小数点后的位数用int手动计算。(TODO: 关于编程中小数不精确问题解析)

在除法运算中，如果除数和被除数都是整数，那么运算结果也会被作为整形（截取），除数和被除数任意一个如果是浮点类型，则计算结果自动四舍五入（或不精确）。

关于取模（余）运算，一般用于判断是否整除（余数为0），是否为偶数（能被2整除），以及范围内循环等。

`+`运算符的三种情况：

* 数字相加：数值相加

  隐式转换：又叫自动类型提升，取值范围小的数值转为取值范围大的数值。例如，在加法运算中，其中一个加数为double类型，其余为int，则相加结果为double类型，隐式转换不需要写额外的代码。

  * 取值范围从小到大：`byte < short < int < long < float < double`

  * 隐式转换的两种提升规则：一是取值范围小的和取值范围大的进行运算，晓得会先提升为大的，再进行计算；二是`byte`、`short`、`char`三种类型的数据在运算的时候，都会直接先提升为`int`，然后再进行计算（即使进行计算的两个数都是同一种数据类型，只要进行加法运算了，最终结果都是`int`类型）。

  强制转换：取值范围大的数值转为取值范围小的数值。如果把一个取值范围大的数值赋值给一个取值范围小的变量，是不允许赋值的，如果一定要赋值，那么就需要加入强制转换，强制转换需要手动编写代码声明。

  * 格式：`目标数据类型 变量名 = (目标数据类型) 被强转的数据（可以是变量名和字面量）;`
  * 强制转换可能会导致数据发生错误，例如将128转为`byte`类型，这超出了它的取值范围，就会导致出现错误。

* 字符串相加：如果`+`操作中出现字符串，此时这个`+`号就是字符串连接符，而不是运算符了，它会将前后的数据进行拼接并产生一个新的字符串。当然，如果是多个数字和字符串混合，则由是从左道友两个两个进行运算，所以在遇到字符串之前的数字都是进行正常的数值运算，遇到字符串之后的则全都是拼接。

* 字符相加：当`字符+字符`或`字符+数字`时，会将字符通过ASCII码查询到相应的数字之后再进行计算，如果是非ASCII字符，则使用期Unicode码点的值进行计算（例如`'中'`的码点为20013）。

> 练习题：键盘录入一个三位数，将其拆分为个位、十位、百位，然后分别打印在控制台。
>
> 题解：$位值 = 输入值 \div 所在位基础值 \bmod 10$
>
> 例如，
>
> $123_{个位} = 123 \div 1 \bmod 10 = 3$
>
> $123_{十位} = 123 \div 10 \bmod 10 = 2$（Java中的整数除法会被截取整形）
>
> $123_{百位} = 123 \div 100 \bmod 10 = 1$

### 2.2 自增/减运算符

自增运算符`++`：可以卸载变量的前面或者后面，作用是变量值+1。

* 写在后面：先使用变量，然后再给变量加一，例如`int a = 1;`那么`1 + a++`的运算结果为2，但是运算结束后a的值为2。
* 写在后面：与写在前面相反，上述示例中，如果是`1 + ++a`，则运算结果为3，运算结束后a的值为2。

无论是写在前面还是写在后面，单独使用的话，都没有区别；自增和自减多用于循环中。

### 2.3 赋值运算符

| 符号 |    作用    |              说明              |
| :--: | :--------: | :----------------------------: |
| `=`  |    赋值    | `int a = 10;`，将10赋值为变量a |
| `+=` |  加后赋值  |    `a += b; => a = a + b;`     |
| `-=` |  减后赋值  |    `a -= b; => a = a - b;`     |
| `*=` |  乘后赋值  |    `a *= b; => a = a * b;`     |
| `/=` |  除后赋值  |    `a /= b; => a = a / b;`     |
| `%=` | 取余后赋值 |    `a %= b; => a = a % b;`     |

`+=`、`-=`、`*=`、`/=`、`%=`底层都隐含了一个强制类型转换：

```java
public class Demo {
  public static void main(String[] args) {
    short s = 1;
    s += 1; // 运算结果的类型还是short，不是int，等同于s = (short) (s + 1);
    System.out.println(s);
  }
}
```

### 2.4 关系运算符

关系（比较）运算符的分类：

| 符号 |                             说明                             |
| :--: | :----------------------------------------------------------: |
| `==` |  `a == b`，判断a与b是否相等，成立为`true`，不成立为`false`   |
| `!=` | `a != b`，判断a与b是否不相等，成立为`true`，不成立为`false`  |
| `>`  |    `a > b`，判断a是否大于b，成立为`true`，不成立为`false`    |
| `>=` | `a >= b`，判断a是否大于或等于b，成立为`true`，不成立为`false` |
| `<`  |    `a < b`，判断a是否小于b，成立为`true`，不成立为`false`    |
| `<=` | `a <= b`，判断a是否小于或等于b，成立为`true`，不成立为`false` |

关系运算符的结构式boolean型。

### 2.5 逻辑运算符

在数学中，一个数据x，大于5，小于15，可以表示为：`5 < x < 15`，但是在Java中，需要将该式子进行拆解再进行合并表达：

* 拆解为：`x > 5`和`x < 15`
* 合并为：`x > 5 & x < 5`

| 符号 |     作用     |                             说明                             |
| :--: | :----------: | :----------------------------------------------------------: |
| `&`  | 逻辑与（且） |       并且，符号前后表达式/值为`true`，结果才是`true`        |
| `&&` |    短路与    | 如果符号前面的表达式运算结果/值为`false`，直接得出结果为`false`，不再运行符号后面的内容 |
| `|`  |    逻辑或    |            或者，两边都为`false`，结果才是`false`            |
| `||` |    短路或    | 如果符号前面的表达式/值为`true`，则直接得出结果为`true`，不再运行符号后面的内容 |
| `^`  |   逻辑异或   |                 相同为`false`，不同为`true`                  |
| `!`  |    逻辑非    |                             取反                             |

使用注意事项：

* 取反运算符最好不要多写，确定好逻辑后只写一次即可；
* 短路运算符简单理解：当左边表达式能确定最终结果，那么右边表达式就不再参与运行；
* 最长用的逻辑运算符：`&&`、`||`、`!`

### 2.6 三元运算符

三元运算符：又叫条件表达式、条件运算符、三目运算符等。其格式为`关系表达式 ? 表达式1 : 表达式2;`，关系表达式运算结果为`true`，则取`表达式1`结果，否则取`表达式2`，例如取两个数的较大值：`a > b ? a : b;`。

计算规则：

* 首先计算关系表达式的值
* 如果值为`true`，表达式1的值就是运算结果
* 如果值为`false`，表达式2的值就是运算结果

### 2.7 原码、反码、补码

**原码**：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。利用原码对正数进行计算是不会有问题的，但是如果是负数计算，由于第一位为符号位，那么运算结果就会出错（如果单独为负数运算写一套运算逻辑，那么对于CPU来说代价太大且极不方便），实际的运算结果与预期结果是相反的（符号位没变化），于是就设计了反码来对负数进行计算。

**反码**：为了解决原码不能计算负数的问题而出现的，正数的反码是其本身，负数的反码是符号位保持不变，其余位取反。

* 计算规则：正数反码不变，负数的反码在原码的基础上，符号位不变，数值取反，即0变1,1变0。
* 反码进行加减运算得到结果的反码
* 但是当反码加减结果跨0的时候出现了问题（结果为正数），因为在反码中出现了两个0（"-0"的`1000 00000`和“+0”的`0000 0000`的反码），于是为了只保留一个0，就在负数反码基础上+1（保留了原“-0”，原码为`1000 0000`，反码为`1111 1111`，加1后转为了`0000 0000`），得到了补码。

**补码**：正数的补码是其本身，负数的补码是在其取反的基础上+1。由于反码转为原码过程中，“-0”`1000 000`一直没有被使用，所以就规定，`1000 0000`为数字-128的补码（-128没有原码和反码），所以一个字节能表示的整数数值范围为`-128~127`，并且基于这个原因（方便CPU运算），CPU寄存器和内存中（甚至硬盘中）的整数的存储方式都是补码，所以原码和反码对于计算机来说都是概念上的东西，它不需要原码和反码，只需要补码进行数据流转运算即可，所以即使-128在计算机中没有原码和补码也不影响。

:::info Tips

有了原码、反码和补码的前置知识，就可以解释前面的Java基本数据类型取值范围的缘故了：

  ① byte占用一个字节，共计8个bit，所以取值范围为`-128~127`，short占两个字节，所以取值范围是`-32768~32767`……

  ② 隐式类型转换：整数隐式类型转换其实就是在小范围数据类型前面补0补到大范围数据类型的长度即可；

  ③ 强制类型转换：从左往右除去超出长度的比特位，保留剩下的比特位（丢失了前面的比特位很可能导致错误数据，例如正数变负数这种）。

:::

### 2.8 其他运算符

在学习了原码、反码和补码的相关知识后，逻辑与和逻辑或也能作为位运算符：

| 运算符 |    含义    |                           运算规则                           |
| :----: | :--------: | :----------------------------------------------------------: |
|  `&`   |   逻辑与   |            0为false，1为true（1是0否，编程通用）             |
|  `|`   |   逻辑或   |                      0为false，1为true                       |
|  `<<`  |    左移    | 补码向左移动，低位（移动后空出来的位置）补0，左边移出去的比特位丢弃 |
|  `>>`  |    右移    |            补码向右移动，高位补0或1（正数与负数）            |
| `>>>`  | 无符号右移 |                      向右移动，高位补0                       |

逻辑或与逻辑与：两个数的补码进行按位逻辑运算即可得到结果。

左移：实际上每左移一位，数值运算上就是原数值乘以2，有时候要写高性能代码常用，因为CPU的寄存器直接移位运算要比数值加减乘除快得多。

右移：高位（左侧）如果是1（负数）则补1，如果是0（正数），则补0，右移一次相当于原数值除以2。

无符号右移：不管正负，高位都是补0。

### 2.9 运算符优先级

| 优先级 |                 运算符                  |
| :----: | :-------------------------------------: |
|   1    |             `.`、`()`、`{}`             |
|   2    |          `!`、`~`、`++`、`--`           |
|   3    |              `*`、`/`、`%`              |
|   4    |                `+`、`-`                 |
|   5    |            `<<`、`>>`、`>>>`            |
|   6    |   `<`、`<=`、`>`、`>=`、`instanceof`    |
|   7    |               `==`、`!=`                |
|   8    |                   `&`                   |
|   9    |                   `^`                   |
|   10   |                   `|`                   |
|   11   |                  `&&`                   |
|   12   |                  `||`                   |
|   13   |                  `?:`                   |
|   14   | `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`&=` |

以上为Java中运算符的优先级，但是一般除了`<<`、`>>`、`>>>等涉及到CPU直接移位运算的符号外，其余时候皆直接使用小括号确定优先级。

## 3、流程控制语句

### 3.1 顺序结构

顺序结构语句是Java程序默认的执行流程，按照代码的先后顺序，从上到下依次执行。

### 3.2 分支结构

#### if语句

if语句在程序中就是用来判断的。

**①** if的第一种格式：

```java
// if 语句结构
if (关系表达式) {
  语句体;
}
```

执行流程：

* 首先计算关系表达式的值
* 如果表达式的值为`true`就执行语句体
* 如果关系表达式的值为`false`就不执行语句体
* 继续执行后面的其他语句

if语句的使用：

* 大括号的开头可以另起一行书写，但是建议写在第一行的末尾（Java语言的语法规范）
* 在语句体中，如果只有一句代码，大括号可以省略不写（在大型项目中不建议这样做）
* 如果对一个布尔类型的变量进行判断，不要用`==`号

**②** if的第二种格式：

```java
if (关系表达式) {
  语句体1;
} else {
  语句体2;
}
```

执行流程：

* 首先计算关系表达式的值
* 如果表达式的值为`true`就执行语句体1
* 如果关系表达式的值为`false`就执行语句体2
* 继续执行后面的其他语句

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/19/351060426455ab3df5ca3ebed00df4c2-image-20251219165245221.png" alt="image-20251219165245221" style="zoom:80%;" align="left" />

<div style="clear: both;"></div>

**③** if语句的第三种格式：

```java
if (关系表达式1) {
  语句体1;
} else if (关系表达式2) {
  语句体2;
}
  ...
 else if (关系表达式n) {
   语句体n;
 } else {
   语句体n+1;
 }
```

执行流程：逐个判断关系表达式，执行第一个关系表达式值为`true`的语句体，如果都为`false`，就执行语句体n+1。

#### switch语句

语句格式：

```java
switch (表达式) {
  case 值1:
    语句体1;
    break;
  case 值2:
    语句体2;
    break;
  ...
  case 值n:
    语句体n;
    break;
  default:
    语句体n+1;
    break; // 末尾可省略
}
```

执行流程：

* 首先计算表达式的值。
* 一次和case后面的值进行比较，如果有对应的值，就会从该case的语句体开始往后依次执行，中间如果遇到break或者方法中的return语句等，就会结束。
* 如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后结束整个switch语句。

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/19/8214cca4f8a3dff7f0874bc9b32f6e3a-image-20251219171412000.png" alt="image-20251219171412000" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

格式说明：

* 表达式：将要匹配的值，取值为`byte`、`short`、`int`、`char`，jdk5以后可以是`枚举`，jdk7以后可以是`String`（不能是`long`和浮点型）。
* case：后面跟的是要和表达式进行比较（匹配）的值。
* break：用于中断（提前结束）switch语句。
* default：所有情况都不匹配的时候就执行该语句体（类似if中的else），非必填项，也不一定是写在最下面，可以写在case之间的任意位置。当然还是比较建议必须写在最后面。
* case的值只能是字面量，不能是变量，且case后面的值不允许重复。

:::info Tips

① 如果有多个case后面的值都是相同的处理逻辑，可以直接将这些值（case 值:）写在一起，一行一条语句（必须逐行挨在一起），然后在最后一条语句后面只写一遍处理逻辑，这样任意一个case匹配成功都可迅速往后执行。（利用case穿透）

② 最后一条语句（不管是case还是default）可以不需要`break`也能正常结束，不过一般还是建议都写上，避免以后往后面添加逻辑的时候忘记写酿成惨剧（后果一般都挺严重），不要管编辑器会不会有格式告警那些。

③ jdk12以后switch新特性：

```java
public class Demo {
    // 使用此新特性，可以省略break语句，不存在穿透现象
    public static void printChNum(int num) {
        switch (num) {
            case 1 -> System.out.println("一");
            case 2 -> {
                // 只有一行的时候，花括号可省略
                System.out.println("二");
            }
            case 3 -> System.out.println("三");
            case 4, 5, 6, 7 -> System.out.println("即将支持！"); // 当需要利用穿透时还可以直接用逗号隔开多个匹配值
            default -> System.out.println(num + "这个数字还是算了。");
        }
    }
}
```

④ switch和if的选用：if一般用于对范围的判断，switch一般用于易穷举结果的匹配。

:::

### 3.3 循环结构

循环：重复做某件事，具有**明确的开始和停止标记**。在Java中，循环一共分为三类，分别是`for循环`、`while循环`以及`do...while循环`（几乎不怎么使用）。

#### for循环

格式：

```java
public class Demo {
    public static void main(String[] args) {
        //for(初始化语句;条件语句;条件控制语句) {
        //    循环结构语句;
        //}
        // 举例：打印十次HelloWorld
        for (int i = 0; i < 10; i++) {
            System.out.println("Hello World!");
        }
    }
}
```

执行流程：

* 执行初始化语句（只执行一次）
* 执行条件判断语句，判断为`true`则执行循环结构语句，`false`则循环结束
* 执行条件控制语句
* 回到第二步，重新开始执行条件判断语句，开启新一轮循环

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/22/14273258547a6ac4e033ab7f7951a2e3-image-20251222134920374.png" alt="image-20251222134920374" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

:::info Tips

① 初始化语句、条件语句和条件控制语句甚至循环结构语句都是非必填项，当然不建议这么做，如果省略条件语句，代表循环将会是一个死循环，容易造成OOM（内存溢出异常），不过有时候会用`for (::) + break;`类代替`while`循环。（`break`关键字在这里为跳出循环语句）。

② 当嵌套多层`for`循环时，可以给每层循环单独添加标签名，然后使用break关键字跳出指定循环：

```java
public class Demo {
    public static void main(String[] args) {
        outer: for (int i = 0; i < 100; i++) {
            inner: for (int j = 0; j < 100; j++) {
                if (i + j == 40) {
                    break outer;
                }
            }
        }
    }
}
```

:::

#### while循环

格式：

```java
public class Demo {
    public static void main(String[] args) {
        // 初始化语句;
        // while (条件判断语句) {
        //    循环控制语句;
        //    条件控制语句;
        // }
        // 举例：打印十次HelloWorld
        int count = 0;
        while (count < 10) {
            System.out.println("Hello World!");
            count++;
        }
    }
}
```

执行流程：

* 执行初始化语句（只执行一次）
* 执行条件判断语句，判断为`true`则执行循环结构语句，`false`则结束循环
* 执行条件控制语句
* 回到第二步，重新开始执行条件判断语句，开启新一轮循环

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/22/7a39187009e007a08a33c3fc3c54470f-image-20251222140845221.png" alt="image-20251222140845221" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

`for`和`while`对比:

* 相同点：运行规则都是一样的

* 区别：

  ① for循环中，控制循环的变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了；

  ② while循环中，控制循环的变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用；

  ③ for循环一般用在明确知道循环的次数或循环的范围时；

  ④ while循环一般用在不知道循环的次数或范围，但是明确知道循环结束的条件时。

> 案例1：打印折纸的次数
>
> 需求：世界最高峰是珠穆朗玛峰（8844.43米=8844430毫米），加入有一张足够大的纸，它的厚度是0.1毫米。请问需要折叠多少次，可以折成珠穆朗玛峰的高度？
>
> ```java
> // 题解：
> public class Anwser {
>     public int solution() {
>         double hight = 0.1;
>         int count = 0;
>         while (hight < 8844430) {
>             hight *= 2;
>             count++;
>         }
>         return count;
>     }
> }
> ```
>
> 案例2：回文数
>
> 需求：给你一个整数x，如果x是一个回文整数，打印true，否则返回false。
>
> 解释：回文数是指正序（从左到右）倒序（从右向左）读都是一样的整数。例如，121是回文，而123不是。
>
> ```java
> // 题解：
> public class Anwser {
>     public boolean solution(int x) {
>         // 用于循环流转变换的值
>         int loopVal = x;
>         // 记录从数字x从右往左倒过来的值
>         int palindrome = 0;
>         while (loopVal != 0) {
>             // 从右往左获取每一个数字
>             int posVal = loopVal % 10;
>             palindrome = palindrome * 10 + posVal;
>             // x个位上的值已获取，所以产生新的个位值
>             loopVal /= 10;
>         }
>         return palindrome == x;
>     }
> }
> ```
>
> 案例3：求商合余数
>
> 需求：给定两个整数，被除数和除数（都是正数，且不超过int范围）。将两数相除，要求不适用乘法、除法和取余运算符，得到商和余数。
>
> ```java
> // 题解：
> public class Anwser {
>     /**
>      * 方法描述：给定两个整数，被除数和除数（都是正数，且不超过int范围）。将两数相除，要求不适用乘法、除法和取余运算符，得到商和余数
>      *
>      * @param dividend 被除数
>      * @param divisor  除数
>      */
>     public void solution(int dividend, int divisor) {
>         int quotient = 0; // 商
>         int remainder = dividend; // 余数
>         while (remainder > divisor) {
>             remainder -= divisor;
>             quotient++;
>         }
>         System.out.printf("%d ÷ %d ＝ %d...%d\n", dividend, divisor, quotient, remainder);
>     }
> }
> ```

#### do...while循环*

格式：

```java
public class Demo {
    public static void main(String[] args) {
        // 初始化语句;
        //do {
        //    循环体语句;
        //    条件控制语句;
        //} while (条件判断语句);
        // 举例：打印十次HelloWorld
    }
}
```

与while区别就是先执行一遍循环体语句和控制语句再做判断，其余没有区别。

#### 无限循环和跳转控制语句

**无限循环**：循环一直停不下来（核心思想都是使条件判断结果始终为`true`），一般用于既不明确循环次数（或范围）也不明确结束条件的情况。一般来说，结束条件可能需要循环语句的运行结果来确定，又或者结束条件为程序停下来（只要程序不停止循环就不停止）。

```java
public class Demo {
    public static void main(String[] args) {
        // 无限循环的三种格式
        for (;;) {
            System.out.println("for无限循环");
        }
        while (true) {
            System.out.println("while无限循环");
        }
        do {
            System.out.println("do...while无限循环");
        } while (true);
    }
}
```

**循环的跳转控制语句**：涉及到两个关键字，`continue`：跳过本次循环，继续执行下次循环；`break`：结束整个循环。

> 案例1：求平方根
>
> 需求：键盘录入一个大于等于2的整数x，计算并返回x的平方根。结果只保留整数部分，小数部分将被舍去。
>
> 题解：从1开始计算每个数的平方，直到结果大于x，则取上一次的数。
>
> 案例2：判断是否为质数
>
> 需求：键盘录入一个正整数，判断其是否为质数。
>
> 题解：从2开始，直到其平方根（小于等于平方根），一个数一个数的判断能否被该数字整除，如果都不能则为质数。

## 4、数组

### 4.1 数组介绍

数组：一种容器，可以用来存储 **同种类型** 的多个值。

* 数组在容器存储的时候，关于数据类型限制，需要结合隐式转换。

### 4.2 数组的定义与静态初始化

数组的定义

* 范式一：`数据类型[] 数组名`（常用）
* 范式二：`数据类型 数组名[]`

数组的初始化：就是在内存中，为数组容器开辟空间，并将数据存入容器中的过程。

* 静态初始化：`数据类型[] 数组名 = new 数据类型[]{ 元素1, 元素2, 元素3... };`

  简化格式：`数据类型[] 数组名 = { 元素1, 元素2, 元素3... };`

  例：`int[] arr = new int[]{11, 22, 33};`

* 数组的地址值：定义好数组后，使用print函数打印到控制台，会得到一个地址值（例`[I@73846619`），这个地址值就表示数组容器在内存中的位置。

  解释一下地址值中各个部分的含义，以`[I@73846619`为例：

  ① `[`：表示数据位一个数组

  ② `I`：表示数组数据类型为`int`

  ③ `@`：间隔符号，固定格式

  ④ `73846619`：真正的地址值（十六进制）

### 4.3 数组元素访问

格式：`数组名[索引];`，索引也叫做下标，角标，从0开始，逐个+1增长，连续不间断。

利用索引对数组中的元素进行访问：

* 获取数组中的元素：`数组名[索引]`，数组索引范围为`0~数组长度-1`。
* 把数据存到数组中：`数组名[索引] = 具体数据/变量`，赋值一旦覆盖，原数据就不在数组中了。

### 4.4 数组遍历

数组遍历：就是取出数组中所有数据的过程，取出后方便加以应用（例如计算、判断以及最简单的打印等）。

```java
public class Demo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        // 利用循环遍历数组，开始条件为索引0，结束条件为数组最大索引（长度-1），条件控制为每次索引+1
        for (int i = 0; i < arr.length - 1; i++) {
            System.out.println(arr[i]);
        }
        // arr.length为数组长度，length是数组的一个属性，其值为数组长度，调用方式：数组名.length
    }
}
```

### 4.5 数组动态初始化

动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。

* 格式：`数据类型[] 数组名 = new 数据类型[数组长度];`，例`int[] arr = new int[3];`

* 数组默认初始化值的规律：

  ① 整数类型：0

  ② 小数类型：0.0

  ③ 字符类型：`/u0000`（空格）

  ④ 布尔类型：`false`

  ⑤ 引用数据类型：`null`

动态初始化和静态初始化区别：

* 动态初始化需手动指定数组长度，由JVM分配默认初始化值，适用于只明确个数，不确定初始化值；
* 静态初始化需手动指定元素值，JVM根据所给出的初始化值计算数组长度，适用于明确了具体操作数据的情况。

### 4.6 数组内存图

Java的内存分配：

* 栈：方法运行时使用的内存，比如`main`方法运行，进入栈中执行

* 堆：存储对象或者数组，`new`来创建的，都存储在堆内存

  在堆中每开辟一块内存，它都会有一个自己的地址值。

* 方法区：存储可以运行的`.class`文件

  **注意**：① 在jdk7以前，方法区和堆空间逻辑上是放在一起的，物理上也是一块连续的内存区域；② 从jdk8开始，取消了方法区，新增元空间，把原来方法区的多种功能进行拆分，有的功能放到了堆中，有的功能放到了元空间中（包括加载字节码文件的功能也放到了元空间）。

* 本地方法栈：JVM在使用操作系统功能的时候使用，与我们Java开发无关

* 寄存器：给CPU使用，与我们无关![JDK7（左）JDK8（右）](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/c6109c41f1da02b7aee8efcf37f7b8f9-image-20251223145053004.png)

<div style="clear: both;"></div>

只涉及到基本数据类型的方法运行内存图（逐行）：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/89b4a23777bdafd0da0c6cb5043d0a3c-image-20251223150425735.png" alt="image-20251223150425735" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

数组内存图：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/6cf3d763b8dd10986eaef6211c78e41d-image-20251223150801275.png" alt="image-20251223150801275" align="left"/>

<div style="clear: both;"></div>

> **总结**
>
> ① 只要是new出来的一定是在堆里面开辟了一个小空间；
>
> ② 如果new了多次，那么在堆里面有多个小空间，每个小空间中都有各自的数据。

两个数组指向同一块内存空间的内存图：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/eca539cf3435b5b810c6a5e9b5c6efe8-image-20251223151214800.png" alt="image-20251223151214800" align="left"/>

<div style="clear: both;"></div>

> **总结**
>
> 当两个数组指向同一块内存区域时，其中一个数组对内存区域中的值进行修改，那么其他数组再次访问时都是修改后的结果。

### 4.7 数组常见问题

常见问题：数组越界异常，当访问了数组中不存在的索引，就会引发索引越界异常。（超出最大索引或者小于0）

### 4.8 数组常见操作

求最值、求和并统计个数、交换数据、打乱数据等。

```java
import java.util.Arrays;
import java.util.Random;

public class MyArrayUtils {
    // 求最大值
    public static int getMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            max = arr[i] > max ? arr[i] : max;
        }
        return max;
    }
    
    // 求和并统计个数
    /*
    需求：生成10个1~100之间的随机数存入数组
    1）求出所有数据之和
    2）求所有数据的平均数
    3）统计有多少个数据比平均值小
    */
    public static void statisticsSum() {
        // 1. 定义数组
        int[] arr = new int[10];
        // 2. 生成随机数据
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(100) + 1;
        }
        System.out.println("生成的随机数组：" + Arrays.toString(arr));

        // 3. 求和
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        System.out.println("求和：" + sum);

        // 4. 求平均数
        double avg = (double) sum / arr.length;
        System.out.println("平均数：" + avg);

        // 5. 统计有多少个数据比平均值小
        int leThanAvgCount = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < avg) {
                leThanAvgCount++;
            }
        }
        System.out.println("比平均数小的元素个数：" + leThanAvgCount);
    }
    
    // 交换数组中的数据：定义一个数组，反转整个数组
    public static void reverse(int[] arr) {
        // 两种方式都行
//        for (int i = 0; i < arr.length / 2; i++) {
//            int temp = arr[i];
//            arr[i] = arr[arr.length - i - 1];
//            arr[arr.length - i - 1] = temp;
//        }

        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    // 打乱数组数据
    public static void shuffle(int[] arr) {
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            // 获取数组索引范围内的随机数
            int index = random.nextInt(arr.length);
            int temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;
        }
    }
}
```

## 5、方法

### 5.1 什么是方法

概念：方法（method）是程序中最小的执行单元。例如Java程序的入口就是main方法。

创建：重复的、具有独立功能的代码逻辑可以抽象/提取到方法中。

作用：可以代码的复用性，也可以提高代码的可维护性（同一逻辑出现问题，只需修改方法体即可，调用方法的地方不用修改）

### 5.2 方法的格式

方法本质就是将一些代码**打包**在一起，用到的时候就**调用**。

定义方法：把一些代码打包到一起，该过程称为方法定义。

方法调用：方法定义完成后并不会主动运行，需要手动调用才能执行，该过程称为方法调用。（方法必须先定义后调用）

#### 最简单的方法定义

```java
public class MethodDemo {
    // 格式：
    // public static void 方法名() {
    //     方法体（就是打包起来的代码）;
    // }
    
    public static void main(String[] args) {
        // 调用定义好的方法
        playLKL();
        // 多次调用
        playLKL();
        playLKL();
        playLKL();
    }
    
    // 定义一个方法
    public static void playLKL() {
        System.out.println("选英雄");
        System.out.println("准备开局");
        System.out.println("对线");
        System.out.println("崩盘");
        System.out.println("骂队友");
        System.out.println("送人头");
        System.out.println("GG");
    }
}
```

#### 带参数的方法定义

```java
public class MethodDemo {
    // 格式：
    // public static void 方法名(参数列表（多个参数用逗号隔开）) {
    //     方法体;
    // }
    // 调用：方法名(参数1, 参数2, ...);
    // 注意：方法调用时，参数的数量与类型必须与方法中定义中小括号里面的变量一一对应，否则程序将报错
    
    public static void main(String[] args) {
        // 调用方法
        getSum(10, 11); // 21
    }
    // 定义方法
    public static void getSum(int num1, int num2) {
        System.out.println(num1 + num2);
    }
}
```

形参和实参：形参即形式参数，指的是方法定义中参数列表中的参数；实参即实际参数，指的是方法调用时传入方法的参数。方法调用时方法的形参和实参必须一一对应，否则程序将报错（编译时报错）。

#### 带返回值的方法定义

需要返回值的原因：方法返回的结果在调用处可能会有别的用途。（有返回值也不是一定会使用的哦）

方法的返回值其实就是方法运行的最终结果，如果在调用处要根据方法的结果去编写另一端代码逻辑，为了在调用处拿到方法产生的结果，就需要定义带有返回值的方法。

```java
public class MethodDemo {
    // 格式：
    // public static 返回值类型 方法名(参数列表) {
    //     方法体;
    //     return 返回值;
    // }
    
    public static void main(String[] args) {
        // 直接调用
        getSum(10, 11);
        // 赋值调用
        int sum = getSum(11, 12);
        // 直接使用运行结果
        System.out.println(getSum(12 + 13)); // 25
    }
    
    public static int getSum(int num1, int num2) {
        return num1 + num2;
    }
}
```

:::info Tips

方法定义技巧：

* 我需要什么？（参数列表）
* 我具体要做什么？（方法体）
* 我要返回什么？（返回值）

:::

方法的注意事项：

* 方法不调用就不执行
* 方法与方法之间是平级关系，不能互相嵌套定义
* 方法的编写顺序与执行顺序无关，只看调用顺序
* 方法的返回值类型为void，标识该方法没有返回值，没有返回值的方法可以省略不写，但是可以使用return语句（后面不跟任何内容）直接结束方法

### 5.3 方法的重载

在同一个类中，方法名相同，参数列表不同的方法就构成重载。重载与返回值无关。

参数列表不同：个数/类型/顺序不同，JVM通过参数的不同来区分调用的是哪个方法。顺序不同虽然可以构成重载，但是不建议这么做。

### 5.4 方法的内存

方法被调用后就会进栈执行，执行完成后出栈，丢弃方法作用域中的所有数据。

#### 方法调用的基本内存原理

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/823caa81431e9e530c45a0cb8c2a1554-image-20251223165127297.png" alt="image-20251223165127297" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

以上代码执行顺序：

1. main方法先入栈开始执行；
2. main方法中执行eat方法，于是eat方法入栈开始执行；
3. eat方法中执行study方法，于是study方法入栈开始执行；
4. study方法打印“学习”，方法执行结束，方法出栈，栈帧回到eat方法继续执行后续代码；
5. eat方法打印“吃饭”，开始执行sleep方法，于是sleep方法入栈；
6. sleep方法打印“睡觉”，方法执行结束，方法出栈，栈帧回到eat方法继续执行后续代码；
7. eat方法执行完毕，eat方法出栈，栈帧回到main方法继续执行后续代码；
8. main方法执行完毕，main方法出栈，程序运行结束。

#### 方法传递基本数据类型的内存原理

基本数据类型和引用数据类型：

![image-20251223170035726](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/f802314367767184c6fe12be4f1887d6-image-20251223170035726.png)

![image-20251223170131056](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/89288b433e5b0350b2ee98123ac42462-image-20251223170131056.png)

<div style="clear: both;"></div>

* 基本数据类型：数据存储在自己的空间中，赋值给其他变量，也是赋的真实值。
* 引用数据类型：数据值是存储在其他空间中，自己空间中存储的是地址值。赋值给其他变量，赋的也是地址值。

演示代码：

```java
public class MethodDemo {
    public static void main(String[] args) {
        int number = 100;
        System.out.println("调用change方法前：" + number); // 100
        change(number);
        System.out.println("调用change方法后：" + number); // 100
    }
    public static void change(int number) {
        number = 200;
    }
}
```

#### 方法传递引用数据类型的内存原理

演示代码：

```java
public class MethodDemo {
    public static void main(String[] args) {
        int[] nums = { 10, 20, 30 };
        System.out.println("调用change方法前：" + nums[1]); // 20
        change(nums);
        System.out.println("调用change方法后：" + nums[1]); // 200
    }
    
    public static void change(int[] arr) {
        arr[1] = 200;
    }
}
```

## 6、面向对象

面向对象思想（Object Oriented）是一种以对象为核心的程序设计范式，其核心要素包括对象封装、类划分、继承机制及消息传递机制，要求程序系统直接映射现实世界的问题域结构。

具体操作思维是将现实世界中存在的事务归类(`class`)，并将其各项特点作为属性(`field`)抽象出来，然后根据属性的取值特点类赋予不同的值。例如，人可以归为一个大类，他有年龄、喜好、性别等属性，每个具体的人就是一个对象，每个对象各个属性值的差别就是代表了不同的人。

面向对象方法论逐步成为软件开发主流范式，衍生出Booch方法、Coad方法、OMT方法等建模体系。1997年左右[统一建模语言（UML）](https://baike.baidu.com/item/统一建模语言/3160571?fromModule=lemma_inlink)整合了多种方法，形成标准化建模工具，应用范围从编程扩展至需求分析、系统设计等领域，推动了面向对象技术在分布式系统、人工智能等领域的广泛应用。

> 做面相对象的软件开发，至少需要能够看懂UML，否则不好编写文档，也不好看懂需求。当然，不同的公司和不同的开发团队不一定会使用UML。

### 6.1 设计对象并使用

#### 类和对象

类：是“生产”对象的设计图，是对象共同特征的描述。

对象：是真实存在的具体的东西。

在Java中，必须先设计类，才能获取相应对象。

```java
// 如何定义类：
public class ObjDemo {
    // 1、成员变脸（代表属性，一般是名词）
    // 2、成员方法（代表行为，一般是动词）
    // 3、构造器（后续章节学习）
    // 4、代码块（后续章节学习）
    // 5、内部类（后续章节学习）
    
    public static void main(String[] args) {
        // 获取对象：类名 对象名（变量名） = new 类名();
        Phone phone = new Phone();
        
        // 使用对象
        // 访问属性：对象名.成员变量
        phone.brind = "xiaomi";
        phone.price = 1999;
        System.out.println(phone.brind);
        System.out.println(phone.price);
        // 访问行为：对象名.方法名(...)
        phone.call();
        phone.playGame();
        
        // 创建多个对象同理即可
        // Phone newPhone = new Phone();
        // ……
    }
}

// 样例：创建手机类
class Phone {
    // 属性
    /** 品牌 */
    String brand;
    /** 价格 */
    double price;
    
    // 行为：
    public void call() {
        System.out.println("手机在打电话");
    }
    public void playGame() {
        System.out.println("手机在玩游戏");
    }
}
```

#### 定义类的补充注意事项

* 用来描述一类事务的类，专业叫做`JavaBean类`。在JavaBean中，是不写main方法的。（事实上，在一个项目中，程序的入口只需要一个就够了）

* 在之前编写的main方法的类，本质作用来看叫做测试类（用来运行每次演示的Demo），我们可以在测试类中创建JavaBean类的对象并进行赋值和调用。

* 类名首字母建议大写，需要见名知意，大驼峰。

* 一个Java文件中可以定义多个class类，且只能一个类是public修饰，public修饰的类名必须和文件名相同。实际开发中还是只建议一个文件中只定义一个class。

* 成员变量的完整定义格式是：`修饰符 数据类型 变量名称 = 初始化值;`，一般无需指定初始化值，存在默认值，当然，如果需要为成员（属性）赋一个优先级高于构造方法的值，也可以定义这个初始化值。

* 对象的成员变量的默认值规则：

  <table style="text-align: center; vertical-align: middle;">
    <thead style="width: 100%;">
      <tr>
        <th>数据类型</th>
        <th>明细</th>
        <th>默认值</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="3">基本类型</td>
        <td>byte、short、int、long</td>
        <td>0</td>
      </tr>
      <tr>
        <td>float、double</td>
        <td>0.0</td>
      </tr>
      <tr>
        <td>boolean</td>
        <td>false</td>
      </tr>
      <tr>
        <td>引用类型</td>
        <td>类、接口、数组、String</td>
        <td>null</td>
      </tr>
    </tbody>
  </table>

### 6.2 封装

封装是面向对象的三大特征之一（另外两个是继承和多态），它的作用在于告诉我们如何正确的设计对象的属性和方法。**对象代表什么，就得封装对应的数据，并提供数据对应的行为。**

>  案例：人画圆，需要定义两个类——人和圆，那么画圆这一方法应该定义在人这个类还是圆这个类中？
>
> 题解：由于画圆这个行为的数据来自于圆，画圆是圆这个类自我描述的行为，所以这个方法应该定义在圆这个类中。

#### 封装的作用

* 对象代表什么，就得封装对应的数据，并提供数据对应的行为（最典型的案例就是JDK自身提供的调用各种功能的类都是基于这个思想实现的）。
* 可以极大地降低学习成本，可以少学、少记，或者压根不用学，不用记对象有哪些方法，有需要时再去找就行。（命名规范中见名知意的重要作用）

#### private关键字

`private`是一个权限修饰符，可以修饰成员（成员变量和方法），被`private`修饰的成员只能在本类中访问。

一个设计好的`Person`类，如果它有一个属性为`age`，如果它的某一个对象被随意的将`age`属性设置为负数或者一个远超人类寿命限制的数，设计成这样的类被认为是不安全的，需要给每个成员（属性）的访问设计一套统一的标准。

利用`private`关键字来修饰类所有需要被定义标准的成员，然后再提供对外可访问的`public`关键字修饰的方法来对成员进行访问（和`private`一样，`public`也是一个权限修饰符，它修饰的成员变量和方法可以在对象上访问），这即是`getter/setter`方法了。

`getter/setter`方法名称有统一的命名标准，取值方法用`getXxx`，赋值方法用`setXxx`，如果是布尔型的成员，取值方法也可以是`isXxx`。

事实上，几乎所有的JavaBean（包括数据流转的类、数据库表对应的类等）在项目中，都需要遵循这个设计标准。

如此，上述的年龄设值问题就可以在`Person`类`age`属性的`setter`方法中添加判断了（这里只是举例，实际开发过程中，一般情况下，调用`setter`已经是经过所有校验的最后一步了设值保存/传入下一步继续流转处理了）。

案例：设计Person类。

```java
public class Person {
    /** 姓名 */
    private String name;
    /** 性别 */
    private char gender;
    /** 年龄 */
    private int age;
    
    // getter/setter，这里的this关键字后面再说，这里如果形参名与属性名不同则可以省略
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public char getGender() {
        return gender;
    }

    public void setGender(char gender) {
        this.gender = gender;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

:::info Tips

① 一些序列化框架是通过`gettter/setter`方法来获取属性的（例如Alibaba Fastjson）。

② 项目中可以考虑引用`lombok`组件来省略代码中的`getter/setter`方法（组件会根据组件中的注解会在编译的时候自动生成）。

```java
import lombok.Getter;
import lombok.Setter;

/**
 * 类描述：面向对象Demo：人类设计
 *
 * @author Triabin
 * @date 2020-12-24 14:28:20
 */
@Getter
@Setter
public class Person {
    /**
     * 姓名
     */
    private String name;
    
    /**
     * 性别
     */
    private char gender;
    
    /**
     * 年龄
     */
    private int age;
}
```

③ 如果求稳且项目组中有成员使用了不适配`lombok`的代码编辑器（Eclipse、vscode等），也可以使用JetBrains IDEA的自动生成功能。

* 设计好成员变量后，在文件中任意地方右键单击呼出弹窗，在弹窗中选择`Generate`，也可以使用快捷键`Alt + Insert`。(macOS为`Command + N`)

  <img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/24/89b2e6b97704e500362c8c4808918f24-image-20251224143930007.png" alt="image-20251224143930007" style="zoom:80%;" align="left" />

  <div style="clear: both;"></div>

* 然后在弹窗中选择`Getter and Setter`（左），再在之后的弹窗（右）中选中类的所有字段（聚焦到类上面后，`Ctrl + A`，或者选中第一个字段后按住`Shift`再点击最后一个字段，或者按住`Ctrl`键，然后一个一个的用鼠标点），选中后回车/点击OK。（macOS则将`Ctrl`键换成`Command`键即可）

  <img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/24/282560d545063b3ac1d05ea90de64cd2-image-20251224144408102.png" alt="image-20251224144408102" align="left"/>

  <div style="clear: both;"></div>

  > 关于Setter template，如果选择Builder，那么生成的`setter`方法会返回对象本身`return this;`，这样做的作用是可以让你链式调用，例如前文中的Person类，如果设置的是Builder模板，那么赋值可以这样：`person.setName("张三").setGender('M').setAge('20');`。当然，实际开发时为了方便修改和代码可读性，可能会换行：
  > ```java
  > public class Demo {
  >     public static void main(String[] args) {
  >         Person person = new Person()
  >             .setName("张三")
  >             .setGender('M')
  >             .setAge('20');
  >     }
  > }
  > ```

:::

### 6.3 this关键字

成员变量与局部变量

上一节Person类设计案例中说，如果Setter方法形参名与属性名不同则this关键字可以省略。其实如果相同且省略this关键字，则会导致Setter方法无法给属性赋值，这牵涉到了成员变量与局部变量的概念。

在类中，如果把变量定义在方法中，则该变量为（该方法的）局部变量，定义在类中，则该变量为（该类的）成员变量。

```java
public class ThisDemo {
    public static void main(String[] args) {
        method(); // 30
    }
    
    private int age;
    public void method() {
        int age = 30;
        System.out.println(age);
    }
}
```

就近原则：上述代码中，最终打印结果为30，因为局部变量的age离打印语句更近，所以最终打印结果为局部变量的值，如果想要使用成员中的age，就可以在age前面添加`this.`，这个this就表示当前类（对象）。这就是就近原则。

如此就可以解释上一节Person类中如果Setter方法形参名与成员变量名相同且省略this关键字导致Setter方法无法给属性赋值的原因了，在这种情况下，Setter方法中的属性名用的是离自己较近的形参，语句作用为形参将自己的值赋值给自己，压根没有访问到成员变量，所以也就无法给对象属性赋值。

> 在类的设计过程中，只要涉及到访问对象自身属性的情况下，不管局部变量中有没有同名的变量，最好都在前面添加`this.`，因为你不确定哪一天可能就会因为bug修改或者特性添加或者业务逻辑变更等各种原因在这个方法中添加同名的局部变量，一方面能避免多处修改，另一方面是**人的记忆是最不靠谱的**，这样设计可以避免因为忘记修改或者别人修改你的代码时没注意成员变量与局部变量的冲突导致的谬误。

### 6.4 构造方法

构造方法也叫作构造器、构造函数，用于在创建对象的时候给成员变量初始化。

```java
// 构造方法格式
public class StructorDemo {
    修饰符 类名(参数列表) {
        方法体;
    }
}
```

特点：

* 方法名与类名相同
* 没有返回值类型，连void都没有
* 没有具体的返回值（不能由return带回结果数据）

执行时机：

* 创建对象的时候**由JVM调用**，不能手动调用构造方法；
* 每创建一次对象，就调用一次构造方法。

一般样例（以前面的Person类为例）：
```java
/**
 * 类描述：面向对象Demo：人类设计
 *
 * @author Triabin
 * @date 2025-12-24 14:28:20
 */
public class Person {
    /**
     * 姓名
     */
    private String name;

    /**
     * 性别
     */
    private char gender;

    /**
     * 年龄
     */
    private int age;

    /**
     * 空参构造
     */
    public Person() {}

    /**
     * 全参构造
     * @param name 姓名
     * @param gender 性别，M男，F女
     * @param age 年龄
     */
    public Person(String name, char gender, int age) {
        this.name = name;
        this.gender = gender;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public Person setName(String name) {
        this.name = name;
        return this;
    }

    public char getGender() {
        return gender;
    }

    public Person setGender(char gender) {
        this.gender = gender;
        return this;
    }

    public int getAge() {
        return age;
    }

    public Person setAge(int age) {
        this.age = age;
        return this;
    }
}
```

构造方法注意事项：

* 构造方法的定义：如果没有写构造方法的情况下，JVM会默认创建一个无参构造方法；如果定义了构造方法，系统将不再提供默认的构造方法。
* 构造方法的重载：带参构造方法，和无参构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载。
* 推荐的使用方式：无论是否使用，都手动书写无参和全参的构造方法。

:::info Tips

与之前所述的利用IDEA生成`getter/setter`方法的相同，也可以通过`Alt + Insert`（macOS为`Command + N`），进入`Generate`选项菜单，选择生成构造方法，并且具体要初始化哪些参数也直接可选，亦或者使用`lombok`组件的`@AllArgsConstructor`与`@NoArgsConstructor`注解生成全参构造与无参构造方法。

:::

### 6.5 标准JavaBean

① 类名要见名知意

② 成员变量使用`private`修饰

③ 提供至少两个构造方法，即无参构造方法和全参构造方法

④ 成员方法：提供每一个成员变量对应的`getter/setter`方法，如果还有其他行为，也需要写上。

### 6.6 对象内存图

![JDK7（左）JDK8（右）](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/c6109c41f1da02b7aee8efcf37f7b8f9-image-20251223145053004.png)

<div style="clear: both;"></div>

回顾：Java代码运行时，先将字节码文件(`.class`)加载进入方法区（元空间）这块内存，然后在栈内存中运行字节码文件中的方法，方法中定义的变量也是存在栈内存中，占内存中的方法运行过程中new出来的内容都会在堆内存中开辟一块内存区域，并产生内存区域相对应的地址。

#### 一个对象的内存图

`Student s = new Student();`：

1. 加载字节码文件（加载`Student.class`到方法区）
2. 声明局部变量（在栈内存中声明局部变量`s`）
3. 在堆内存中开辟一块内存空间（`new Student()`的过程）
4. 默认初始化（`Student`类成员变量对应数据类型的默认值）
5. 显式初始化（定义`Student`类时给成员变量的字面量初始化值）
6. 构造方法初始化（调用`Student`构造函数时，函数中给成员变量的初始化值）
7. 将堆内存中开辟空间的地址值赋值给左边声明的局部变量

图解：

![image-20251225142956508](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/58cf27c291d5d8a725dc66c1df14e049-image-20251225142956508.png)

<div style="clear: both;"></div>

* 上图左边的代码运行时，首先会将`TestStudent.class`加载到方法区，开始执行后将`main`方法加载到栈内存；
* 运行`main`方法第一行，需要创建`Student`对象，于是将`Student.class`加载到方法区；
* 开始创建`Student`对象，现在`main`方法中创建一个局部变量`s`，然后开始在堆内存中开辟一块内存空间（假设内存地址为`001`），根据方法区加载的`Student.class`内容创建对象；
* 先开始对`Student`对象的成员变量进行默认初始化，`name`为`String`类型，默认初始化值为`null`，同理，`age`默认初始化值为`0`;
* 从左边`Student`类的代码来看，没有对成员变量进行显式初始化；（如果定义过程中显式设置了`String name = "张三"`，则会在这一步将值赋给堆内存中对象的`name`属性）
* 由于调用了空参构造器，并且`Student`类的空参构造器并没有手动指定，所以构造方法也没有再对成员变量进行覆盖初始化；
* 堆内存中的`Student`对象创建完成，将内存地址`001`赋值给栈内存中的局部变量`s`；
* 代码继续执行，此时打印`s`的值为`001`，打印`s`中`name`和`age`属性值分别为`null`和`0`；
* 通过`s`访问堆内存相应的内存空间，并修改对象成员变量值后，再打印则为修改后的值；
* 此时再通过`s`调用其中的`study`方法，通过堆内存中记录的方法地址，将方法区中的方法加载到栈空间中，运行方法；
* `study`运行完成后，出栈；
* `main`方法也运行完成，出栈；
* 此时堆内存中地址为`001`区域的对象已无变量指向自己，将在垃圾回收时被回收掉这块内存。

以上就是一个对象在方法运行中创建到销毁（内存释放）的全过程，如果是同一个类的多个对象，也同理，唯一的区别就是**当第二次创建同一个类的对象时，不需要再重新加载字节码文件到方法区**。并且，每次建对象开辟的内存空间之间是相互独立，互不影响的。

#### 两个变量指向同一个对象的内存图

![image-20251225145419891](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/60c23ed540d30dc3f2da47722f6d267c-image-20251225145419891.png)

<div style="clear: both;"></div>

如图，在洞悉了局部变量与堆内存中开辟的内存空间之间的关系之后，多个局部变量指向同一块内存区域的情况就很好理解了，当多个变量指向同一个对象时，只要有其中任何一个变量访问并修改了对象的属性，则所有变量获取到的都是修改后的对象，因为大家（所有变量）记录的都是同一个内存地址值。

将变量的值设为`null`以后，则是掐断了其与堆内存中对象所在内存空间的联系，它将无法访问该对象，当所有的变量都不指向该内存区域时，该内存区域将变成垃圾，然后被GC回收。

#### 基本数据类型和引用数据类型的区别

前文 [1.5  数据类型](#1.5- 数据类型)中对基本数据类型做了介绍，引用数据类型则是只简单归类为除基本数据类型之外的其他。现在结合前两节对与对象的内存图可以从内存的角度对基本数据类型和引用数据类型做一个更加详细解释：

* 基本数据类型数据的值是存储在自己的空间中的，赋值给其他变量赋的是真实的值（例如直接将内存中的补码赋给另一个变量）；
* 引用数据类型数据值则是存储在其他空间中或者空间中的其他内存位置，自己空间中存储的是地址值，赋值给其他变量赋的是地址值（注意这里存储地址值变量的空间并不单单指栈空间，堆空间中的对象成员变量也会存储其他引用数据的地址值）。

#### this的内存原理

this本质：所在方法调用者的地址值。
![image-20251225151847436](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/deb1b64c7ce1196745ef9247d53c2d1d-image-20251225151847436.png)

### 6.7 补充知识：成员变量、局部变量区别


|      区别      |                  成员变量                  |                    局部变量                    |
| :------------: | :----------------------------------------: | :--------------------------------------------: |
| 类中的位置不同 |                类中、方法外                |           方法内、方法声明上（形参）           |
|  初始化值不同  |               有默认初始化值               |           没有，使用之前需要完成赋值           |
|  内存位置不同  |                   堆内存                   |                     栈内存                     |
|  生命周期不同  | 随着对象的创建而存在，随着对象的消失而消失 | 随着方法的调用而存在，随着方法的运行结束而消失 |
|     作用域     |                整个类中有效                |                 当前方法中有效                 |

### 6.8 static

### 6.9 继承

### 6.10 包、final、权限修饰符、代码块

### 6.11 抽象类

### 6.12 接口

### 6.13 多态

### 6.14 内部类

## 7、Lambda表达式和方法引用

## 8、API&字符串

面向对象其实就学两部分，如何使用别人写好的东西？自己如何设计一个类？

### 8.1 API

API：Application Programming Interface，即应用程序编程接口。简单理解就是别人已经写好的东西，我们不需要自己编写，直接使用即可。例如前文中使用的`Random`对象，就是Java中已经编写好的一个工具类。

JavaAPI：指的就是JDK中提供的各种功能的Java类。这些类将底层的功能实现逻辑封装了起来，我们不需要关心这些类是如何实现的，只需要学习使用这些类即可。

Java帮助文档使用：在Oracle官网，有完整的接口文档，将这些接口文档下载下来，然后打包成了`.CHM`文件，就可以离线进行文档的传递了。该文档中，有JDK全部的类以及类的详细说明文档，如果需要查询某个类，直接搜索类名或者到相应的包下查找即可。

![image-20251225173013380](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/110192666ed55e2c04d1cbd432330307-image-20251225173013380.png)

<div style="clear: both;"></div>

说明：`java.lang`包中存放的是Java的基础类，因此在使用这个包下的类的时候，不需要写`import`导包语句。

一般使用步骤：
* 打开API文档
* 点击显示，并找到索引下面的输入
* 在输入框中输入类名并点击显示
* 查看类所在包
* 查看类的描述
* 查看构造方法
* 查看成员方法

例如查看之前生成随机数所用的`java.util.Random`类：

![image-20251226134113331](https://gitee.com/triabin/img_bed/raw/master/2025/12/26/5aea4428e973b4924787460ffeaa55ce-image-20251226134113331.png)

<div style="clear: both;"></div>

:::warning 注意

① `.CHM`文件在Windows系统中可以直接打开，并正常显示；

② 在macOS中可以去AppStore免费下载`CHM Viewer`，用它打开，但是如果文档中有中文，有可能会遇到乱码，此时需要在软件顶部`工具栏-文本编码`中选择`Unicode (UTF-8)`（每次打开都需要选择一次）；

③ JDK各个版本几乎都比较通用，所以国内使用比较广的就是JDK1.8的中文版本，因为这个版本的中文翻译做得相对详尽（虽然也是机翻，但是够看了😅），真正遇到有差异的工具类时再去官网找对应版本的文档即可（一般几乎遇不到这种情况）；

④ 目前比较流行的中文版本是JDK1.8的一个帮助文档，其他版本大同小异，有需要可取Oracle官网下载，例如[JDK21](https://www.oracle.com/java/technologies/javase-jdk21-doc-downloads.html)，[JDK8中文版本](https://www.123865.com/s/VBJ0Td-0qni)。

:::

### 8.2 字符串

字符串，在Java中可以通过双引号字面量直接获取到字符串对象，对于字符串的操作，前文运算符中一节中已经介绍过拼接，此外，字符串的其他常用的操作还有比较、替换、截取、查找、切割、检索、加密、打乱内容、大小写转换等。

字符串在开发中有着极其广泛的应用，尤其在C端，可以说这是最接近C端直接输入和现实的东西，为了方便对字符串的操作，Java中提供了`java.lang.String`、`java.lang.StringBuilder`、`java.lang.StringBuffer`、`java.util.StringJoiner`、`java.util.regex.Pattern`、`java.util.regex.Matcher`等类对方便对字符串进行操作。

#### String

概述：`java.lang.String`类代表字符串，Java程序中的所有字符串文字（例如"abc"）都为此类对象。

注意点：字符串的内容是不会发生改变的，它的对象在创建后不能被更改。如果将两个字符串拼接，那么它将会产生一个新的字符串。

```java
public class StringDemo {
    public static void main(String[] args) {
        String name = "尼古拉斯·阿伟";
        String schoolName = "迦南学院";
        System.out.println(name + schoolName);
        // 以上三行代码共计产生了三个字符串对象

        Sting str = "String1";
        str = "String2";
        // 以上两行代码共计产生两个字符串对象
    }
}
```

创建字符串对象的两种方式：
* 直接赋值：`String name = "尼古拉斯·阿玮";`

* `new`关键字：
  
  |             构造方法             |                            说明                            |
  | :------------------------------: | :--------------------------------------------------------: |
  |        `public String()`         |               创建空白字符串，不包含任何内容               |
  | `public String(String original)` |              根据传入的字符串，创建字符串对象              |
  |  `public String(char[] value)`   |                根据字符数组，创建字符串对象                |
  |  `public String(byte[] bytes)`   | 根据字节数组，创建字符串对象（有重载方法可传入字符集参数） |
  
  这四种方式，前两种几乎不用，第三种一般用于变更字符串的场景，第四种则在网络编程中有较为广泛的应用，在网络环境中传输的数据一般都是字节信息，包括字符串，在将字节信息转为字符串时，就需要用到这个构造方法。

字符串对象创建的内存模型：目前为止，关于Java的内存模型，已经了解了栈内存、堆内存以及方法区三个逻辑分区，而通过**直接使用双引号字面量赋值的字符串**都存在一个新的分区中——`StringTable`（串池，或者字符串常量池），这个分区在JDK7之前是独立的，但是从JDK7开始，这个分区被挪到了堆内存中，但是其核心逻辑并没有变更。

串池工作原理：当通过双引号字面量直接赋值的方式创建字符串对象的时候，JVM会先检查串池中是否存在该字符串，如果存在直接返回该字符串地址，不存在则创建一个字符串再返回其地址。

`public String(char[] value)`创建字符串对象内存模型：

![image-20251226142037671](https://gitee.com/triabin/img_bed/raw/master/2025/12/26/0875ea3a0e2ba411b8332af30f03be11-image-20251226142037671.png)

<div style="clear: both;"></div>

如上图所示，每`new`一次，都会在堆内存中开辟一块空间来存储相同的字符串，完全没有字符串常量池的复用逻辑。

字符串的比较：

```java
public class StringDemo {
    public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "abc";
        System.out.println(s1 == s2); // true
        
        String s3 = "aaa";
        String s4 = "bbb";
        System.out.println(s3 == s4); // false
        
        String s5 = new String("abc");
        String s6 = "abc";
        System.out.println(s5 == s6); // false
    }
}
```

`==`号比较的内容：基本数据类型比较的是具体的值，引用数据类型比较的是地址值。因此则可以解释上述代码的运行结果了。

在`java.lang.String`中，一共提供了两个方法来实现字符串之间的比较功能：

* `public boolean equals("要比较的字符串")`：完全一样的结果才是`true`，否则为`false`，其实现逻辑如下：

  ```java
  public final class String {
      // ...
      
      public boolean equals(Object anObject) {
          if (this == anObject) {
              return true;
          }
          return (anObject instanceof String aString)
                  && (!COMPACT_STRINGS || this.coder == aString.coder)
                  && StringLatin1.equals(value, aString.value);
      }
  }
  
  final class StringLatin1 {
      @IntrinsicCandidate
      public static boolean equals(byte[] value, byte[] other) {
          if (value.length == other.length) {
              for (int i = 0; i < value.length; i++) {
                  if (value[i] != other[i]) {
                      return false;
                  }
              }
              return true;
          }
          return false;
      }
  }
  ```

* `public boolean equalsIgnoreCase("要比较的字符串")`：功能与`equals`相同，只是忽略大小写（见名知意）。

:::info Tips

在编程过程中难免会遇到未知字符串变量与已知字符串进行比较的情况，例如方法传入的字符串参数`value`与已知字符串`"targetValue"`进行比较，此时应该写成`"targetValue".equals(value)`，因为如果反过来写成`value.equals("targetValue")`，虽然代码能编译通过，但是如果调用方法的时候传入的字符串为`null`，那么这种写法将导致空指针异常（`NullPointerException`，算是Java程序员最常见的异常之一了😅）。

:::

`java.lang.String`类中的常用方法（这里只列举方法名，参数和返回值都可见名知意）：

* 长度：`length`

* 检索：检索则需要了解字符串的索引下标这一个概念，类似数组，第一个字符下标为0，从0开始到`length-1`

  ① `charAt`：用于定位指定字符索引

  ② `indexOf`：用于定位指定字符串在字符串中的起始索引

  ③ `contains`：用于判断是否存在指定字符串，返回布尔值

* 比较：`equals`、`equalsIgnoreCase`、`matches`，`matches`参数为正则表达式
* 替换：`replace`、`replaceAll`，`replaceFirst`，注意后两个方法都是匹配的正则表达式
* 截取：`substring`，注意第一参数为截取的起始索引，第二个参数为截取的结束索引后一位（左闭右开区间），第二个参数如果不填，则从起始索引开始截取全部
* 大小写转换：`toUpperCase/toLowerCase`
* 判空：`isEmpty()`
* 其余方法则在使用到的时候再查即可

#### StringBuilder

String的缺陷：

```java
public class StringDemo {
    public static void main(String[] args) {
        // 拼接百万字符串
        String res = "";
        for (int i = 0; i < 1000000; i++) {
            res += "abc";
        }
        System.out.println(res);
    }
}
```

当运行以上代码时，由于字符串常量池中的字符串不可变，将会短时间内在`StringTable`中产生百万个只在一次循环中使用后就丢弃的字符串常量，造成了内存的大量浪费。`java.lang.StringBuilder`就是为了解决这种问题而设计的。

概述：`StringBuilder`可以看成是一个容器，创建之后，里面的内容是可变的，这将大大提高字符串的操作效率。

构造方法：

* `public StringBuilder()`：创建一个空白可变字符串对象，不含有任何内容
* `publci StringBuilder(String str)`：根据字符串内容创建可变字符串对象

常用方法：

* `public StringBuilder append(任意类型)`，拼接数据并返回对象本身（类似前面介绍的方便链式调用的`setter`方法），参数可以是任意类型，会自动调用对应类型的`toString()`方法（该方法每一个对象一定会有，基本数据类型会自动装箱为包装类，然后调用包装类的`toString`方法）
* `public StringBuilder reverse()`：反转容器中的内容
* `public int length()`：与`java.lang.String`类中的一样，返回字符串长度
* `public String toString()`：将`StringBuilder`转为`String`

> 说明：Java底层对`StringBuilder`、`StringBuffer`等类做了特殊处理，在使用`println`方法打印时，不需要另转为`String`，可以直接打印。

#### StringJoiner

```java
public class StringDemo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3 };
        StringBuilder sb = new StringBuilder("[]");
        for (int i = 0; i < arr.length; i++) {
            if (i == arr.length - 1) {
                sb.append(arr[i]);
            } else {
                sb.append(arr[i]).append(", ");
            }
        }
        sb.append("]");
        System.out.println(sb);
    }
}
```

对于以上代码，拼接类似这样的可迭代的数组，还需要判断索引以确定分隔符“, ”是否添加，繁琐且易出错，于是为了解决这种问题就设计了`java.util.StringJoiner`类，上述代码可以使用它进行改写：

```java
import java.util.StringJoiner;

public class StringDemo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3 };
        StringJoiner sj = new StringJoiner(", ", "[", "]");
        for (int i = 0; i < arr.length; i++) {
            sj.add(arr[i] + "");
        }
        System.out.println(sj);
    }
}
```

概述：

* `StringJoiner`与`StringBuilder`一样，都可以看成是一个容器，创建之后里面的内容是可变的；
* 作用：提高字符串的操作效率，而且代码编辑十分简洁，但是由于是JDK8新特新，实际项目中很少人使用，主要是`StringBuilder`使用习惯了，新生代沿用了下来，并且`String`自身也有一个静态方法`String.join()`用来拼接可迭代对象。

构造方法：

* `public StringJoiner("间隔符号")`：创建一个`StringJoiner`对象，只指定拼接时的间隔符号；
* `public StringJoiner(间隔符号, 开始符号, 结束符号)`：创建一个`StringJoiner`对象，指定拼接时的间隔符号、开始符号、结束符号。

常用方法：

* `public StringJoiner add(String "添加的内容")`：添加数据，并返回对象本身
* `public int length()`
* `public String toString()`

#### 字符串原理

回顾：

* 字符串存储的内存原理：直接复制会复用字符串常量池中的，`new`出来的不会复用，而是开辟一个新的内存空间
* `==`号比较的到底是什么：基本数据类型比较数据值，引用数据类型比较内存地址

字符串拼接的底层原理：

* 等号右边无变量参与

  ```java
  public class StringDemo {
      public static void main(String[] args) {
          String s = "a" + "b" + "c";
          System.out.println(s);
      }
  }
  ```

  这种情况会触发编译器的优化机制，在编译时会将它编译成最终结果“"abc"”。

* 等号右边有变量参与

  ```java
  public class StringDemo {
      public static void main(String[] args) {
          String s1 = "a";
          String s2 = s1 + "b";
          String s3 = s2 + "c";
          System.out.println(s3);
      }
  }
  ```

  <img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/26/00f4bf18c82d44586e2dd1e189d5ebf8-image-20251226154057595.png" alt="image-20251226154057595" align="left"/>
  <div style="clear: both;"></div>
  在JDK8以前，会自动使用`StringBuilder`进行拼接，因此在运行类似`String s2 = s1 + "b";`这样一行代码的时候，会创建一个`StringBuilder`对象，然后运行`append`方法将`"b"`拼接到字符串后面，再将`StringBuilder`对象转为`String`对象（通过`new String()`的方式），因此每运行一次这样的拼接以后，都会产生至少一个`String`对象以及在字符串常量池中产生一个拼接目标的字符串常量。这就是直接使用字符串拼接性能低下的原因。
  
  在JDK8中，针对这一情况，对于拼接代码等号右边有变量的情况都会对拼接结果进行一次长度预估，然后创建对应长度的数组，将拼接变量与字符串分别填入数组后再拼接，但是预估以及面对上面这种一个变量就拼接一次的情况，还是会触发多次预估和数组创建，仍浪费时间、内存和性能。

总之，面对多变量字符串拼接的情况，不要直接使用`String`进行拼接，改为使用`StringBuilder`、`StringBuffer`、`StringJoiner`等专门设计的类来进行拼接更为合适。

`StringBuilder`提高效率的原理：所有要拼接的内容都会往`StringBuilder`中存放，不会开辟新的内存空间，节约内存。

`StringBuilder`原码分析：

* 默认创建一个长度为16的字节数组`value`

* 添加的内容长度小于16，直接存

* 添加的内容大于16会扩容（`原来容量 * 2 + 2`）

* 如果扩容后还不够，以实际长度为准进行扩容

* 代码演示：

  ```java
  public class StringBuilderDemo {
      public static void main(String[] args) {
          StringBuilder sb = new StringBuilder();
          System.out.println(sb.capacity()); // 16
          System.out.println(sb.length()); // 0
  
          sb.append("abc");
          System.out.println(sb.capacity()); // 16
          System.out.println(sb.length()); // 3
  
          sb.delete(0, sb.length());
          sb.append("abcdefghijklmnopqrstuvwxyz");
          System.out.println(sb.capacity()); // 34
          System.out.println(sb.length()); // 26
  
          sb.delete(0, sb.length());
          sb.append("abcdefghijklmnopqrstuvwxyz0123456789");
          System.out.println(sb.capacity()); // 36
          System.out.println(sb.length()); // 36
      }
  }
  ```

> 习题：给定两个字符串，A和B。A的旋转操作就是将A最左边的字符移动到最右边，例如，A='abcde'，旋转之后就是'bcdea'，如果在若干次旋转操作之后，A能变成B，返回true，不能则返回false。
>
> 题解：
>
> ```java
> public class Answers {
>     public boolean isRotateMatch(String strA, String strB) {
>         if (strA == null || strB == null) return false;
>         if (strA.length() != strB.length()) return false;
>         if (strA.equals(strB)) return true;
>         for (int i = 0; i < strA.length(); i++) {
>             strA = strA.substring(1) + strA.charAt(0);
>             if (strA.equals(strB)) return true;
>         }
>         return false;
>     }
> }
> ```

## 9、集合

数组的弊端：

### 9.1 集合的基本使用



## 10、常用API

## 11、Stream流

## 12、异常

## 13、File

## 14、IO流

## 15、多线程&JUC

## 16、网络编程

## 17、反射
