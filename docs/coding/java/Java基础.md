---
title: Java基础
order: 2
---

# Java基础

> 带\*号的章节不重要

## 1、Java基础概念

### 1.1 注释

单行注释：`// 单行注释信息`

多行注释：`/* 多行注释信息 */`

文档注释：`/** 文档注释信息 */`

> 说明
>
> 注释内容不会参与编译和运行，仅仅是对代码的解释说明。
>
> 不管是单行注释还是多行注释，在书写的时候都不要嵌套。
>

### 1.2 关键字

关键字：被Java赋予特定含义的英文单词。

关键字特性：

* 关键字的字母全部小写
* 常用代码编辑器针对关键字有特殊的颜色标记，非常直观

> Java中大约有50多个关键字，不必刻意记忆，见官网：[Oracle官网](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)

常见关键字：

* `class`：用于创建/定义一个类，类是Java最基本的组成单元。

### 1.3 字面量

字面量用于告诉程序员数据在程序中的书写格式。

在代码中，一般会书写一下六种字面量：

| 字面量类型 |                   说明                   |            举例             |
| :--------: | :--------------------------------------: | :-------------------------: |
|  整数类型  |             不带小数点的数字             |        `666`，`-88`         |
|  小数类型  |              带小数点的数字              |      `13.14`，`-5.21`       |
| 字符串类型 |           用双引号括起来的内容           | `HelloJava`，`new一个对象`  |
|  字符类型  | 用单引号括起来的内容，内容只能有一个字符 |    `'A'`、`'0'`、`'我'`     |
|  布尔类型  |             布尔值，标识真假             | 只有两个值：`true`、`false` |
|   空类型   |            一个特殊的值，空值            |           `null`            |

用例：

```java
public class ValueDemo {
    public static void main(Stringp[] args) {
        // 整数
        System.out.println(121);
        System.out.println(-33);
      
        // 小数
        System.out.println(3.14);
        System.out.println(-6.98);
      
        // 字符串
        System.out.println("str");
        System.out.println("字符串");
      
        // 布尔
        System.out.println(true);
        System.out.println(false);
      
        // 空
        System.out.println(null);
    }
}
```

**特殊字符类型的字面量：**

* `\t`：制表符，在打印的时候，把前面字符串的长度补齐到8或8的整数倍。最少补一个空格，最多补8个空格。

  ```java
  public class Demo {
    public static void main(String[] args) {
      // 不用制表符的版本全都拼接在一起
      System.out.println("name" + "age");
      System.out.println("tom" + 23);
      
      // 使用制表符后自动对齐
      System.out.println("name" + '\t' + "age");
      System.out.println("tom\t23");
    }
  }
  ```

* `\n`：换行符略

### 1.4 变量

变量：在程序中存储数据的标识。

变量定义：`数据类型 变量名 = 数据值;`

* 数据类型：为存储数据的（内存）空间中存储的数据添加的类型限制（整数、小数、字符串等）。
* 变量名：为存储数据的空间起的名字（标识）。
* `=`：赋值符号，标识将右侧的字面量值赋给左侧的变量名所对应的内存空间。
* 数据值：存储在内存空间中的值。

变量的基本用法：

* 输出打印

  ```java
  int a = 10;
  System.out.println(a); // 10
  ```

* 参与计算

  ```java
  int a = 10;
  int b = 20;
  System.out.println(a + b);
  ```

* 修改记录的值

  ```java
  int a = 10;
  System.out.println("修改前变量a = " + a);
  a = 20;
  System.out.println("修改后变量a = " + a);
  ```

变量使用的注意事项：

* 只能存一个值

* 变量名不允许重复定义

* 一条语句可以定义多个变量（逗号隔开即可）

  ```java
  int a = 1, b = 2, c = 3, d = 4;
  ```

* 变量在使用之前一定要进行赋值

* 变量的作用域范围

### 1.5  数据类型

**基本数据类型：** 分为4类8种

* 整数

  ① byte：内存占用1个字节，即8个比特位，取一位作为符号位，其取值范围为`-128~127`，多用它的数组来存取流转文件内容。

  ② short：内存占用2个字节，去一位作为符号位，其取值范围为`-32768~32767`。

  ③ int：整数字面量的默认类型，内存占用4个字节，取值范围为`-2147483648~2147483647`。

  ④ long：内存占用8个字节，取值范围：`-9223372036854775808~9223372036854775807`，定义字面量时需要在字面量后面加一个`L`或`l`，但是一般建议使用大写的`L`，因为小写的`l`辨识度没有大写的高。

* 浮点数

  ① float：内存占用4个字节，共计32个比特位，第一位用来表示符号位；2\~9位为指数（阶码）；10\~32位为有效数字（尾数）。所以它的取值范围为`-3.401298e-38~3.402823e+38`。定义float字面量时也需要在末尾加一个`F`或`f`，一般建议使用大写。

  （TODO：关于浮点数的存储原理，还需另做文章解读）

  ② double：浮点数字面量的默认类型，内存占用8个字节，`-4.9000000e-324~1.797693e+308`。

* 字符：char，内存占用2个字节，取值范围为`0~65535`，字面量为单个字符，使用单引号括起来。

* 布尔：boolean，内存占用1个字节，值为`true`、`false`。

**引用数据类型**：数组、字符串、其他对象。

### 1.6 标识符

标识符：给类、方法、变量等取的名字。

命名规则：

* 由数字、字母、下划线和美元符号组成；
* 不能以数字开头
* 不能是关键字
* 区分大小写

命名规范：

* 方法和变量使用小驼峰命名法，即第一个单词首字母小写，其余大写；
* 类名使用大驼峰命名法，即每个单词首字母大写；
* 尽可能的见名知意

:::warning 注意

① 下划线开头的标识符：在早期代码中，有时用 `_`开头表示“私有”或“内部”成员（如 `_count`），但这不是强制规范，Oracle 官方编码规范不鼓励使用下划线开头，并且Java 9+ 中，单独的下划线 `_`是关键字（受限标识符），不能作为变量名；

② 美元符号开头的标识符：$常见于编译器自动生成的类或变量名（反编译class文件后可见），手动编写的代码中要尽可能的避免，以免与编译器生成的名称冲突。

:::

### 1.7 键盘录入\*

*观前提醒：常规开发工作过程中，这玩意儿几乎用不到，常见于公司内部自己写的命令行小工具，极少使用，常规上线的大型项目中我从来没见过使用。*

Java自带了`java.util.Scanner`类，用于处理键盘的输入。

```java
import java.util.Scanner;

public class Demo {
  Scanner sc = new Scanner(System.in);
  
  int input = sc.nextInt(); // 接收int型的数据，其他数据类型同理
  
  System.out.println("输入内容：" + input);
}
```

## 2、运算符

运算符和表达式：对字面量或者变量进行操作的符号即为运算符；用运算符把字面量或者变量连接起来，符合Java语法的式子就可以称为表达式。不同运算符连接的表达式体现的是不同类型的表达式。

### 2.1 算数运算符

加`+`、减`-`、乘`*`、除`/`、取模（余）`%`（运算符作用略或参见小学数学🐶）

在代码中，如果有小数参与计算，计算结果有可能不精确，所以在银行项目中涉及到小数点后几位一般要么用要么用BigDecimal对象，要么小数点后的位数用int手动计算。(TODO: 关于编程中小数不精确问题解析)

在除法运算中，如果除数和被除数都是整数，那么运算结果也会被作为整形（截取），除数和被除数任意一个如果是浮点类型，则计算结果自动四舍五入（或不精确）。

关于取模（余）运算，一般用于判断是否整除（余数为0），是否为偶数（能被2整除），以及范围内循环等。

`+`运算符的三种情况：

* 数字相加：数值相加

  隐式转换：又叫自动类型提升，取值范围小的数值转为取值范围大的数值。例如，在加法运算中，其中一个加数为double类型，其余为int，则相加结果为double类型，隐式转换不需要写额外的代码。

  * 取值范围从小到大：`byte < short < int < long < float < double`

  * 隐式转换的两种提升规则：一是取值范围小的和取值范围大的进行运算，晓得会先提升为大的，再进行计算；二是`byte`、`short`、`char`三种类型的数据在运算的时候，都会直接先提升为`int`，然后再进行计算（即使进行计算的两个数都是同一种数据类型，只要进行加法运算了，最终结果都是`int`类型）。

  强制转换：取值范围大的数值转为取值范围小的数值。如果把一个取值范围大的数值赋值给一个取值范围小的变量，是不允许赋值的，如果一定要赋值，那么就需要加入强制转换，强制转换需要手动编写代码声明。

  * 格式：`目标数据类型 变量名 = (目标数据类型) 被强转的数据（可以是变量名和字面量）;`
  * 强制转换可能会导致数据发生错误，例如将128转为`byte`类型，这超出了它的取值范围，就会导致出现错误。

* 字符串相加：如果`+`操作中出现字符串，此时这个`+`号就是字符串连接符，而不是运算符了，它会将前后的数据进行拼接并产生一个新的字符串。当然，如果是多个数字和字符串混合，则由是从左道友两个两个进行运算，所以在遇到字符串之前的数字都是进行正常的数值运算，遇到字符串之后的则全都是拼接。

* 字符相加：当`字符+字符`或`字符+数字`时，会将字符通过ASCII码查询到相应的数字之后再进行计算，如果是非ASCII字符，则使用期Unicode码点的值进行计算（例如`'中'`的码点为20013）。

> 练习题：键盘录入一个三位数，将其拆分为个位、十位、百位，然后分别打印在控制台。
>
> 题解：$位值 = 输入值 \div 所在位基础值 \bmod 10$
>
> 例如，
>
> $123_{个位} = 123 \div 1 \bmod 10 = 3$
>
> $123_{十位} = 123 \div 10 \bmod 10 = 2$（Java中的整数除法会被截取整形）
>
> $123_{百位} = 123 \div 100 \bmod 10 = 1$

### 2.2 自增/减运算符

自增运算符`++`：可以卸载变量的前面或者后面，作用是变量值+1。

* 写在后面：先使用变量，然后再给变量加一，例如`int a = 1;`那么`1 + a++`的运算结果为2，但是运算结束后a的值为2。
* 写在后面：与写在前面相反，上述示例中，如果是`1 + ++a`，则运算结果为3，运算结束后a的值为2。

无论是写在前面还是写在后面，单独使用的话，都没有区别；自增和自减多用于循环中。

### 2.3 赋值运算符

| 符号 |    作用    |              说明              |
| :--: | :--------: | :----------------------------: |
| `=`  |    赋值    | `int a = 10;`，将10赋值为变量a |
| `+=` |  加后赋值  |    `a += b; => a = a + b;`     |
| `-=` |  减后赋值  |    `a -= b; => a = a - b;`     |
| `*=` |  乘后赋值  |    `a *= b; => a = a * b;`     |
| `/=` |  除后赋值  |    `a /= b; => a = a / b;`     |
| `%=` | 取余后赋值 |    `a %= b; => a = a % b;`     |

`+=`、`-=`、`*=`、`/=`、`%=`底层都隐含了一个强制类型转换：

```java
public class Demo {
  public static void main(String[] args) {
    short s = 1;
    s += 1; // 运算结果的类型还是short，不是int，等同于s = (short) (s + 1);
    System.out.println(s);
  }
}
```

### 2.4 关系运算符

关系（比较）运算符的分类：

| 符号 |                             说明                             |
| :--: | :----------------------------------------------------------: |
| `==` |  `a == b`，判断a与b是否相等，成立为`true`，不成立为`false`   |
| `!=` | `a != b`，判断a与b是否不相等，成立为`true`，不成立为`false`  |
| `>`  |    `a > b`，判断a是否大于b，成立为`true`，不成立为`false`    |
| `>=` | `a >= b`，判断a是否大于或等于b，成立为`true`，不成立为`false` |
| `<`  |    `a < b`，判断a是否小于b，成立为`true`，不成立为`false`    |
| `<=` | `a <= b`，判断a是否小于或等于b，成立为`true`，不成立为`false` |

关系运算符的结构式boolean型。

### 2.5 逻辑运算符

在数学中，一个数据x，大于5，小于15，可以表示为：`5 < x < 15`，但是在Java中，需要将该式子进行拆解再进行合并表达：

* 拆解为：`x > 5`和`x < 15`
* 合并为：`x > 5 & x < 5`

| 符号 |     作用     |                             说明                             |
| :--: | :----------: | :----------------------------------------------------------: |
| `&`  | 逻辑与（且） |       并且，符号前后表达式/值为`true`，结果才是`true`        |
| `&&` |    短路与    | 如果符号前面的表达式运算结果/值为`false`，直接得出结果为`false`，不再运行符号后面的内容 |
| `|`  |    逻辑或    |            或者，两边都为`false`，结果才是`false`            |
| `||` |    短路或    | 如果符号前面的表达式/值为`true`，则直接得出结果为`true`，不再运行符号后面的内容 |
| `^`  |   逻辑异或   |                 相同为`false`，不同为`true`                  |
| `!`  |    逻辑非    |                             取反                             |

使用注意事项：

* 取反运算符最好不要多写，确定好逻辑后只写一次即可；
* 短路运算符简单理解：当左边表达式能确定最终结果，那么右边表达式就不再参与运行；
* 最长用的逻辑运算符：`&&`、`||`、`!`

### 2.6 三元运算符

三元运算符：又叫条件表达式、条件运算符、三目运算符等。其格式为`关系表达式 ? 表达式1 : 表达式2;`，关系表达式运算结果为`true`，则取`表达式1`结果，否则取`表达式2`，例如取两个数的较大值：`a > b ? a : b;`。

计算规则：

* 首先计算关系表达式的值
* 如果值为`true`，表达式1的值就是运算结果
* 如果值为`false`，表达式2的值就是运算结果

### 2.7 原码、反码、补码

**原码**：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。利用原码对正数进行计算是不会有问题的，但是如果是负数计算，由于第一位为符号位，那么运算结果就会出错（如果单独为负数运算写一套运算逻辑，那么对于CPU来说代价太大且极不方便），实际的运算结果与预期结果是相反的（符号位没变化），于是就设计了反码来对负数进行计算。

**反码**：为了解决原码不能计算负数的问题而出现的，正数的反码是其本身，负数的反码是符号位保持不变，其余位取反。

* 计算规则：正数反码不变，负数的反码在原码的基础上，符号位不变，数值取反，即0变1,1变0。
* 反码进行加减运算得到结果的反码
* 但是当反码加减结果跨0的时候出现了问题（结果为正数），因为在反码中出现了两个0（"-0"的`1000 00000`和“+0”的`0000 0000`的反码），于是为了只保留一个0，就在负数反码基础上+1（保留了原“-0”，原码为`1000 0000`，反码为`1111 1111`，加1后转为了`0000 0000`），得到了补码。

**补码**：正数的补码是其本身，负数的补码是在其取反的基础上+1。由于反码转为原码过程中，“-0”`1000 000`一直没有被使用，所以就规定，`1000 0000`为数字-128的补码（-128没有原码和反码），所以一个字节能表示的整数数值范围为`-128~127`，并且基于这个原因（方便CPU运算），CPU寄存器和内存中（甚至硬盘中）的整数的存储方式都是补码，所以原码和反码对于计算机来说都是概念上的东西，它不需要原码和反码，只需要补码进行数据流转运算即可，所以即使-128在计算机中没有原码和补码也不影响。

:::info Tips

有了原码、反码和补码的前置知识，就可以解释前面的Java基本数据类型取值范围的缘故了：

  ① byte占用一个字节，共计8个bit，所以取值范围为`-128~127`，short占两个字节，所以取值范围是`-32768~32767`……

  ② 隐式类型转换：整数隐式类型转换其实就是在小范围数据类型前面补0补到大范围数据类型的长度即可；

  ③ 强制类型转换：从左往右除去超出长度的比特位，保留剩下的比特位（丢失了前面的比特位很可能导致错误数据，例如正数变负数这种）。

:::

### 2.8 其他运算符

在学习了原码、反码和补码的相关知识后，逻辑与和逻辑或也能作为位运算符：

| 运算符 |    含义    |                           运算规则                           |
| :----: | :--------: | :----------------------------------------------------------: |
|  `&`   |   逻辑与   |            0为false，1为true（1是0否，编程通用）             |
|  `|`   |   逻辑或   |                      0为false，1为true                       |
|  `<<`  |    左移    | 补码向左移动，低位（移动后空出来的位置）补0，左边移出去的比特位丢弃 |
|  `>>`  |    右移    |            补码向右移动，高位补0或1（正数与负数）            |
| `>>>`  | 无符号右移 |                      向右移动，高位补0                       |

逻辑或与逻辑与：两个数的补码进行按位逻辑运算即可得到结果。

左移：实际上每左移一位，数值运算上就是原数值乘以2，有时候要写高性能代码常用，因为CPU的寄存器直接移位运算要比数值加减乘除快得多。

右移：高位（左侧）如果是1（负数）则补1，如果是0（正数），则补0，右移一次相当于原数值除以2。

无符号右移：不管正负，高位都是补0。

### 2.9 运算符优先级

| 优先级 |                 运算符                  |
| :----: | :-------------------------------------: |
|   1    |             `.`、`()`、`{}`             |
|   2    |          `!`、`~`、`++`、`--`           |
|   3    |              `*`、`/`、`%`              |
|   4    |                `+`、`-`                 |
|   5    |            `<<`、`>>`、`>>>`            |
|   6    |   `<`、`<=`、`>`、`>=`、`instanceof`    |
|   7    |               `==`、`!=`                |
|   8    |                   `&`                   |
|   9    |                   `^`                   |
|   10   |                   `|`                   |
|   11   |                  `&&`                   |
|   12   |                  `||`                   |
|   13   |                  `?:`                   |
|   14   | `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`&=` |

以上为Java中运算符的优先级，但是一般除了`<<`、`>>`、`>>>等涉及到CPU直接移位运算的符号外，其余时候皆直接使用小括号确定优先级。

## 3、流程控制语句

### 3.1 顺序结构

顺序结构语句是Java程序默认的执行流程，按照代码的先后顺序，从上到下依次执行。

### 3.2 分支结构

#### if语句

if语句在程序中就是用来判断的。

**①** if的第一种格式：

```java
// if 语句结构
if (关系表达式) {
  语句体;
}
```

执行流程：

* 首先计算关系表达式的值
* 如果表达式的值为`true`就执行语句体
* 如果关系表达式的值为`false`就不执行语句体
* 继续执行后面的其他语句

if语句的使用：

* 大括号的开头可以另起一行书写，但是建议写在第一行的末尾（Java语言的语法规范）
* 在语句体中，如果只有一句代码，大括号可以省略不写（在大型项目中不建议这样做）
* 如果对一个布尔类型的变量进行判断，不要用`==`号

**②** if的第二种格式：

```java
if (关系表达式) {
  语句体1;
} else {
  语句体2;
}
```

执行流程：

* 首先计算关系表达式的值
* 如果表达式的值为`true`就执行语句体1
* 如果关系表达式的值为`false`就执行语句体2
* 继续执行后面的其他语句

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/19/351060426455ab3df5ca3ebed00df4c2-image-20251219165245221.png" alt="image-20251219165245221" style="zoom:80%;" align="left" />

<div style="clear: both;"></div>

**③** if语句的第三种格式：

```java
if (关系表达式1) {
  语句体1;
} else if (关系表达式2) {
  语句体2;
}
  ...
 else if (关系表达式n) {
   语句体n;
 } else {
   语句体n+1;
 }
```

执行流程：逐个判断关系表达式，执行第一个关系表达式值为`true`的语句体，如果都为`false`，就执行语句体n+1。

#### switch语句

语句格式：

```java
switch (表达式) {
  case 值1:
    语句体1;
    break;
  case 值2:
    语句体2;
    break;
  ...
  case 值n:
    语句体n;
    break;
  default:
    语句体n+1;
    break; // 末尾可省略
}
```

执行流程：

* 首先计算表达式的值。
* 一次和case后面的值进行比较，如果有对应的值，就会从该case的语句体开始往后依次执行，中间如果遇到break或者方法中的return语句等，就会结束。
* 如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后结束整个switch语句。

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/19/8214cca4f8a3dff7f0874bc9b32f6e3a-image-20251219171412000.png" alt="image-20251219171412000" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

格式说明：

* 表达式：将要匹配的值，取值为`byte`、`short`、`int`、`char`，jdk5以后可以是`枚举`，jdk7以后可以是`String`（不能是`long`和浮点型）。
* case：后面跟的是要和表达式进行比较（匹配）的值。
* break：用于中断（提前结束）switch语句。
* default：所有情况都不匹配的时候就执行该语句体（类似if中的else），非必填项，也不一定是写在最下面，可以写在case之间的任意位置。当然还是比较建议必须写在最后面。
* case的值只能是字面量，不能是变量，且case后面的值不允许重复。

:::info Tips

① 如果有多个case后面的值都是相同的处理逻辑，可以直接将这些值（case 值:）写在一起，一行一条语句（必须逐行挨在一起），然后在最后一条语句后面只写一遍处理逻辑，这样任意一个case匹配成功都可迅速往后执行。（利用case穿透）

② 最后一条语句（不管是case还是default）可以不需要`break`也能正常结束，不过一般还是建议都写上，避免以后往后面添加逻辑的时候忘记写酿成惨剧（后果一般都挺严重），不要管编辑器会不会有格式告警那些。

③ jdk12以后switch新特性：

```java
public class Demo {
    // 使用此新特性，可以省略break语句，不存在穿透现象
    public static void printChNum(int num) {
        switch (num) {
            case 1 -> System.out.println("一");
            case 2 -> {
                // 只有一行的时候，花括号可省略
                System.out.println("二");
            }
            case 3 -> System.out.println("三");
            case 4, 5, 6, 7 -> System.out.println("即将支持！"); // 当需要利用穿透时还可以直接用逗号隔开多个匹配值
            default -> System.out.println(num + "这个数字还是算了。");
        }
    }
}
```

④ switch和if的选用：if一般用于对范围的判断，switch一般用于易穷举结果的匹配。

:::

### 3.3 循环结构

循环：重复做某件事，具有**明确的开始和停止标记**。在Java中，循环一共分为三类，分别是`for循环`、`while循环`以及`do...while循环`（几乎不怎么使用）。

#### for循环

格式：

```java
public class Demo {
    public static void main(String[] args) {
        //for(初始化语句;条件语句;条件控制语句) {
        //    循环结构语句;
        //}
        // 举例：打印十次HelloWorld
        for (int i = 0; i < 10; i++) {
            System.out.println("Hello World!");
        }
    }
}
```

执行流程：

* 执行初始化语句（只执行一次）
* 执行条件判断语句，判断为`true`则执行循环结构语句，`false`则循环结束
* 执行条件控制语句
* 回到第二步，重新开始执行条件判断语句，开启新一轮循环

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/22/14273258547a6ac4e033ab7f7951a2e3-image-20251222134920374.png" alt="image-20251222134920374" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

:::info Tips

① 初始化语句、条件语句和条件控制语句甚至循环结构语句都是非必填项，当然不建议这么做，如果省略条件语句，代表循环将会是一个死循环，容易造成OOM（内存溢出异常），不过有时候会用`for (::) + break;`类代替`while`循环。（`break`关键字在这里为跳出循环语句）。

② 当嵌套多层`for`循环时，可以给每层循环单独添加标签名，然后使用break关键字跳出指定循环：

```java
public class Demo {
    public static void main(String[] args) {
        outer: for (int i = 0; i < 100; i++) {
            inner: for (int j = 0; j < 100; j++) {
                if (i + j == 40) {
                    break outer;
                }
            }
        }
    }
}
```

:::

#### while循环

格式：

```java
public class Demo {
    public static void main(String[] args) {
        // 初始化语句;
        // while (条件判断语句) {
        //    循环控制语句;
        //    条件控制语句;
        // }
        // 举例：打印十次HelloWorld
        int count = 0;
        while (count < 10) {
            System.out.println("Hello World!");
            count++;
        }
    }
}
```

执行流程：

* 执行初始化语句（只执行一次）
* 执行条件判断语句，判断为`true`则执行循环结构语句，`false`则结束循环
* 执行条件控制语句
* 回到第二步，重新开始执行条件判断语句，开启新一轮循环

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/22/7a39187009e007a08a33c3fc3c54470f-image-20251222140845221.png" alt="image-20251222140845221" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

`for`和`while`对比:

* 相同点：运行规则都是一样的

* 区别：

  ① for循环中，控制循环的变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了；

  ② while循环中，控制循环的变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用；

  ③ for循环一般用在明确知道循环的次数或循环的范围时；

  ④ while循环一般用在不知道循环的次数或范围，但是明确知道循环结束的条件时。

> 案例1：打印折纸的次数
>
> 需求：世界最高峰是珠穆朗玛峰（8844.43米=8844430毫米），加入有一张足够大的纸，它的厚度是0.1毫米。请问需要折叠多少次，可以折成珠穆朗玛峰的高度？
>
> ```java
> // 题解：
> public class Anwser {
>     public int solution() {
>         double hight = 0.1;
>         int count = 0;
>         while (hight < 8844430) {
>             hight *= 2;
>             count++;
>         }
>         return count;
>     }
> }
> ```
>
> 案例2：回文数
>
> 需求：给你一个整数x，如果x是一个回文整数，打印true，否则返回false。
>
> 解释：回文数是指正序（从左到右）倒序（从右向左）读都是一样的整数。例如，121是回文，而123不是。
>
> ```java
> // 题解：
> public class Anwser {
>     public boolean solution(int x) {
>         // 用于循环流转变换的值
>         int loopVal = x;
>         // 记录从数字x从右往左倒过来的值
>         int palindrome = 0;
>         while (loopVal != 0) {
>             // 从右往左获取每一个数字
>             int posVal = loopVal % 10;
>             palindrome = palindrome * 10 + posVal;
>             // x个位上的值已获取，所以产生新的个位值
>             loopVal /= 10;
>         }
>         return palindrome == x;
>     }
> }
> ```
>
> 案例3：求商合余数
>
> 需求：给定两个整数，被除数和除数（都是正数，且不超过int范围）。将两数相除，要求不适用乘法、除法和取余运算符，得到商和余数。
>
> ```java
> // 题解：
> public class Anwser {
>     /**
>      * 方法描述：给定两个整数，被除数和除数（都是正数，且不超过int范围）。将两数相除，要求不适用乘法、除法和取余运算符，得到商和余数
>      *
>      * @param dividend 被除数
>      * @param divisor  除数
>      */
>     public void solution(int dividend, int divisor) {
>         int quotient = 0; // 商
>         int remainder = dividend; // 余数
>         while (remainder > divisor) {
>             remainder -= divisor;
>             quotient++;
>         }
>         System.out.printf("%d ÷ %d ＝ %d...%d\n", dividend, divisor, quotient, remainder);
>     }
> }
> ```

#### do...while循环*

格式：

```java
public class Demo {
    public static void main(String[] args) {
        // 初始化语句;
        //do {
        //    循环体语句;
        //    条件控制语句;
        //} while (条件判断语句);
        // 举例：打印十次HelloWorld
    }
}
```

与while区别就是先执行一遍循环体语句和控制语句再做判断，其余没有区别。

#### 无限循环和跳转控制语句

**无限循环**：循环一直停不下来（核心思想都是使条件判断结果始终为`true`），一般用于既不明确循环次数（或范围）也不明确结束条件的情况。一般来说，结束条件可能需要循环语句的运行结果来确定，又或者结束条件为程序停下来（只要程序不停止循环就不停止）。

```java
public class Demo {
    public static void main(String[] args) {
        // 无限循环的三种格式
        for (;;) {
            System.out.println("for无限循环");
        }
        while (true) {
            System.out.println("while无限循环");
        }
        do {
            System.out.println("do...while无限循环");
        } while (true);
    }
}
```

**循环的跳转控制语句**：涉及到两个关键字，`continue`：跳过本次循环，继续执行下次循环；`break`：结束整个循环。

> 案例1：求平方根
>
> 需求：键盘录入一个大于等于2的整数x，计算并返回x的平方根。结果只保留整数部分，小数部分将被舍去。
>
> 题解：从1开始计算每个数的平方，直到结果大于x，则取上一次的数。
>
> 案例2：判断是否为质数
>
> 需求：键盘录入一个正整数，判断其是否为质数。
>
> 题解：从2开始，直到其平方根（小于等于平方根），一个数一个数的判断能否被该数字整除，如果都不能则为质数。

## 4、数组

### 4.1 数组介绍

数组：一种容器，可以用来存储 **同种类型** 的多个值。

* 数组在容器存储的时候，关于数据类型限制，需要结合隐式转换。

### 4.2 数组的定义与静态初始化

数组的定义

* 范式一：`数据类型[] 数组名`（常用）
* 范式二：`数据类型 数组名[]`

数组的初始化：就是在内存中，为数组容器开辟空间，并将数据存入容器中的过程。

* 静态初始化：`数据类型[] 数组名 = new 数据类型[]{ 元素1, 元素2, 元素3... };`

  简化格式：`数据类型[] 数组名 = { 元素1, 元素2, 元素3... };`

  例：`int[] arr = new int[]{11, 22, 33};`

* 数组的地址值：定义好数组后，使用print函数打印到控制台，会得到一个地址值（例`[I@73846619`），这个地址值就表示数组容器在内存中的位置。

  解释一下地址值中各个部分的含义，以`[I@73846619`为例：

  ① `[`：表示数据位一个数组

  ② `I`：表示数组数据类型为`int`

  ③ `@`：间隔符号，固定格式

  ④ `73846619`：真正的地址值（十六进制）

### 4.3 数组元素访问

格式：`数组名[索引];`，索引也叫做下标，角标，从0开始，逐个+1增长，连续不间断。

利用索引对数组中的元素进行访问：

* 获取数组中的元素：`数组名[索引]`，数组索引范围为`0~数组长度-1`。
* 把数据存到数组中：`数组名[索引] = 具体数据/变量`，赋值一旦覆盖，原数据就不在数组中了。

### 4.4 数组遍历

数组遍历：就是取出数组中所有数据的过程，取出后方便加以应用（例如计算、判断以及最简单的打印等）。

```java
public class Demo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        // 利用循环遍历数组，开始条件为索引0，结束条件为数组最大索引（长度-1），条件控制为每次索引+1
        for (int i = 0; i < arr.length - 1; i++) {
            System.out.println(arr[i]);
        }
        // arr.length为数组长度，length是数组的一个属性，其值为数组长度，调用方式：数组名.length
    }
}
```

### 4.5 数组动态初始化

动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。

* 格式：`数据类型[] 数组名 = new 数据类型[数组长度];`，例`int[] arr = new int[3];`

* 数组默认初始化值的规律：

  ① 整数类型：0

  ② 小数类型：0.0

  ③ 字符类型：`/u0000`（空格）

  ④ 布尔类型：`false`

  ⑤ 引用数据类型：`null`

动态初始化和静态初始化区别：

* 动态初始化需手动指定数组长度，由JVM分配默认初始化值，适用于只明确个数，不确定初始化值；
* 静态初始化需手动指定元素值，JVM根据所给出的初始化值计算数组长度，适用于明确了具体操作数据的情况。

### 4.6 数组内存图

Java的内存分配：

* 栈：方法运行时使用的内存，比如`main`方法运行，进入栈中执行

* 堆：存储对象或者数组，`new`来创建的，都存储在堆内存

  在堆中每开辟一块内存，它都会有一个自己的地址值。

* 方法区：存储可以运行的`.class`文件

  **注意**：① 在jdk7以前，方法区和堆空间逻辑上是放在一起的，物理上也是一块连续的内存区域；② 从jdk8开始，取消了方法区，新增元空间，把原来方法区的多种功能进行拆分，有的功能放到了堆中，有的功能放到了元空间中（包括加载字节码文件的功能也放到了元空间）。

* 本地方法栈：JVM在使用操作系统功能的时候使用，与我们Java开发无关

* 寄存器：给CPU使用，与我们无关![JDK7（左）JDK8（右）](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/c6109c41f1da02b7aee8efcf37f7b8f9-image-20251223145053004.png)

<div style="clear: both;"></div>

只涉及到基本数据类型的方法运行内存图（逐行）：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/89b4a23777bdafd0da0c6cb5043d0a3c-image-20251223150425735.png" alt="image-20251223150425735" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

数组内存图：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/6cf3d763b8dd10986eaef6211c78e41d-image-20251223150801275.png" alt="image-20251223150801275" align="left"/>

<div style="clear: both;"></div>

> **总结**
>
> ① 只要是new出来的一定是在堆里面开辟了一个小空间；
>
> ② 如果new了多次，那么在堆里面有多个小空间，每个小空间中都有各自的数据。

两个数组指向同一块内存空间的内存图：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/eca539cf3435b5b810c6a5e9b5c6efe8-image-20251223151214800.png" alt="image-20251223151214800" align="left"/>

<div style="clear: both;"></div>

> **总结**
>
> 当两个数组指向同一块内存区域时，其中一个数组对内存区域中的值进行修改，那么其他数组再次访问时都是修改后的结果。

### 4.7 数组常见问题

常见问题：数组越界异常，当访问了数组中不存在的索引，就会引发索引越界异常。（超出最大索引或者小于0）

### 4.8 数组常见操作

求最值、求和并统计个数、交换数据、打乱数据等。

```java
import java.util.Arrays;
import java.util.Random;

public class MyArrayUtils {
    // 求最大值
    public static int getMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            max = arr[i] > max ? arr[i] : max;
        }
        return max;
    }
    
    // 求和并统计个数
    /*
    需求：生成10个1~100之间的随机数存入数组
    1）求出所有数据之和
    2）求所有数据的平均数
    3）统计有多少个数据比平均值小
    */
    public static void statisticsSum() {
        // 1. 定义数组
        int[] arr = new int[10];
        // 2. 生成随机数据
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(100) + 1;
        }
        System.out.println("生成的随机数组：" + Arrays.toString(arr));

        // 3. 求和
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        System.out.println("求和：" + sum);

        // 4. 求平均数
        double avg = (double) sum / arr.length;
        System.out.println("平均数：" + avg);

        // 5. 统计有多少个数据比平均值小
        int leThanAvgCount = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < avg) {
                leThanAvgCount++;
            }
        }
        System.out.println("比平均数小的元素个数：" + leThanAvgCount);
    }
    
    // 交换数组中的数据：定义一个数组，反转整个数组
    public static void reverse(int[] arr) {
        // 两种方式都行
//        for (int i = 0; i < arr.length / 2; i++) {
//            int temp = arr[i];
//            arr[i] = arr[arr.length - i - 1];
//            arr[arr.length - i - 1] = temp;
//        }

        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    // 打乱数组数据
    public static void shuffle(int[] arr) {
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            // 获取数组索引范围内的随机数
            int index = random.nextInt(arr.length);
            int temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;
        }
    }
}
```

## 5、方法

### 5.1 什么是方法

概念：方法（method）是程序中最小的执行单元。例如Java程序的入口就是main方法。

创建：重复的、具有独立功能的代码逻辑可以抽象/提取到方法中。

作用：可以代码的复用性，也可以提高代码的可维护性（同一逻辑出现问题，只需修改方法体即可，调用方法的地方不用修改）

### 5.2 方法的格式

方法本质就是将一些代码**打包**在一起，用到的时候就**调用**。

定义方法：把一些代码打包到一起，该过程称为方法定义。

方法调用：方法定义完成后并不会主动运行，需要手动调用才能执行，该过程称为方法调用。（方法必须先定义后调用）

#### 最简单的方法定义

```java
public class MethodDemo {
    // 格式：
    // public static void 方法名() {
    //     方法体（就是打包起来的代码）;
    // }
    
    public static void main(String[] args) {
        // 调用定义好的方法
        playLKL();
        // 多次调用
        playLKL();
        playLKL();
        playLKL();
    }
    
    // 定义一个方法
    public static void playLKL() {
        System.out.println("选英雄");
        System.out.println("准备开局");
        System.out.println("对线");
        System.out.println("崩盘");
        System.out.println("骂队友");
        System.out.println("送人头");
        System.out.println("GG");
    }
}
```

#### 带参数的方法定义

```java
public class MethodDemo {
    // 格式：
    // public static void 方法名(参数列表（多个参数用逗号隔开）) {
    //     方法体;
    // }
    // 调用：方法名(参数1, 参数2, ...);
    // 注意：方法调用时，参数的数量与类型必须与方法中定义中小括号里面的变量一一对应，否则程序将报错
    
    public static void main(String[] args) {
        // 调用方法
        getSum(10, 11); // 21
    }
    // 定义方法
    public static void getSum(int num1, int num2) {
        System.out.println(num1 + num2);
    }
}
```

形参和实参：形参即形式参数，指的是方法定义中参数列表中的参数；实参即实际参数，指的是方法调用时传入方法的参数。方法调用时方法的形参和实参必须一一对应，否则程序将报错（编译时报错）。

#### 带返回值的方法定义

需要返回值的原因：方法返回的结果在调用处可能会有别的用途。（有返回值也不是一定会使用的哦）

方法的返回值其实就是方法运行的最终结果，如果在调用处要根据方法的结果去编写另一端代码逻辑，为了在调用处拿到方法产生的结果，就需要定义带有返回值的方法。

```java
public class MethodDemo {
    // 格式：
    // public static 返回值类型 方法名(参数列表) {
    //     方法体;
    //     return 返回值;
    // }
    
    public static void main(String[] args) {
        // 直接调用
        getSum(10, 11);
        // 赋值调用
        int sum = getSum(11, 12);
        // 直接使用运行结果
        System.out.println(getSum(12 + 13)); // 25
    }
    
    public static int getSum(int num1, int num2) {
        return num1 + num2;
    }
}
```

:::info Tips

方法定义技巧：

* 我需要什么？（参数列表）
* 我具体要做什么？（方法体）
* 我要返回什么？（返回值）

:::

方法的注意事项：

* 方法不调用就不执行
* 方法与方法之间是平级关系，不能互相嵌套定义
* 方法的编写顺序与执行顺序无关，只看调用顺序
* 方法的返回值类型为void，标识该方法没有返回值，没有返回值的方法可以省略不写，但是可以使用return语句（后面不跟任何内容）直接结束方法

#### 可变参数

假如你需要定义一个求和方法，该方法可以灵活完成如下需求：计算两个数据的和、计算3个数据的和、计算4个数据的和……最初的做法是将传入参数定义为一个数组，但是在简单使用过程中发现过于繁琐，需要将参数定义为数组，还需要将数组引用传进方法，于是后来（JDK5）就引入了可变参数的概念。

可变参数：方法形参的个数是可以发生变化的，格式为`属性类型... 形参名`，例如`int... args`。

底层：可变参数底层本质就是一个数组，只不过这个数组不需要手动创建，而是由JVM自己创建。

使用注意事项：

* 在方法形参中最多只能有一个可变参数
* 在方法中，如果除了可变参数外，还有其他形参，那么可变参数要写在最后
* 如果参数为可变参数，即使不传入参数也可以（空列表）
* 如果方法参数定义为可变参数，那么即使传递一个数组进去也可以

如此，对于上面提到的求和方法可以定义如下：

```java
public class MehtonDemo {
    public static int getSum(int... args) {
        int sum = 0;
        for (int i = 0; i < args.length; i++) {
            sum += args[i];
        }
        return sum;
    }
}
```

### 5.3 方法的重载

在同一个类中，方法名相同，参数列表不同的方法就构成重载。重载与返回值无关。

参数列表不同：个数/类型/顺序不同，JVM通过参数的不同来区分调用的是哪个方法。顺序不同虽然可以构成重载，但是不建议这么做。

### 5.4 方法的内存

方法被调用后就会进栈执行，执行完成后出栈，丢弃方法作用域中的所有数据。

#### 方法调用的基本内存原理

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/23/823caa81431e9e530c45a0cb8c2a1554-image-20251223165127297.png" alt="image-20251223165127297" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

以上代码执行顺序：

1. main方法先入栈开始执行；
2. main方法中执行eat方法，于是eat方法入栈开始执行；
3. eat方法中执行study方法，于是study方法入栈开始执行；
4. study方法打印“学习”，方法执行结束，方法出栈，栈帧回到eat方法继续执行后续代码；
5. eat方法打印“吃饭”，开始执行sleep方法，于是sleep方法入栈；
6. sleep方法打印“睡觉”，方法执行结束，方法出栈，栈帧回到eat方法继续执行后续代码；
7. eat方法执行完毕，eat方法出栈，栈帧回到main方法继续执行后续代码；
8. main方法执行完毕，main方法出栈，程序运行结束。

#### 方法传递基本数据类型的内存原理

基本数据类型和引用数据类型：

![image-20251223170035726](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/f802314367767184c6fe12be4f1887d6-image-20251223170035726.png)

![image-20251223170131056](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/89288b433e5b0350b2ee98123ac42462-image-20251223170131056.png)

<div style="clear: both;"></div>

* 基本数据类型：数据存储在自己的空间中，赋值给其他变量，也是赋的真实值。
* 引用数据类型：数据值是存储在其他空间中，自己空间中存储的是地址值。赋值给其他变量，赋的也是地址值。

演示代码：

```java
public class MethodDemo {
    public static void main(String[] args) {
        int number = 100;
        System.out.println("调用change方法前：" + number); // 100
        change(number);
        System.out.println("调用change方法后：" + number); // 100
    }
    public static void change(int number) {
        number = 200;
    }
}
```

#### 方法传递引用数据类型的内存原理

演示代码：

```java
public class MethodDemo {
    public static void main(String[] args) {
        int[] nums = { 10, 20, 30 };
        System.out.println("调用change方法前：" + nums[1]); // 20
        change(nums);
        System.out.println("调用change方法后：" + nums[1]); // 200
    }
    
    public static void change(int[] arr) {
        arr[1] = 200;
    }
}
```

> 说明：对于JavaSDK中，使用`native`关键字修饰的方法是没有方法体的，因为它是调用其他语言来实现的。

## 6、面向对象

面向对象思想（Object Oriented）是一种以对象为核心的程序设计范式，其核心要素包括对象封装、类划分、继承机制及消息传递机制，要求程序系统直接映射现实世界的问题域结构。

具体操作思维是将现实世界中存在的事务归类(`class`)，并将其各项特点作为属性(`field`)抽象出来，然后根据属性的取值特点类赋予不同的值。例如，人可以归为一个大类，他有年龄、喜好、性别等属性，每个具体的人就是一个对象，每个对象各个属性值的差别就是代表了不同的人。

面向对象方法论逐步成为软件开发主流范式，衍生出Booch方法、Coad方法、OMT方法等建模体系。1997年左右[统一建模语言（UML）](https://baike.baidu.com/item/统一建模语言/3160571?fromModule=lemma_inlink)整合了多种方法，形成标准化建模工具，应用范围从编程扩展至需求分析、系统设计等领域，推动了面向对象技术在分布式系统、人工智能等领域的广泛应用。

> 做面相对象的软件开发，至少需要能够看懂UML，否则不好编写文档，也不好看懂需求。当然，不同的公司和不同的开发团队不一定会使用UML。

### 6.1 设计对象并使用

#### 类和对象

类：是“生产”对象的设计图，是对象共同特征的描述。

对象：是真实存在的具体的东西。

在Java中，必须先设计类，才能获取相应对象。

```java
// 如何定义类：
public class ObjDemo {
    // 1、成员变脸（代表属性，一般是名词）
    // 2、成员方法（代表行为，一般是动词）
    // 3、构造器（后续章节学习）
    // 4、代码块（后续章节学习）
    // 5、内部类（后续章节学习）
    
    public static void main(String[] args) {
        // 获取对象：类名 对象名（变量名） = new 类名();
        Phone phone = new Phone();
        
        // 使用对象
        // 访问属性：对象名.成员变量
        phone.brind = "xiaomi";
        phone.price = 1999;
        System.out.println(phone.brind);
        System.out.println(phone.price);
        // 访问行为：对象名.方法名(...)
        phone.call();
        phone.playGame();
        
        // 创建多个对象同理即可
        // Phone newPhone = new Phone();
        // ……
    }
}

// 样例：创建手机类
class Phone {
    // 属性
    /** 品牌 */
    String brand;
    /** 价格 */
    double price;
    
    // 行为：
    public void call() {
        System.out.println("手机在打电话");
    }
    public void playGame() {
        System.out.println("手机在玩游戏");
    }
}
```

#### 定义类的补充注意事项

* 用来描述一类事务的类，专业叫做`JavaBean类`。在JavaBean中，是不写main方法的。（事实上，在一个项目中，程序的入口只需要一个就够了）

* 在之前编写的main方法的类，本质作用来看叫做测试类（用来运行每次演示的Demo），我们可以在测试类中创建JavaBean类的对象并进行赋值和调用。

* 类名首字母建议大写，需要见名知意，大驼峰。

* 一个Java文件中可以定义多个class类，且只能一个类是public修饰，public修饰的类名必须和文件名相同。实际开发中还是只建议一个文件中只定义一个class。

* 成员变量的完整定义格式是：`修饰符 数据类型 变量名称 = 初始化值;`，一般无需指定初始化值，存在默认值，当然，如果需要为成员（属性）赋一个优先级高于构造方法的值，也可以定义这个初始化值。

* 对象的成员变量的默认值规则：

  <table style="text-align: center; vertical-align: middle;">
    <thead style="width: 100%;">
      <tr>
        <th>数据类型</th>
        <th>明细</th>
        <th>默认值</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="3">基本类型</td>
        <td>byte、short、int、long</td>
        <td>0</td>
      </tr>
      <tr>
        <td>float、double</td>
        <td>0.0</td>
      </tr>
      <tr>
        <td>boolean</td>
        <td>false</td>
      </tr>
      <tr>
        <td>引用类型</td>
        <td>类、接口、数组、String</td>
        <td>null</td>
      </tr>
    </tbody>
  </table>

### 6.2 封装

封装是面向对象的三大特征之一（另外两个是继承和多态），它的作用在于告诉我们如何正确的设计对象的属性和方法。**对象代表什么，就得封装对应的数据，并提供数据对应的行为。**

>  案例：人画圆，需要定义两个类——人和圆，那么画圆这一方法应该定义在人这个类还是圆这个类中？
>
> 题解：由于画圆这个行为的数据来自于圆，画圆是圆这个类自我描述的行为，所以这个方法应该定义在圆这个类中。

#### 封装的作用

* 对象代表什么，就得封装对应的数据，并提供数据对应的行为（最典型的案例就是JDK自身提供的调用各种功能的类都是基于这个思想实现的）。
* 可以极大地降低学习成本，可以少学、少记，或者压根不用学，不用记对象有哪些方法，有需要时再去找就行。（命名规范中见名知意的重要作用）

#### private关键字

`private`是一个权限修饰符，可以修饰成员（成员变量和方法），被`private`修饰的成员只能在本类中访问。

一个设计好的`Person`类，如果它有一个属性为`age`，如果它的某一个对象被随意的将`age`属性设置为负数或者一个远超人类寿命限制的数，设计成这样的类被认为是不安全的，需要给每个成员（属性）的访问设计一套统一的标准。

利用`private`关键字来修饰类所有需要被定义标准的成员，然后再提供对外可访问的`public`关键字修饰的方法来对成员进行访问（和`private`一样，`public`也是一个权限修饰符，它修饰的成员变量和方法可以在对象上访问），这即是`getter/setter`方法了。

`getter/setter`方法名称有统一的命名标准，取值方法用`getXxx`，赋值方法用`setXxx`，如果是布尔型的成员，取值方法也可以是`isXxx`。

事实上，几乎所有的JavaBean（包括数据流转的类、数据库表对应的类等）在项目中，都需要遵循这个设计标准。

如此，上述的年龄设值问题就可以在`Person`类`age`属性的`setter`方法中添加判断了（这里只是举例，实际开发过程中，一般情况下，调用`setter`已经是经过所有校验的最后一步了设值保存/传入下一步继续流转处理了）。

案例：设计Person类。

```java
public class Person {
    /** 姓名 */
    private String name;
    /** 性别 */
    private char gender;
    /** 年龄 */
    private int age;
    
    // getter/setter，这里的this关键字后面再说，这里如果形参名与属性名不同则可以省略
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public char getGender() {
        return gender;
    }

    public void setGender(char gender) {
        this.gender = gender;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

:::info Tips

① 一些序列化框架是通过`gettter/setter`方法来获取属性的（例如Alibaba Fastjson）。

② 项目中可以考虑引用`lombok`组件来省略代码中的`getter/setter`方法（组件会根据组件中的注解会在编译的时候自动生成）。

```java
import lombok.Getter;
import lombok.Setter;

/**
 * 类描述：面向对象Demo：人类设计
 *
 * @author Triabin
 * @date 2020-12-24 14:28:20
 */
@Getter
@Setter
public class Person {
    /**
     * 姓名
     */
    private String name;
    
    /**
     * 性别
     */
    private char gender;
    
    /**
     * 年龄
     */
    private int age;
}
```

③ 如果求稳且项目组中有成员使用了不适配`lombok`的代码编辑器（Eclipse、vscode等），也可以使用JetBrains IDEA的自动生成功能。

* 设计好成员变量后，在文件中任意地方右键单击呼出弹窗，在弹窗中选择`Generate`，也可以使用快捷键`Alt + Insert`。(macOS为`Command + N`)

  <img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/24/89b2e6b97704e500362c8c4808918f24-image-20251224143930007.png" alt="image-20251224143930007" style="zoom:80%;" align="left" />

  <div style="clear: both;"></div>

* 然后在弹窗中选择`Getter and Setter`（左），再在之后的弹窗（右）中选中类的所有字段（聚焦到类上面后，`Ctrl + A`，或者选中第一个字段后按住`Shift`再点击最后一个字段，或者按住`Ctrl`键，然后一个一个的用鼠标点），选中后回车/点击OK。（macOS则将`Ctrl`键换成`Command`键即可）

  <img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/24/282560d545063b3ac1d05ea90de64cd2-image-20251224144408102.png" alt="image-20251224144408102" align="left"/>

  <div style="clear: both;"></div>

  > 关于Setter template，如果选择Builder，那么生成的`setter`方法会返回对象本身`return this;`，这样做的作用是可以让你链式调用，例如前文中的Person类，如果设置的是Builder模板，那么赋值可以这样：`person.setName("张三").setGender('M').setAge('20');`。当然，实际开发时为了方便修改和代码可读性，可能会换行：
  > ```java
  > public class Demo {
  >     public static void main(String[] args) {
  >         Person person = new Person()
  >             .setName("张三")
  >             .setGender('M')
  >             .setAge('20');
  >     }
  > }
  > ```

:::

### 6.3 this关键字

成员变量与局部变量

上一节Person类设计案例中说，如果Setter方法形参名与属性名不同则this关键字可以省略。其实如果相同且省略this关键字，则会导致Setter方法无法给属性赋值，这牵涉到了成员变量与局部变量的概念。

在类中，如果把变量定义在方法中，则该变量为（该方法的）局部变量，定义在类中，则该变量为（该类的）成员变量。

```java
public class ThisDemo {
    public static void main(String[] args) {
        method(); // 30
    }
    
    private int age;
    public void method() {
        int age = 30;
        System.out.println(age);
    }
}
```

就近原则：上述代码中，最终打印结果为30，因为局部变量的age离打印语句更近，所以最终打印结果为局部变量的值，如果想要使用成员中的age，就可以在age前面添加`this.`，这个this就表示当前类（对象）。这就是就近原则。

如此就可以解释上一节Person类中如果Setter方法形参名与成员变量名相同且省略this关键字导致Setter方法无法给属性赋值的原因了，在这种情况下，Setter方法中的属性名用的是离自己较近的形参，语句作用为形参将自己的值赋值给自己，压根没有访问到成员变量，所以也就无法给对象属性赋值。

> 在类的设计过程中，只要涉及到访问对象自身属性的情况下，不管局部变量中有没有同名的变量，最好都在前面添加`this.`，因为你不确定哪一天可能就会因为bug修改或者特性添加或者业务逻辑变更等各种原因在这个方法中添加同名的局部变量，一方面能避免多处修改，另一方面是**人的记忆是最不靠谱的**，这样设计可以避免因为忘记修改或者别人修改你的代码时没注意成员变量与局部变量的冲突导致的谬误。

### 6.4 构造方法

构造方法也叫作构造器、构造函数，用于在创建对象的时候给成员变量初始化。

```java
// 构造方法格式
public class StructorDemo {
    修饰符 类名(参数列表) {
        方法体;
    }
}
```

特点：

* 方法名与类名相同
* 没有返回值类型，连void都没有
* 没有具体的返回值（不能由return带回结果数据）

执行时机：

* 创建对象的时候**由JVM调用**，不能手动调用构造方法；
* 每创建一次对象，就调用一次构造方法。

一般样例（以前面的Person类为例）：
```java
/**
 * 类描述：面向对象Demo：人类设计
 *
 * @author Triabin
 * @date 2020-12-24 14:28:20
 */
public class Person {
    /**
     * 姓名
     */
    private String name;

    /**
     * 性别
     */
    private char gender;

    /**
     * 年龄
     */
    private int age;

    /**
     * 空参构造
     */
    public Person() {}

    /**
     * 全参构造
     * @param name 姓名
     * @param gender 性别，M男，F女
     * @param age 年龄
     */
    public Person(String name, char gender, int age) {
        this.name = name;
        this.gender = gender;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public Person setName(String name) {
        this.name = name;
        return this;
    }

    public char getGender() {
        return gender;
    }

    public Person setGender(char gender) {
        this.gender = gender;
        return this;
    }

    public int getAge() {
        return age;
    }

    public Person setAge(int age) {
        this.age = age;
        return this;
    }
}
```

构造方法注意事项：

* 构造方法的定义：如果没有写构造方法的情况下，JVM会默认创建一个无参构造方法；如果定义了构造方法，系统将不再提供默认的构造方法。
* 构造方法的重载：带参构造方法，和无参构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载。
* 推荐的使用方式：无论是否使用，都手动书写无参和全参的构造方法。

:::info Tips

与之前所述的利用IDEA生成`getter/setter`方法的相同，也可以通过`Alt + Insert`（macOS为`Command + N`），进入`Generate`选项菜单，选择生成构造方法，并且具体要初始化哪些参数也直接可选，亦或者使用`lombok`组件的`@AllArgsConstructor`与`@NoArgsConstructor`注解生成全参构造与无参构造方法。

:::

### 6.5 标准JavaBean

① 类名要见名知意

② 成员变量使用`private`修饰

③ 提供至少两个构造方法，即无参构造方法和全参构造方法

④ 成员方法：提供每一个成员变量对应的`getter/setter`方法，如果还有其他行为，也需要写上。

### 6.6 对象内存图

![JDK7（左）JDK8（右）](https://gitee.com/triabin/img_bed/raw/master/2025/12/23/c6109c41f1da02b7aee8efcf37f7b8f9-image-20251223145053004.png)

<div style="clear: both;"></div>

回顾：Java代码运行时，先将字节码文件(`.class`)加载进入方法区（元空间）这块内存，然后在栈内存中运行字节码文件中的方法，方法中定义的变量也是存在栈内存中，占内存中的方法运行过程中new出来的内容都会在堆内存中开辟一块内存区域，并产生内存区域相对应的地址。

#### 一个对象的内存图

`Student s = new Student();`：

1. 加载字节码文件（加载`Student.class`到方法区）
2. 声明局部变量（在栈内存中声明局部变量`s`）
3. 在堆内存中开辟一块内存空间（`new Student()`的过程）
4. 默认初始化（`Student`类成员变量对应数据类型的默认值）
5. 显式初始化（定义`Student`类时给成员变量的字面量初始化值）
6. 构造方法初始化（调用`Student`构造函数时，函数中给成员变量的初始化值）
7. 将堆内存中开辟空间的地址值赋值给左边声明的局部变量

图解：

![image-20251225142956508](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/58cf27c291d5d8a725dc66c1df14e049-image-20251225142956508.png)

<div style="clear: both;"></div>

* 上图左边的代码运行时，首先会将`TestStudent.class`加载到方法区，开始执行后将`main`方法加载到栈内存；
* 运行`main`方法第一行，需要创建`Student`对象，于是将`Student.class`加载到方法区；
* 开始创建`Student`对象，现在`main`方法中创建一个局部变量`s`，然后开始在堆内存中开辟一块内存空间（假设内存地址为`001`），根据方法区加载的`Student.class`内容创建对象；
* 先开始对`Student`对象的成员变量进行默认初始化，`name`为`String`类型，默认初始化值为`null`，同理，`age`默认初始化值为`0`;
* 从左边`Student`类的代码来看，没有对成员变量进行显式初始化；（如果定义过程中显式设置了`String name = "张三"`，则会在这一步将值赋给堆内存中对象的`name`属性）
* 由于调用了空参构造器，并且`Student`类的空参构造器并没有手动指定，所以构造方法也没有再对成员变量进行覆盖初始化；
* 堆内存中的`Student`对象创建完成，将内存地址`001`赋值给栈内存中的局部变量`s`；
* 代码继续执行，此时打印`s`的值为`001`，打印`s`中`name`和`age`属性值分别为`null`和`0`；
* 通过`s`访问堆内存相应的内存空间，并修改对象成员变量值后，再打印则为修改后的值；
* 此时再通过`s`调用其中的`study`方法，通过堆内存中记录的方法地址，将方法区中的方法加载到栈空间中，运行方法；
* `study`运行完成后，出栈；
* `main`方法也运行完成，出栈；
* 此时堆内存中地址为`001`区域的对象已无变量指向自己，将在垃圾回收时被回收掉这块内存。

以上就是一个对象在方法运行中创建到销毁（内存释放）的全过程，如果是同一个类的多个对象，也同理，唯一的区别就是**当第二次创建同一个类的对象时，不需要再重新加载字节码文件到方法区**。并且，每次建对象开辟的内存空间之间是相互独立，互不影响的。

#### 两个变量指向同一个对象的内存图

![image-20251225145419891](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/60c23ed540d30dc3f2da47722f6d267c-image-20251225145419891.png)

<div style="clear: both;"></div>

如图，在洞悉了局部变量与堆内存中开辟的内存空间之间的关系之后，多个局部变量指向同一块内存区域的情况就很好理解了，当多个变量指向同一个对象时，只要有其中任何一个变量访问并修改了对象的属性，则所有变量获取到的都是修改后的对象，因为大家（所有变量）记录的都是同一个内存地址值。

将变量的值设为`null`以后，则是掐断了其与堆内存中对象所在内存空间的联系，它将无法访问该对象，当所有的变量都不指向该内存区域时，该内存区域将变成垃圾，然后被GC回收。

#### 基本数据类型和引用数据类型的区别

前文 [1.5  数据类型](#1.5- 数据类型)中对基本数据类型做了介绍，引用数据类型则是只简单归类为除基本数据类型之外的其他。现在结合前两节对与对象的内存图可以从内存的角度对基本数据类型和引用数据类型做一个更加详细解释：

* 基本数据类型数据的值是存储在自己的空间中的，赋值给其他变量赋的是真实的值（例如直接将内存中的补码赋给另一个变量）；
* 引用数据类型数据值则是存储在其他空间中或者空间中的其他内存位置，自己空间中存储的是地址值，赋值给其他变量赋的是地址值（注意这里存储地址值变量的空间并不单单指栈空间，堆空间中的对象成员变量也会存储其他引用数据的地址值）。

#### this的内存原理

this本质：所在方法调用者的地址值。
![image-20251225151847436](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/deb1b64c7ce1196745ef9247d53c2d1d-image-20251225151847436.png)

### 6.7 补充知识：成员变量、局部变量区别


|      区别      |                  成员变量                  |                    局部变量                    |
| :------------: | :----------------------------------------: | :--------------------------------------------: |
| 类中的位置不同 |                类中、方法外                |           方法内、方法声明上（形参）           |
|  初始化值不同  |               有默认初始化值               |           没有，使用之前需要完成赋值           |
|  内存位置不同  |                   堆内存                   |                     栈内存                     |
|  生命周期不同  | 随着对象的创建而存在，随着对象的消失而消失 | 随着方法的调用而存在，随着方法的运行结束而消失 |
|     作用域     |                整个类中有效                |                 当前方法中有效                 |

### 6.8 static

`static`：表示静态，是Java中的一个修饰符，可以修饰成员方法也可以修饰成员变量。被`static`修饰的成员变量叫做静态变量，同理，被修饰的方法叫做静态方法。

#### 静态变量

特点：

* 变量被该类所有对象共享
* 随着类的加载而加载，是优先于对象出现的（类字节码文件加载到方法区的时候它就出现了，此时还没创建对象）

调用方式：

* 类名调用（推荐）：`类名.变量名`
* 对象调用：`对象变量名.变量名`

静态变量内存图：

<img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/28/85f4434fd3de2366602551d2b42ad5cd-image-20251228134033472.png" alt="image-20251228134033472"/>
<div style="clear: both;"></div>

运行过程简述：

* `main`方法第一行，将`Student.class`加载到方法区，发现该类有静态成员变量，于是将静态成员加载到堆内存的**静态区**，并且将其赋一个对应数据类型的默认值；

  静态区：静态存储位置，在JDK8以前，这个分区存放在方法区，JDK8开始将其挪到了堆内存中。

* 将“阿玮老师”赋给静态变量`teacherName`；

* 内存中开辟一块空间存放`Student`对象，给成员变量赋默认初始值；

* 分别给成员变量赋值；

* 调用`show()`方法，方法入栈，然后通过对象访问到静态成员变量和类成员变量打印到控制台，方法运行结束，出栈；

* `Student = s2`类似。

#### 静态方法和工具类

特点：

* 多用在测试类和工具类中
* JavaBean中很少使用（就算用到，也多涉及到一些设计模式，例如单例）

调用方式：

* 类名调用（推荐）：`类名.方法名`（类外部，内部可以直接调用，不用类名）
* 对象调用：`对象变量名.方法名`

工具类：帮助我们做一些事情（最好是能归为一类的那种），但是不描述任何事物（对象）的类。

工具类与其他类对比：

* JavaBean类：用来描述一类事物的类，比如，`Teacher`、`Student`、`Dog`，`Cat`等。
* 测试类：用来检验其他类是否书写正确，带有程序入口的类。
* 工具类：不是用来描述一类事物的，而是帮我们做一些事（里面多是一些静态方法，用于实现具体的功能）。

工具类要遵守的规则：

* 类名见名知意，例如数组工具类叫`ArrayUtil`（这里只是举例，实际上JDK提供的数组工具类叫做`Arrays`），数学工具就叫`MathUtil`；
* 私有化构造方法，防止外界创建这个类的对象，因为工具类不是用来描述事物的，创建它的对象没有意义，只需要类名来调用工具方法就行了；
* 方法都定义为静态的，方便调用（否则私有化了构造方法的类无法调用成员方法）。

#### `static`的注意事项

* 静态方法只能访问静态变量和静态方法（否则加载到静态区的时候其他内容都还没加载出来，无法访问）；
* 非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法（也是和加载顺序相关）；
* 静态方法中没有`this`关键字。

总结：静态方法中只能访问静态；非静态方法可以访问所有。静态方法中没有`this`关键字。

静态成员变量随着类的加载而加载到静态区，此时的普通成员变量和成员方法因为不一定有调用者（创建的类对象），所以无法调用，但是静态成员变量已经加载到静态区，静态方法因为不需要`this`作为调用者，所以也可以直接调用。

重新认识`main`方法：

* public：被JVM调用，权限够大
* static：被JVM调用，不用创建对象，直接访问类名（因为main方法是静态的，如果以main方法作为入口的测试类，那么测试类中其他方法也需要是静态的）
* void：被JVM调用，不需要给JVM返回值
* main：一个通用的名称，虽然不是关键字，但是能被JVM识别，是Java规定的主入口名称
* `String[] args`：用于接收键盘录入的数据，现在几乎不用（编译后的结果在命令行调用的时候后面跟的参数列表）

### 6.9 继承

继承是面向对象的三大特征之一，之前已经学过了封装，在将事物零散的属性和行为封装到一起成为一个对象的过程中，出现了许多属性高度重合的类。

例如`Student`（学生）和`Teacher`（老师）两个类都有诸如姓名、年龄、性别、住址等相同的属性以及吃饭睡觉等相同的方法，为了解决这个问题，于是将这些重合的属性和方法写到了第三个类中，给这个类取名为`Person`。学生和老师两个类只需要去**继承**这个类即可获取到这些共有的属性和方法，再根据自身特添加一些独属于自己的属性和方法（或者重写父类方法）即可。

* Java中提供一个关键字`extends`，用这个关键字就可以让一个类和另一个类建立起继承关系。

  `public class Student extends Person {}`

* 上述案例中，`Student`称为子类（派生类），`Person`称为父类（基类或超类）。

#### 继承继承的好处

* 可以把多个子类中重复的代码抽取到父类中，提高了代码的复用性。
* 子类可以在父类的基础上，增加其他功能，使子类更强大。

继承要学习的点：自己设计父类，使用别人设计好的类。

**自己设计继承**：当类与类之间存在相同的内容，并满足子类时父类中的一种，就可以考虑使用继承来优化代码。

#### 继承的特点

Java只支持单继承，不支持多继承，但支持多层继承：

* 单继承：一个子类只能继承一个父类

* 不支持多继承：子类不能同时继承多个父类

* 多层继承：子类A继承父类B，父类B可以继承父类C，其中，C是A的间接父类，B是A的直接父类，C是B的直接父类

  > 在Java中，每一个类都直接或间接的继承于`java.lang.Object`类（万物皆对象，所以给最大基类命名为Object）。如果在定义类的时候，没有明确使用`extends`关键字指定父类，那么JVM会自动默认给类加上一个父类`Object`。

#### 子类能继承父类中的哪些内容

| 父类中的内容 |  非私有  | 私有`private` |
| :----------: | :------: | :-----------: |
|   构造方法   | 不能继承 |   不能继承    |
|   成员变量   |  能继承  |    能继承     |
|   成员方法   |  能继承  |   不能继承    |

① 构造方法如果可以被继承会将会导致构造方法的命名规则，即构造方法名与类名相同。

```java
public class ExtendsDemo {
    public static void main(String[] args) {
        Son son1 = new Son();
        Son son2 = new Son("张三", 18); // 报错
    }
}
    
class Parent {
    private String name;
    private int age;

    public Parent() {}
    public Parent(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Son extends Parent {}
```

② 私有的成员变量虽然可以被继承下来，但是不能直接使用，只能通过`public`的`getter/setter`方法访问属性。继承的内存图：

![image-20251228151814410](https://gitee.com/triabin/img_bed/raw/master/2025/12/28/1aabdd22e90e31619b6eadb04da62456-image-20251228151814410.png)
<div style="clear: both;"></div>

运行时内存分析：

* 首先加载`TestStudent.class`到方法区，然后`main`方法进栈，开始运行；
* 第一行发现要使用`Zi`类，于是将`Zi.class`加载到方法区，加载过程发现它集成了`Fu`类，于是将`Fu.class`也加载到方法区；
* 第一行等号左边，在栈中定义了一个类型为`Zi`的`main`方法局部变量`z`；
* 第一行等号右边，在堆空间中开辟一块内存区域，地址为`001`（假设），内存氛围两块（逻辑上），一块存放`Fu`类的成员变量，一块存放`Zi`类的成员，然后分别进行默认初始化，然后将内存地址赋值给左边的局部变量`z`，然后继续执行下一行；
* 打印出内存地址`001`，继续执行下一行；
* 三行都是赋值语句，不同的是每次赋值，都会现在`Zi`类的那块内存中找成员变量，找不到才会去父类中找，三行依次赋值后继续执行下一行；
* 打印完成，`main`方法运行完毕，方法出栈。

在该过程中，如果`Fu`类中，将成员变量都用`private`修饰，那么在子类中赋值时，将无法直接访问，除非父类提供可被子类继承的`public`的`getter/setter`供子类访问相应成员变量。

③ **虚方法表**：对于方法的继承，如果每次调用父类方法都需要逐级往父类中去查找的话，那么那些继承关系比较复杂的类将会大大降低Java代码的执行效率，于是Java在底层做了一些优化，它会从最顶级的父类开始，设置一个虚方法表，将这个类中可能会经常用到的方法（非`private`、非`static`、非`final`）单独抽离出来，每次继承，父类都会将虚方法表交给子类，然后子类会再将自己的常用方法加入到这个虚方法表中，如此就避免了每次调用父类方法时的逐级查找（同时也方便方法重写）。**只有父类中的虚方法才能被子类继承。**内存图演示：

![image-20251228154537300](https://gitee.com/triabin/img_bed/raw/master/2025/12/28/52194bc6dbea119ec26220084bcf36d1-image-20251228154537300.png)
<div style="clear: both;"></div>

运行过程内存分析：

* 首先加载字节码文件`TestStudent.class`，然后`main`方法入栈开始执行；
* 第一行，需要加载`Zi.class`，由于`Zi`类继承了`Fu`类，于是加载`Fu.class`，由于`Fu`类继承了`java.lang.Object`类（以前的内存分析由于不涉及到它的内容，为了简化分析，于是略过了这一步），于是加载`Object.class`到方法区。加载完成，首先在栈中定义变量`z`，然后开始在堆空间开辟内存区间，内存区域间在逻辑上分为两块，但是由于父类和子类都没有成员变量，所以只开辟，不需要默认初始化赋值，然后将开辟出来的内存地址返回给`z`；
* 第二行，打印出内存地址`001`；
* 第三行，调用`ziShow()`方法，先去`Zi`类的虚方法表中查找该方法，没找到再去查找自己的成员方法，还找不到就逐级向上查找，找到了直接运行；
* 第四行，调用`fuShow1()`方法，先去`Zi`类的虚方法表中查找该方法，找到了直接运行；
* 第五行，调用`fuShwo2()`方法，先去`Zi`类的虚方法表中查找该方法，没找到，再去查找自己的成员方法，也没找到，于是去`Fu`类中查找成员方法，找到了发现是`private`的方法，于是报错，栈帧弹出。

#### 继承中成员变量的访问特点

就近原则：谁离我近，我就用谁。当前方法作用域内找，找不到就去成员变量里面找，成员变量找不到再去父类找。

```java
public class ExtendsDemo {
    public static void main(String[] args) {
        Son son = new Son();
        son.show(); // Show Son Parents
    }
}

class Parent {
    String name = "Parents";
}

class Son {
    String name = "Son";
    public void show() {
        String name = "Show"
        System.out.println(name); // 访问离我近的
        System.out.println(this.name); // 访问本类
        System.out.println(super.name); // 访问父类
    }
}
```

#### 继承中成员方法的访问特点

直接调用满足就近原则，谁离我近我就用谁，`super`调用，访问父类。

调用方法过程：现在本类中查看，有无此方法，没有则去父类中查找。但是如果子类重写了父类方法，那么在子类的虚方法表中的该方法名对应的方法为子类重写后的方法。

```java
public class ExtendsDemo {
    public static void main(String[] args) {
        Student s1 = new Student();
        s1.lunch();
        
        InternationalStudent s2 = new InternationalStudent();
        s2.lunch();
    }
}

class Person {
    public void eat() {
        System.out.println("吃米饭");
    }
    public void drink() {
        System.out.println("喝开水");
    }
}

class Student extends Person {
    public void lunch() {
        this.eat();
        this.drink();
        
        super.eat();
        super.drink();
    }
}

class InternationalStudent {
    public void lunch() {
        this.eat();
        this.drink();
        
        super.eat();
        super.drink();
    }
    
    @Override
    public void eat() {
        System.out.println("吃面包");
    }
    
    @Override
    public void drink() {
        System.out.println("喝凉水");
    }
}
```

方法的重写：当父类（做同一件事情的）的方法不能满足子类需求时，需要进行方法重写。

* 书写格式：在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。
* `@Override`重写注解：用于放在重写后的方法上，校验子类重写时语法是否正确。（关于注解的知识以后再详述）
* 在添加虚方法表过程中，如果发生了方法重写，那么子类的方法会覆盖父类的方法。

方法重写注意事项和要求：

* 重写的方法名称、参数列表必须与父类保持一致；
* 子类在重写父类方法时，访问权限子类必须大于等于父类（暂时了解：`private < default（空着不写） < protected < public`；
* 子类重写父类方法是，返回值类型必须小于等于父类；
* 建议：重写方法时，方法尽量与父类保持一致（访问权限、参数列表、返回值类型等，绝大部分场景都是一致的）；
* 私有方法不能被重写；
* 子类不能重写父类的静态方法，重写将会报错。**只有被添加到虚方法表中的方法才能被重写。** 方法重写本质就是覆盖虚方法表中的方法，因此那些不能被添加到虚方法表中的方法都无法被重写。

#### 继承中构造方法的特点

* 父类中的构造方法不会被子类继承；

* 子类中所有构造方法默认先访问父类中的无参构造，再执行自己。

  ```java
  public class ExtendsDemo {
      public static void main(String[] args) {
          Child child = new Child("Triabin");
          System.out.println(child); // Child{name='Triabin', age=18}，toString()方法为java.lang.Object中的方法，因此每个类其实都有该方法，打印到控制台时，引用对象打印的其实都是该方法的返回值
      }
  }
  
  class Parent {
      String name;
      int age;
  
      public Parent() {
          this.age = 18;
      }
  }
  
  class Child extends Parent {
      public Child(String name) {
          this.name = name;
      }
  
      @Override
      public String toString() {
          return String.format("Child{name='%s', age=%d}", name, age);
      }
  }
  ```

  原因：子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据，因此子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。

  调用方式：子类构造方法的第一行语句默认都是`super();`，即使不写也存在，并且必须在第一行。（如果调用父类的有参构造则必须手动调用`super(参数列表);`）

#### this、super使用总结

* `this`：可以理解为一个变量，表示当前方法调用者的地址值；从虚拟机打印的对象中方法的内存信息来看，它就是一个存在每个对象方法中的局部变量，当方法被调用的时候它才有值。
* `super`：代表父类存储空间。

| 关键字  |              访问成员变量              |                访问成员方法                 |                         访问构造方法                         |
| :-----: | :------------------------------------: | :-----------------------------------------: | :----------------------------------------------------------: |
| `this`  | `this.成员变量`<br />访问本类成员变量  | `this.成员方法(...)`<br />访问本类成员方法  | `this(...)`<br />访问本类构造方法，如果是在构造方法中，这个语句必须写在第一行 |
| `super` | `super.成员变量`<br />访问父类成员变量 | `super.成员方法(...)`<br />访问父类成员方法 |              `super(...)`<br />访问父类构造方法              |

### 6.10 多态

多态是面向对象的三大特征之一，前面已经依次介绍了封装和继承。在继承的使用过程中，出现了一种使用情况，假如在设计一个学生管理系统时，将所有用户重复的属性放在`User`类中，然后分别继承出`Administrator`类，`Teacher`类和`Student`类，然后再设计一个注册接口的方法，为了设计这个方法，就需要重写出`register(Administrator admin)`、`register(Teacher teacher)`和`register(Student student)`三个方法，这样的场景又造成了代码逻辑的重复，调用起来也很不方便，于是设计了多态来解决这样的问题。

在创建对象时，可以将子类对象赋值给父类，例如`User user = new Student()`，这样**同类型的对象，表现出的不同形态，即为多态**。可以看出，继承是多态的前提条件，没有继承，就没有多态。根据多态的特性，上述问题中的注册方法可以写成`register(User user)`，这样就可以接收所有继承自`User`类的对象了，并且根据各个子类中方法实现的逻辑不同，调用同一个方法时，其运行逻辑也可以不同。

#### 多态的基本使用

多态的表现形式：`父类类型 变量名 = 子类对象;`

多态的前提：
* 有继承/实现关系（实现关系到后面的接口章节再介绍）
* 有父类引用指向子类对象
* 有方法重写

多态的好处：使用父类作为参数，可以接收所有子类对象，体现多态的扩展性与便利。

代码演示：

```java
public class PolymorphismDemo {
    public static void main(String[] args) {
        User student = new Administrator();
        User teacher = new Teacher();
        User admin = new Student();

        register(admin); // Administrator
        register(teacher); // Teacher
        register(student); // Student
    }

    public static void register(User user) {
        user.show();
    }
}

class User {
    public void show() {
        System.out.println("User");
    }
}

class Administrator extends User {
    @Override
    public void show() {
        System.out.println("Administrator");
    }
}

class Teacher extends User {
    @Override
    public void show() {
        System.out.println("Teacher");
    }
}

class Student extends User {
    @Override
    public void show() {
        System.out.println("Student");
    }
}
```

#### 多态调用成员的特点

* 变量调用：编译看左边，运行也看左边

* 方法调用：编译看左边，运行看右边

代码演示：

```java
public class PolymorphismDemo {
    public static void main(String[] args) {
        Animal animal = new Cat();
        Cat cat = new Cat();

        // 编译代码的时候，会看左边的父类中有没有这个变量，如果有就编译成功，没有就编译失败，运行的时候也看左边，实际获取的就是左边父类中的成员变量的值
        System.out.println(animal.name); // 动物
        System.out.println(cat.name); // 猫

        // 编译的时候，会看左边的父类中有没有这个方法，如果有就编译成功，没有就编译失败，运行的时候实际运行的是子类中的方法
        animal.show(); // Animal --- show方法
        cat.show(); // Cat --- show方法
    }
}

class Animal {
    String name = "动物";

    public void show() {
        System.out.println("Animal --- show方法");
    }
}

class Dog extends Animal {
    String name = "狗";

    @Override
    public void show() {
        System.out.println("Dog --- show方法");
    }
}

class Cat extends Animal {
    String name = "猫";

    @Override
    public void show() {
        System.out.println("Cat --- show方法");
    }
}
```

多态调用成员内存图解：

![image-20251230160445552](https://gitee.com/triabin/img_bed/raw/master/2025/12/30/f2fdfad65a6cf856297f7c46bcaf6fce-image-20251230160445552.png)
<div style="clear: both;"></div>

执行步骤解析：

* 首先加载`Test.class`到方法区，然后`main`方法入栈开始执行；
* 第一行，先加载字节码文件，涉及到继承关系，都是先加载父类再加载子类，所以这一行加载顺序为`Object.class -> Animal.class -> Dog.class`，加载完毕后在栈内存中定义一个类型为`Animal`的变量`a`，然后在堆内存中开辟一块内存区间来存储`Dog`对象，这块内存区间分为两个区间（逻辑上），一个存储父类成员变量，一个存储子类成员变量，给所有成员变量初始化完成后继续执行下一部；
* 第二行，调用成员变量，先去父类中找成员变量`name`，找到了后打印到控制台，然后继续执行下一步（当然，如果父类中没有这个成员变量，直接编译都无法通过，这就是编译看左边，运行也看左边）；
* 第三行，调用成员方法，直接在需方发表中找到了`show()`方法，直接入栈运行即可（因为此时子类中的`show()`方法已经在加载字节码文件的时候就被子类`Dog`中的`show()`方法覆盖了，所以运行的是子类中的`show()`方法，这就是运行看右边）；
* 运行完毕，`main`方法出栈。

看着整个运行逻辑有点复杂，其实总结下来就是为了确保多态使用过程中，不会调用到不存在的成员变量（所以要求成员变脸必须是父类中存在的）以及能够调用到真正要运行（子类中）的方法。只要明确了这个目的，整个加载调用过程的设计也就能够理解了。

#### 多态的优势和弊端

优势：
* 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。例如，`Person p = new Student(); p.work(); ...`，在代码中，如果后续不想学生工作了，想要换老师工作，只需要将第一行改成`Person p = new Teacher();`即可，后续的代码不用变更。
* 定义方法的时候，使用父类作为参数，可以接收所有子类对象。

弊端：在执行子类特有方法时，无法调用子类的特有功能。解决方案：这种问题在设计方法的时候就需要考虑到，如果确实有需求，可以使用`instanceof`来判断类型从属关系然后进行强转再调用，`instanceof`关键字的使用格式`变量名 instanceof 类名`，返回结果为布尔类型，代码演示：

```java
public class PolymorphismDemo {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        test(a1);
        test(a2);
    }

    public static void test(Animal animal) {
        animal.eat();

        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.watchDog();
        }
        if (animal instanceof Cat cat) { // JDK14加入的新特性，将判断和强转合到一起
            cat.mouseKiller();
        }
    }
}

class Animal {
    public void eat() {
        System.out.println("吃东西");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗啃骨头");
    }

    public void watchDog() {
        System.out.println("看家狗");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }

    public void mouseKiller() {
        System.out.println("猫抓老鼠");
    }
}
```

如果不先判断类型就直接强转（例如将狗转成猫），可能会出现类型转换异常`ClassCastException`。

### 6.11 包、final、权限修饰符、代码块

#### 包

包就是文件夹，用来管理各种不同功能的Java类，方便后期代码维护。包名使用`package`关键字声明在一个Java文件的第一行。

包的命名规则：公司域名反写+包的作用，需要全部英文小写，见名知意。例如`com.microsoft.office.word`、`com.microsoft.office.powerpoint`、`com.microsoft.office.excel`。

在使用一个类的时候，真正的使用方式，其实是将其包名加类名才对，这种`包名.类名`的形式叫做类的**全类名**（也叫做全限定名，只不过一般不用，至少口语上不用）。平时在编写代码时，因为使用了导入语句将类导入，所以避免了在每一个使用类的地方都写上全类名，当类名冲突的时候，就可以通过给其中一个类使用的地方加上全类名来区分。

使用其他类的规则：

* 使用同一包中的类时，不需要导包（默认到本包中找）
* 使用`java.lang`包中的类时，不需要导包
* 其他情况都需要导包
* 如果同事使用两个包中的同名类，需要用全类名（很少碰到）

:::info Tips

在编写Java程序的时候，如果使用JetBrains IDEA，默认情况下，导入同一个包中的类如果超过5个，它就会自动改成`import com.identifier.*`，这个星号就表示导入这个包下的所有类。这种导入方式虽然省事儿，但是在项目中是及其不推荐的，首先代码编写需要的是确保使用明确声明的东西，其次这回很容易造成命名空间污染以及出现不必要的导入，因此需要避免使用`*`号导入。IDEA设置自动导包自动使用`*`同包数量：`File -> New Projects Setup -> Settings for New Projects... -> Editor -> Code Style -> Java -> Imports`，进入界面后将`Class count to use import whith '*'`和`Names count to use static import whith '*'`改为一个几乎不可能达到的数字（一般直接改为9999😅），然后保存即可。

**注意：一定要在`Settings for New Projects...`中设置，不然你重新打开一个项目又恢复默认你了，所有需要全部项目生效的设置都在这里设置一遍。**

:::

#### `final`关键字

final，翻译成中文就是`最终的`，即不可变，在Java中，`final`关键字可以修饰方法、类和变量：

* 方法：表名该方法是最终方法，不能被重写
* 类：表名该类是最终类，不能被继承
* 变量：声明常量，只能被赋值一次（注意是赋值指向值的指向不可变，对于引用数据类型，赋值的地址不可变，但是地址对应的引用数据类型自身是可变的，例如指向一个对象，那么这个指向确实不可变，但是可以调用这个对象本身的成员变量/成员方法修改自身属性）

常量：实际开发中，一般作为系统的配置信息，方便维护，提高可读性，并且常量有自己的命名规范：单词全部大写，单词之间用下划线`_`隔开。

细节：

* `final`修饰的变量是基本类型，那么变量存储的数据值不能发生改变；
* `final`修饰的变量是引用类型，那么变量存储的地址值不能发生改变，对象内部的可以改变。 

:::info 说明
**① 字符串不可变的原因：`java.lang.String`类使用了字节数组存储字符串内容，该字节数组使用了`final`关键字进行修饰：`private final byte[] value;`；**

**② 在项目中，一般会用`Constants.java`这个类定义全局常量，定义格式：`public static final 数据类型 常量名 = 常量值;`，使用：`Constants.常量名`；**

**③ 项目中的每个类中获取日志对象时，也常用`final`关键字：`private static final Logger logger = LogManager.getLogger(当前类名.class);`。**
:::

#### 权限修饰符

权限修饰符就是用来控制一个成员能够被访问的范围的，可以用来修饰成员变量、方法（包括构造方法）、内部类。

权限修饰符有四种，作用范围从小到大依次是：`private < default（空着不写，缺省/默认） < protected < public`。

|   修饰符    | 同一个类中 | 同一个包中其他类 | 不同包下的子类 | 不同包下无关类 |
| :---------: | :--------: | :--------------: | :------------: | :------------: |
|  `private`  |     ✓      |                  |                |                |
|  空着不写   |     ✓      |        ✓         |                |                |
| `protected` |     ✓      |        ✓         |       ✓        |                |
|  `public`   |     ✓      |        ✓         |       ✓        |       ✓        |

* `private`：只能自己用
* `default`：只能本包中使用
* `protected`：其他包中的子类也能用
* `public`：公共的

使用规则：实际开发中，一般只用`private`和`public`。
* 成员变量私有

* 方法公开

* <span id="6-11-权限修饰符-共性代码">特例</span>：如果方法中的代码是抽取其他方法中共性代码，这个方法一般也私有
  
  例如在类的方法中，如果有多个需要暴露到外界使用的方法都有相同的代码逻辑，那么这部分代码就称之为共性代码。共性代码一般会被抽取出来，封装成一个私有方法，供类中的其他方法调用。（因为这相当于类中方法的一部分，不希望暴露到外界被其他地方调用）

:::info Tips
在实际开发中，其实并没有那么统一的标准，大多根据项目功能开发需求和语言特性，自由发挥使用，尽量避免屎山代码的形成即可。
:::

#### 代码块

代码块：在类中，使用`{}`括起来的代码，称为代码块。

根据代码块出现的位置不同，可以将代码块分为三类，分别是出现在方法中的局部代码块、方法外类里面的构造代码块以及使用`static`关键字修饰的静态代码块。

局部代码块：写在方法中的`{}`，用于限制变量的生命周期，定义的变量只在该代码块中有效，出了代码块就释放内存。其最为本质的作用就是节约内存，秉承用完内存立马回收的思想，但是随着计算机硬件的发展，内存的成本逐步降低，现在基本不用这个技术了。

```java
public class LocalCodeBlockDemo {
    public static void main(String[] args) {
        {
            int a = 10;
            System.out.println(a);
        }
        System.out.println(a); // Cannot resolve symbol 'a'
    }
}
```

构造代码块：写在类中的`{}`下的代码片段，一般用于存放构造方法中重复的代码，执行时机为每次创建对象时，在构造方法执行之前。这个特性由于其灵活性等原因，现在已经基本不常用了。

```java
public class ConstructorCodeBlockDemo {
    private String name;
    private int age;

    // 构造代码块
    {
        System.out.println("这是构造代码块");
    }
    public ConstructorCodeBlockDemo() {
        System.out.println("这是无参构造方法");
    }
    public ConstructorCodeBlockDemo(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("这是有参构造方法");
    }
}
```

静态代码块：使用`static`关键字修饰的代码块（格式：`static { ... }`），一般用于初始化静态变量，随着类的加载而加载，并且自动触发，**只执行一次**。这个特性在项目中的应用十分广泛，例如在项目中，我们可以使用静态代码块来初始化数据库连接池、加载配置文件等。

```java
public class StaticCodeBlockDemo {
    public static void main(String[] args) {
        System.out.println(StaticCodeBlock.count);
    }
}

class StaticCodeBlock {
    // 静态变量
    private static int count = 0;

    // 静态代码块
    static {
        System.out.println("这是静态代码块");
        count = 100;
    }
}
```

“只执行一次”是静态代码块的重要特性，也是某些数据的的初始化不能写在`main`方法中的原因（因为只要是方法，就有被重复调用的可能，包括`main`方法）。

### 6.12 抽象类和抽象方法

在之前的面相对象三大特征中，我们首先提出了继承来解决代码重复的问题，继承算是解决了属性复用的问题，但是方法复用过程中又出现了新的问题，即父类中的方法不能满足所有子类需求，于是又设计了方法重写的概念，但是方法重写只是一种软性的规定，即在使用过程中即使不重写方法也不会报错，加之前面说的父类方法不能穷尽子类方法需求的问题，于是引入了抽象的概念。

> 说明：抽象也算是面向对象的特性

可以说，类是对事物的抽象，抽象类则是对类的抽象，对类行为（方法）的规定。

抽象方法：将**共性的**行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的（该行为在每个子类中必须要有），父类中不能确定具体的方法体，该方法就可以定义为抽象方法。
* 定义格式：`public abstract 返回值类型 方法名(参数列表);`，没有方法体，方法权限修饰符要确保在子类中能继承到该方法（不能是`private`）

抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类。
* 定义格式：`public abstract class 类名 { ... }`，抽象类中可以包含抽象方法和非抽象方法。

抽象里和抽象方法的注意事项：
* 抽象类不能实例化（不能创建对象），只能被继承。
* 抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类。
* 可以有构造方法（给子类调用）。
* 抽象类的子类要么重写抽象类中的所有抽象方法，要么声明为抽象类。

抽象类和抽象方法的意义：在多人协作的项目中，对类的行为（包括方法名）进行统一强制规定，避免了多人协作过程中忘记实现某种行为的情况以及对同一行为的方法命名迥异的情况。

### 6.13 接口

在有了面向对象的三大特征以及抽象的概念后，实际使用过程中出现了一种情况，就是在规定的诸多类中，有许多**不同的**类（不是同一个父类）之间却存在着相同的一些列的行为（方法），并且这些行为是每一个类都必须要拥有的，但是由于项目是多人协作，在开发过程中每个人每次分配到的需求不一，这一些列的方法不一定都能记得去一一实现，并且即使是同一个方法，每个人每次的命名也不一定能够统一，这给方法的调用带来一定负担。由于只能继承一个类的特性，这些方法又不能定义在另一个抽象类之中，于是就引入了接口的概念来解决这一个问题。

与抽象类不同，抽象类是对类的抽象，接口是对行为的抽象，抽象类中定义了同一种（同一个继承体系）类必须要有的行为，而接口中则是定义不同类中必须要有的行为。

#### 接口的基本使用

接口的定义和使用：

* 接口用关键字`interface`来定义：`public interface 接口名 {}`
* 接口不能实例化
* 接口和类之间是实现关系，通过`implements`关键字表示：`权限修饰符 class 类名 implements 接口1, 接口2... {}`
* 接口的实现类要么重写接口中所有的抽象方法，要么是抽象类
* 实现和继承可以同时存在

#### 接口中成员的特点

* 成员变量：只能是常量，默认修饰符`public static final`（默认，就算你没写，Java也会自动给你加上），因为接口是一种规则，规则是不能改变的，所以只能是常量。

  ```java
  public class InterfaceDemo {
      public static void main(String[] args) {
          System.out.println(InterF.a); // 10
          InterF.a = 20; // Cannot assign a value to final variable 'a'
      }
  }
  
  public interface InterF {
      int a = 10;
  }
  ```

* 构造方法：没有构造方法，因为接口是行为的规则，不能创建对象也不需要给实现类初始化成员变量，所以没有给接口设计构造方法。

* 成员方法：只能是抽象方法，默认修饰符为`public abstract`（默认，就算你没写，Java也会自动给你加上）。

  ① JDK7及以前，接口中只能定义抽象方法；

  ② JDK8新特性：接口中可以定义有方法体的方法`default`和`static`，可以定义方法的默认实现以及静态方法；

  ③ JDK9新特性：接口中可以定义私有方法。

> ① 接口中，所有方法前面的`public abstract`都可以省略，项目开发过程中都是不会去写这部分内容的，所以其格式可以归结为`返回值类型 方法名(参数列表);`。
>
> ② 在IDEA中，编写实现类时，在写完要实现的接口时会出现编译报错，此时按下`Ctrl+I`（macOS为`Command+I`）即可快速呼出方法重写弹窗，窗口中会列出所有还需要重写的方法，选中即可快速生成空实现方法。

#### 接口和类之间的关系

* 类和类的关系：继承关系，只能单继承，不能多继承，但是可以多层继承。
* 类和接口的关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口，如果多个接口中有同名方法，则只需要重写一次即可。
* 接口和接口的关系：继承关系，可以单继承，**也可以多继承**。

#### 接口扩展

接口新增特性：

* JDK8新增的有默认实现的接口方法：有默认实现的方法，使用关键字`default`修饰，一般用于解决接口升级又不需要在所有实现类中去实现或者调用的情况，又或者所有实现类对于该的方法体都完全一致的情况，格式为`default 返回值类型 方法名(参数列表) { 方法体 }`。

  注意事项：① 默认方法不是抽象方法，所以不强制重写，但是如果重写，重写的时候不需要`default`关键字。

  ② 如果实现的多个接口中，有同名的`default`方法，那么实现类就必须重写该方法。

* JDK8新增的接口中可以定义静态方法：接口中定义静态方法与类中的静态方法一样，需要用`static`关键字修饰，格式为`public static 返回值类型 方法名(参数列表) { 方法体 }`。

  注意事项：① 静态方法只能通过接口名去调用，不能通过实现类名或者实现类的对象名去调用。

  ② `public`关键字可以省略，`static`关键字不可以省略。

* JDK9开始，接口中可以定义私有方法：其实在接口中定义私有方法的目的与前文[权限修饰符](#权限修饰符)中所述的**[共性代码](#6-11-权限修饰符-共性代码 "共性代码")**的目的一致，因为静态方法的存在，所有也和普通类一样，包含静态私有方法。

接口的应用：

* 接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类事项对应的接口就可以了。
* 当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态，接口多态的引用于继承多态的应用一致。

#### 适配器模式

设计模式（Design pattern）：是一套反复使用、多数人知晓的、经过分类编目的、代码设计经验总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

适配器设计模式：解决接口于接口实现类之间的矛盾问题。[见23种设计模式-适配器模式](../common/important/23种设计模式.md#13、适配器模式)

问题：一个接口中抽象方法太多，而实际使用只需要其中一部分方法，但是由于接口必须全部实现的限制，需要在实现类中对一些方法做空实现，造成代码可读性下降，代码结构复杂等问题。

解决：

1. 编写中间类`XxxAdapter`实现对应接口；
2. 对接口中的抽象方法进行空实现；
3. 让真正的实现类继承中间类，重写实际需要使用到的方法；
4. 为了避免其他类去创建适配器类对象，中间的适配器类使用`abstract`关键字修饰。

### 6.14 内部类

内部类：类的五大成员之一（五大成员：属性、方法、构造方法、代码块、内部类），在一个类中再定义另一个类即为内部类。内部类表示的是外部类的一部分，内部类单独出现没有任何意义。（Tips：我的开发印象中，内部类在定义一些前端接收的JSON数据时，为了保持结构一致并且方便类的管理时使用过）

内部类的访问特点：

* 内部类可以直接访问外部类的成员，包括私有（类内部）；
* 外部类要访问内部类的成员，必须创建对象。

以下为一个内部类使用样例：

```java
public class InnerClassDemo {
    public static void main(String[] args) {
        Car car = new Car("BMW", 2010, "red", "V8", 20); // 要想在外面使用内部类，需要给内部类加static关键字修饰
        car.show(); // Car{carName='BMW', age=2010, color='red', engine=Engine{name='V8', age=20}}
    }
}

/**
 * 类描述：内部类演示对象
 *
 * @author Triabin
 * @date 2020-10-03 16:08:38
 */
public class Car {
    /**
     * 车名
     */
    private String carName;
    /**
     * 使用年限
     */
    private int age;
    /**
     * 车辆颜色
     */
    private String color;
    /**
     * 引擎
     */
    private Engine engine;

    /**
     * 类描述：发动机引擎
     */
    static class Engine {
        /**
         * 引擎名称
         */
        private String name;
        /**
         * 引擎使用年限
         */
        private int age;

        public Engine() {
        }

        public Engine(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return "Engine{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }

        public String getName() {
            return name;
        }

        public Engine setName(String name) {
            this.name = name;
            return this;
        }

        public int getAge() {
            return age;
        }

        public Engine setAge(int age) {
            this.age = age;
            return this;
        }

        public void show() {
            System.out.println(this);
        }
    }

    public Car() {
    }

    public Car(String carName, int age, String color) {
        this.carName = carName;
        this.age = age;
        this.color = color;
    }

    public Car(String carName, int age, String color, String engineName, int engineAge) {
        this(carName, age, color);
        this.engine = new Engine(engineName, engineAge);
    }

    @Override
    public String toString() {
        return "Car{" +
                "carName='" + carName + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                ", engine=" + engine +
                '}';
    }

    public String getCarName() {
        return carName;
    }

    public Car setCarName(String carName) {
        this.carName = carName;
        return this;
    }

    public int getAge() {
        return age;
    }

    public Car setAge(int age) {
        this.age = age;
        return this;
    }

    public String getColor() {
        return color;
    }

    public Car setColor(String color) {
        this.color = color;
        return this;
    }

    public Engine getEngine() {
        return engine;
    }

    public Car setEngine(Engine engine) {
        this.engine = engine;
        return this;
    }

    public void show() {
        System.out.println(this);
    }
}

```

内部类的分类：根据类位置的不同以及功能作用的差异内部类可以分为成员内部类、静态内部类、局部内部类和匿名内部类，在实际的使用过程中，前三种几乎不用我们自己手动写，匿名内部类则在开发过程中会经常用到。

#### 成员内部类

成员内部类写在成员位置，属于外部类的成员，例如前面案例中`Car`类的内部类`Engine`。

成员内部类可以被一些修饰符修饰，比如`private`、`默认`、`protected`、`public`、`static`等，只要可以用来修饰成员变量的，都可以用来修饰成员内部类。当然，一旦使用`static`进行修饰以后，就不叫成员内部类了，而是叫做静态内部类。

在成员内部类中，JDK16之前是不能定义静态变量的，JDK16开始才可以定义静态变量。

获取成员内部类对象：

* 在外部类编写方法，对外提供内部类的对象：在外部类创建对外暴露的成员方法，方法返回该内部类对象实例即可。
* 直接创建格式：`外部类名.内部类名 对象名 = 外部类对象.内部类对象;`，示例：`Outer.Inner inner = new Outer().new Inner();`

:::info Tips

① Java打印地址值的时候，如果是内部类，地址值为以下格式：`外部类名$内部类名@地址值`，这也是之前命名规范中不建议使用美元符号命名的原因之一。

② 使用`private`关键字修饰的内部类外部无法直接访问，需要跟私有属性一样，提供对外暴露的方法使用内部类。

:::

成员内部类访问外部类：

```java
public class FieldInnerClassDemo {
    public static void main(String[] args) {
        Outer.Inner inner = new Outer().new Inner();
        inner.show();
    }
}

class Outer {
    private int a = 10;
    
    class Inner {
        private int a = 20;
        
        public void show() {
            int a = 30;
            System.out.println(a); // 30
            System.out.println(this.a); // 20
            System.out.println(Outer.this.a); // 10
        }
    }
}
```

内存分析：

![image-20260103173029787](https://gitee.com/triabin/img_bed/raw/master/2026/01/03/83747366ff930cd5e29ab98a566c5cd7-image-20260103173029787.png)
<div style="clear: both;"></div>

* JVM将`Test.class`字节码文件加载到方法区，开始执行该文件夹，将`main`方法加载到栈内存，开始执行；
* `main`方法第一行，需要用到`Outer.class`和`Outer$Inner.class`等字节码文件，将它们分别加载到方法区，然后在栈空间中定义一个类型为`Inner`，名为`oi`的变量；然后在堆空间中开辟一块空间用于存储`Outer`类对象，假设地址为`001`，成员变量为`a`，默认初始化为0，然后再进行字面量初始化为10；再在堆空间中开辟一块内存区域用于存储`Inner`对象，假设地址为`002`，成员变量为`a`，默认值为0，字面量初始化后值为20；然后再在该对象内初始化一个类型为`Outer`的`this`指向前面开辟的`Outer`对象所在内存地址`001`；最后将`Inner`对象所在地址`002`返回并赋值给栈内存中的`oi`；
* `main`方法第二行，调用`oi`对象的`show()`方法，方法入栈，开始执行；
* `show`方法第一行，在栈内存中定义局部变量`a`并给它赋值为30；
* `show`方法第二行，打印变量`a`的值，由于就近原则，直接取局部变量`a`的值30；
* `show`方法第三行，打印`this.a`，由于`show`方法的调用者为`Inner`类对象`oi`，所以`this`指向`002`，所以此处`a`的值为`oi`的成员变量，值为20；
* `show`方法第四行，打印`Outer.this.a`，由于在堆空间中开辟`Inner`对象内存空间时，在该对象中初始化了一个`Outer`的`this`指向外部类，所以这里的`a`为外部类中的成员变量，值为10；
* `show`方法`mian`方法相继执行完毕，方法出栈，程序运行结束。

#### 静态内部类

静态内部类中的一种，算是一种特殊情况，当成员内部类前面使用`static`关键字修饰，该成员内部类就称为静态内部类。静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象。

创建静态内部类对象的格式：`外部类名.内部类名 变量名 = new 外部类名.内部类名();`；

调用非静态方法的格式：先创建对象，对象调用；

调用静态方法的格式：`外部类名.内部类名.方法名(参数列表);`

#### 局部内部类

将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量；

外接无法直接使用，需要在方法内部创建对象并使用；

该类可以直接访问外部类的成员，也可以访问方法内的局部变量。

#### 匿名内部类

匿名内部类本质就是隐藏了名字的内部类，格式为：`new 类名或者接口名 { 重写方法; }`，这当中包含了三个部分，继承/实现、方法重写、创建对象。

举例：有一个接口`Inter`，它有一个抽象方法名为`show()`，那么使用匿名内部类可以直接写成`new Inter() { 直接写重写方法 }`，对于一些接口/父类的直接使用（只用一次）的场景，不需要额外再去新建一个实现类，可以在使用的地方利用匿名内部类直接实现。

代码演示：

```java
public class AnonymousInnerClassDemo {
    public static void main(String[] args) {
        Swim swim = new Swim() {
            @Override
            public void swim() {
                System.out.println("在匿名内部类中重写了swim方法");
            }
        };
        swim.swim();
    }
}

public interface Swim {
    void swim();
}
```

`new 接口名()`后面的花括号中的内容就是那个“没有名字的类”的内容，这些匿名内部类在编译后都会被虚拟机赋予一个名字，字节码文件为`外部类名$数字序号.class`，其内容为常规的实现类编译后的样子。

使用场景：当方法的参数是接口或者类时，以几口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以使用匿名内部类简化代码。

## 7、Lambda表达式和方法引用

### 7.1 Lambda表达式

上一章节匿名内部类中的使用，可以使用Lambda表达式进一步简化代码：

```java
public class AnonymousInnerClassDemo {
    public static void main(String[] args) {
        // Swim swim = () -> {
        //     System.out.println("在匿名内部类中重写了swim方法");
        // };
        // 或
        Swim swim = () -> System.out.println("在匿名内部类中重写了swim方法");
        swim.swim();
    }
}

public interface Swim {
    void swim();
}
```

这就是Lambda表达式的应用。

#### 函数式编程

函数式编程（Functional programming）是一种思想特点。在面向对象中，要做一件事情，首先是先找到对应的对象，然后再让对象去做事情。而函数式编程的思想，则是忽略面向对象复杂的语法，只强调做什么，而不是谁去做。可以简单的理解为我在乎的只有接口里面的方法逻辑，而不是谁去实现了这个接口。

Lambda表达式就是在Java中函数式编程思想的具体实现。

#### Lambda表达式的标准格式

Lambda是JDK8新加入的特性，它由`()`、`->`和`{}`三部分组成：

* `()`：对应方法的形参
* `->`：固定格式
* `{}`：对应方法体，当方法体只有一行代码时，可省略

注意点：

* Lambda表达式可以用来简化匿名内部类的书写
* Lambda表达式只能简化**函数式接口**的匿名内部类的写法
* 函数式接口：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加`@FunctionalInterface`注解验证，如果报错就不是函数式接口

#### Lambda表达式的省略写法

神略核心：可推导，可省略。（凡是可以推导出来的东西，都可以省略）

Lambda的省略规则：

* 参数类型可以省略不写；
* 如果只有一个参数，参数类型可以省略，`()`也可以省略；
* 如果Lambda表达式的方法体只有一行，大括号、分号，`return`可以省略不写，需要同时省略。

```java
import java.util.Arrays;
import java.util.Comparator;

public class LambdaDemo {
    public static void main(String[] args) {
        // Lambda省略规则演示，以Arrays自带的排序方法为例
        Integer[] arr = { 3, 5, 4, 1, 6, 2 };

        // 原生写法
        Arrays.sort(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1 - o2;
            }
        });

        // Lambda表达式
        Arrays.sort(arr, (Integer o1, Integer o2) -> {
            return o1 - o2;
        });
        
        // 省略参数类型
        Arrays.sort(arr, (o1, o2) -> {
            return o1 - o2;
        });
        
        // 省略括号略
        
        // 只有一行，省略大括号、分号、return关键字
        Arrays.sort(arr, (o1, o2) -> o1 - o2);
    }
}
```

:::info Tips

函数式编程思想是JDK8才引入的的，为此，JDK8还提供了一些函数式接口来供方便我们更好地在Java开发中使用函数式编程，详见[Java四大函数式编程接口](./random-notes/Java四大函数式编程接口)。在实际开发中，熟悉了函数式编程后，就会觉得Lambda表达式非常好用，但是在刚开始接触开发的时候，往往意识不到哪些地方该使用函数式编程。以我的经验来看，**只要觉得某个地方传递的参数实际上是函数**，就立马考虑是否使用函数式编程，一使用函数式编程，就先看看在Java提供的四大函数式编程接口中，是否有现成可用的接口，避免自己重复创建函数式接口。四大函数式编程接口基本涵盖了80%以上的使用场景了，极少需要自己手动创建这样的接口。

:::

### 7.2 方法引用

方法引用：把已有的方法拿过来用，当做函数式接口中抽象方法的方法体。

#### 方法引用的基本使用

方法引用的要求：
* 引用处必须是函数式接口
* 被引用的方法必须已经存在
* 被引用方法的形参和返回值需要跟抽象方法保持一致
* 被引用方法的功能要满足当前需求

下面通过一个方法引用的实际使用案例来说明如何使用方法引用：

```java
import java.util.Arrays;
import java.util.Comparator;

public class MethodRefDemo {
    public static void main(String[] args) {
        // 创建一个数组，进行倒序排序
        Integer[] arr = { 3, 5, 4, 1, 6, 2 };
        System.out.println("原数组：" + Arrays.toString(arr));

        // 原生写法
        Arrays.sort(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });

        // Lambda表达式
        Arrays.sort(arr, (Integer o1, Integer o2) -> {
            return o2 - o1;
        });
        
        // Lambda表达式简化格式
        Arrays.sort(arr, (o1, o2) -> o2 - o1);

        // 方法引用
        Arrays.sort(arr, MethodRefDemo::subtact);

        System.out.println("倒序后：" + Arrays.toString(arr));
    }

    // 可以是Java自带的，也可以是第三方的
    public static int subtact(int num1, int num2) {
        return num2 - num1;
    }
}
```

在上述排序的案例中，`MethodRefDemo::subtact`表示引用`MethodRefDemo`类中的`subtact`方法来作为`Arrays.sort`方法第二个参数的接口中抽象方法的方法体。（`::`是方法引用符）

方法引用的分类：方法引用可以分为引用静态方法、引用成员方法和引用构造方法，其中，引用成员方法还可以细分为应用其他类的成员方法、引用本类的成员方法和引用父类的成员方法。

#### 引用静态方法

格式：`类名::静态方法名`，例`Integer::parseInt`。

#### 引用成员方法

格式：`对象::成员方法名`，例`System.out::println`。
* 其他类：`其他类对象::方法名`
* 本类：`this::方法名`
* 父类：`super::方法名`

注意：本类和父类的方法引用使用过程中，方法引用处不能是静态方法内，因为静态方法中没有`this`，如果非要在静态方法中使用，那么只能新建一个对象来完成方法引用。

#### 引用构造方法

格式：`类名::new`，例`Random::new`。

练习：集合里面存储姓名和年龄，比如：张无忌，15，要求：将数据封装成`Student`对象并收集到`List`集合中。

题解：

```java
// 学生类设计
package com.triabin.ideasy_server;

/**
 * 类描述：学生类
 *
 * @author Triabin
 * @date 2020-10-04 00:36:40
 */
public class Student {
    /**
     * 学生姓名
     */
    private String name;

    /**
     * 学生年龄
     */
    private int age;

    public Student() {}

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Student(String strItem) {
        String[] items = strItem.split("，");
        this.name = items[0];
        this.age = Integer.parseInt(items[1]);
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public Student setName(String name) {
        this.name = name;
        return this;
    }

    public int getAge() {
        return age;
    }

    public Student setAge(int age) {
        this.age = age;
        return this;
    }
}
```

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class StudentSeloution {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        Collections.addAll(list, "张无忌，15", "赵敏，18", "周芷若，16", "张三丰，107", "周伯通，19", "张翠山，36");
        List<Student> students = list.stream()
                .map(Student::new)
                .toList();
        System.out.println(students);
    }
}
```

说明：
①`list.stream()`意为将`list`集合转换为一个流，流是Java8中新增的一个概念，它可以对集合中的元素进行操作，例如筛选、映射、排序等。可以理解为它能将一个可迭代对象中的元素放到流水线上然后通过流式调用的方式可以对这些流水线上的元素进行操作。这里只做一个简单介绍，后续章节再详细学习。

② `流.map(Function<T,R>)`，这个`map`方法接收一个`Function<T,R>`函数式接口作为参数，用于将接受到的`T`类型参数转换为`R`类型参数。（详见[Java四大函数式编程接口](./random-notes/Java四大函数式编程接口)），将`List<String>`转为流之后调用`map`方法时可以就可以将流水线上的每个元素按照提供的`Function<T,R>`函数式接口中的抽象方法进行转换，将每个元素转换为`Student`对象。

#### 其他调用方式

**使用类名引用成员方法**，格式：`类名::成员方法`，例`String::substring`。

> 题目：集合里面有一些字符串，将它们变成大写后输出。
>
> ```java
> import java.util.ArrayList;
> import java.util.Collections;
> import java.util.List;
> 
> public class MethodRefDemo {
>     public static void main(String[] args) {
>         List<String> list = new ArrayList<>();
>         Collections.addAll(list, "aaa", "bbb", "ccc", "ddd");
>         
>         list.stream().map(String::toUpperCase).forEach(System.out::println);
>     }
> }
> ```

从上面的案例可以看到，`类名::方法名`这样的方式调用到了`String`类中的成员方法`public String toUpperCase()`（注意不是静态方法）。这种方法引用其实是根据函数式接口中抽象方法的第一个参数决定的，必须是该抽象方法参数列表中的**第一个参数**所属类的成员方法才可以这样调用。

上述案例中，`map`的函数式接口`Function<T,R>`的抽象方法`apply(T t)`接收的第一个参数`T`是`String`，而`toUpperCase`是`String`的成员方法，所以可以这么调用。

注意：成员方法的参数列表需要与所需接口的抽象方法参数列表中第二个参数到最后一个参数保持一致，如果只有一个参数，那么成员方法为无参。

**引用数组的构造方法**，格式：`数据类型[]::new`，例`int[]::new`。

> 题目：集合中存储一些整数，收集到数组中。
>
> ```java
> import java.util.Arrays;
> import java.util.Collections;
> import java.util.List;
> 
> public class MethodRefDemo {
>     public static void main(String[] args) {
>         List<Integer> list = new ArrayList<>();
>         Collections.addAll(list, 1, 2, 3, 4, 5);
>         // Integer[] arr = list.toArray(new IntFunction<Integer[]>() {
>         //     @Override
>         //     public Integer[] apply(int value) {
>         //         return new Integer[0];
>         //     }
>         // });
>         // 改为使用方法引用
>         Integer[] arr = list.toArray(Integer[]::new);
>         System.out.println(Arrays.toString(arr));
>     }
> }
> ```
>
> 注意：数组的类型需要跟流中的类型保持一致。

## 8、API&字符串

面向对象其实就学两部分，如何使用别人写好的东西？自己如何设计一个类？

### 8.1 API

API：Application Programming Interface，即应用程序编程接口。简单理解就是别人已经写好的东西，我们不需要自己编写，直接使用即可。例如前文中使用的`Random`对象，就是Java中已经编写好的一个工具类。

JavaAPI：指的就是JDK中提供的各种功能的Java类。这些类将底层的功能实现逻辑封装了起来，我们不需要关心这些类是如何实现的，只需要学习使用这些类即可。

Java帮助文档使用：在Oracle官网，有完整的接口文档，将这些接口文档下载下来，然后打包成了`.CHM`文件，就可以离线进行文档的传递了。该文档中，有JDK全部的类以及类的详细说明文档，如果需要查询某个类，直接搜索类名或者到相应的包下查找即可。

![image-20251225173013380](https://gitee.com/triabin/img_bed/raw/master/2025/12/25/110192666ed55e2c04d1cbd432330307-image-20251225173013380.png)

<div style="clear: both;"></div>

说明：`java.lang`包中存放的是Java的基础类，因此在使用这个包下的类的时候，不需要写`import`导包语句。

一般使用步骤：
* 打开API文档
* 点击显示，并找到索引下面的输入
* 在输入框中输入类名并点击显示
* 查看类所在包
* 查看类的描述
* 查看构造方法
* 查看成员方法

例如查看之前生成随机数所用的`java.util.Random`类：

![image-20251226134113331](https://gitee.com/triabin/img_bed/raw/master/2025/12/26/5aea4428e973b4924787460ffeaa55ce-image-20251226134113331.png)

<div style="clear: both;"></div>

:::warning 注意

① `.CHM`文件在Windows系统中可以直接打开，并正常显示；

② 在macOS中可以去AppStore免费下载`CHM Viewer`，用它打开，但是如果文档中有中文，有可能会遇到乱码，此时需要在软件顶部`工具栏-文本编码`中选择`Unicode (UTF-8)`（每次打开都需要选择一次）；

③ JDK各个版本几乎都比较通用，所以国内使用比较广的就是JDK1.8的中文版本，因为这个版本的中文翻译做得相对详尽（虽然也是机翻，但是够看了😅），真正遇到有差异的工具类时再去官网找对应版本的文档即可（一般几乎遇不到这种情况）；

④ 目前比较流行的中文版本是JDK1.8的一个帮助文档，其他版本大同小异，有需要可取Oracle官网下载，例如[JDK21](https://www.oracle.com/java/technologies/javase-jdk21-doc-downloads.html)，[JDK8中文版本](https://www.123865.com/s/VBJ0Td-0qni)。

:::

### 8.2 字符串

字符串，在Java中可以通过双引号字面量直接获取到字符串对象，对于字符串的操作，前文运算符中一节中已经介绍过拼接，此外，字符串的其他常用的操作还有比较、替换、截取、查找、切割、检索、加密、打乱内容、大小写转换等。

字符串在开发中有着极其广泛的应用，尤其在C端，可以说这是最接近C端直接输入和现实的东西，为了方便对字符串的操作，Java中提供了`java.lang.String`、`java.lang.StringBuilder`、`java.lang.StringBuffer`、`java.util.StringJoiner`、`java.util.regex.Pattern`、`java.util.regex.Matcher`等类对方便对字符串进行操作。

#### String

概述：`java.lang.String`类代表字符串，Java程序中的所有字符串文字（例如"abc"）都为此类对象。

注意点：字符串的内容是不会发生改变的，它的对象在创建后不能被更改。如果将两个字符串拼接，那么它将会产生一个新的字符串。

```java
public class StringDemo {
    public static void main(String[] args) {
        String name = "尼古拉斯·阿伟";
        String schoolName = "迦南学院";
        System.out.println(name + schoolName);
        // 以上三行代码共计产生了三个字符串对象

        Sting str = "String1";
        str = "String2";
        // 以上两行代码共计产生两个字符串对象
    }
}
```

创建字符串对象的两种方式：
* 直接赋值：`String name = "尼古拉斯·阿玮";`

* `new`关键字：
  
  |             构造方法             |                            说明                            |
  | :------------------------------: | :--------------------------------------------------------: |
  |        `public String()`         |               创建空白字符串，不包含任何内容               |
  | `public String(String original)` |              根据传入的字符串，创建字符串对象              |
  |  `public String(char[] value)`   |                根据字符数组，创建字符串对象                |
  |  `public String(byte[] bytes)`   | 根据字节数组，创建字符串对象（有重载方法可传入字符集参数） |
  
  这四种方式，前两种几乎不用，第三种一般用于变更字符串的场景，第四种则在网络编程中有较为广泛的应用，在网络环境中传输的数据一般都是字节信息，包括字符串，在将字节信息转为字符串时，就需要用到这个构造方法。

字符串对象创建的内存模型：目前为止，关于Java的内存模型，已经了解了栈内存、堆内存以及方法区三个逻辑分区，而通过**直接使用双引号字面量赋值的字符串**都存在一个新的分区中——`StringTable`（串池，或者字符串常量池），这个分区在JDK7之前是独立的，但是从JDK7开始，这个分区被挪到了堆内存中，但是其核心逻辑并没有改变。

串池工作原理：当通过双引号字面量直接赋值的方式创建字符串对象的时候，JVM会先检查串池中是否存在该字符串，如果存在直接返回该字符串地址，不存在则创建一个字符串再返回其地址。

`public String(char[] value)`创建字符串对象内存模型：

![image-20251226142037671](https://gitee.com/triabin/img_bed/raw/master/2025/12/26/0875ea3a0e2ba411b8332af30f03be11-image-20251226142037671.png)

<div style="clear: both;"></div>

如上图所示，每`new`一次，都会在堆内存中开辟一块空间来存储相同的字符串，完全没有字符串常量池的复用逻辑。

字符串的比较：

```java
public class StringDemo {
    public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "abc";
        System.out.println(s1 == s2); // true
        
        String s3 = "aaa";
        String s4 = "bbb";
        System.out.println(s3 == s4); // false
        
        String s5 = new String("abc");
        String s6 = "abc";
        System.out.println(s5 == s6); // false
    }
}
```

`==`号比较的内容：基本数据类型比较的是具体的值，引用数据类型比较的是地址值。因此则可以解释上述代码的运行结果了。

在`java.lang.String`中，一共提供了两个方法来实现字符串之间的比较功能：

* `public boolean equals("要比较的字符串")`：完全一样的结果才是`true`，否则为`false`，其实现逻辑如下：

  ```java
  public final class String {
      // ...
      
      public boolean equals(Object anObject) {
          if (this == anObject) {
              return true;
          }
          return (anObject instanceof String aString)
                  && (!COMPACT_STRINGS || this.coder == aString.coder)
                  && StringLatin1.equals(value, aString.value);
      }
  }
  
  final class StringLatin1 {
      @IntrinsicCandidate
      public static boolean equals(byte[] value, byte[] other) {
          if (value.length == other.length) {
              for (int i = 0; i < value.length; i++) {
                  if (value[i] != other[i]) {
                      return false;
                  }
              }
              return true;
          }
          return false;
      }
  }
  ```

* `public boolean equalsIgnoreCase("要比较的字符串")`：功能与`equals`相同，只是忽略大小写（见名知意）。

:::info Tips

在编程过程中难免会遇到未知字符串变量与已知字符串进行比较的情况，例如方法传入的字符串参数`value`与已知字符串`"targetValue"`进行比较，此时应该写成`"targetValue".equals(value)`，因为如果反过来写成`value.equals("targetValue")`，虽然代码能编译通过，但是如果调用方法的时候传入的字符串为`null`，那么这种写法将导致空指针异常（`NullPointerException`，算是Java程序员最常见的异常之一了😅）。

:::

`java.lang.String`类中的常用方法（这里只列举方法名，参数和返回值都可见名知意）：

* 长度：`length`

* 检索：检索则需要了解字符串的索引下标这一个概念，类似数组，第一个字符下标为0，从0开始到`length-1`

  ① `charAt`：用于定位指定字符索引

  ② `indexOf`：用于定位指定字符串在字符串中的起始索引

  ③ `contains`：用于判断是否存在指定字符串，返回布尔值

* 比较：`equals`、`equalsIgnoreCase`、`matches`，`matches`参数为正则表达式
* 替换：`replace`、`replaceAll`，`replaceFirst`，注意后两个方法都是匹配的正则表达式
* 截取：`substring`，注意第一参数为截取的起始索引，第二个参数为截取的结束索引后一位（左闭右开区间），第二个参数如果不填，则从起始索引开始截取全部
* 大小写转换：`toUpperCase/toLowerCase`
* 判空：`isEmpty()`
* 其余方法则在使用到的时候再查即可

#### StringBuilder

String的缺陷：

```java
public class StringDemo {
    public static void main(String[] args) {
        // 拼接百万字符串
        String res = "";
        for (int i = 0; i < 1000000; i++) {
            res += "abc";
        }
        System.out.println(res);
    }
}
```

当运行以上代码时，由于字符串常量池中的字符串不可变，将会短时间内在`StringTable`中产生百万个只在一次循环中使用后就丢弃的字符串常量，造成了内存的大量浪费。`java.lang.StringBuilder`就是为了解决这种问题而设计的。

概述：`StringBuilder`可以看成是一个容器，创建之后，里面的内容是可变的，这将大大提高字符串的操作效率。

构造方法：

* `public StringBuilder()`：创建一个空白可变字符串对象，不含有任何内容
* `publci StringBuilder(String str)`：根据字符串内容创建可变字符串对象

常用方法：

* `public StringBuilder append(任意类型)`，拼接数据并返回对象本身（类似前面介绍的方便链式调用的`setter`方法），参数可以是任意类型，会自动调用对应类型的`toString()`方法（该方法每一个对象一定会有，基本数据类型会自动装箱为包装类，然后调用包装类的`toString`方法）
* `public StringBuilder reverse()`：反转容器中的内容
* `public int length()`：与`java.lang.String`类中的一样，返回字符串长度
* `public String toString()`：将`StringBuilder`转为`String`

> 说明：Java底层对`StringBuilder`、`StringBuffer`等类做了特殊处理，在使用`println`方法打印时，不需要另转为`String`，可以直接打印。

#### StringJoiner

```java
public class StringDemo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3 };
        StringBuilder sb = new StringBuilder("[]");
        for (int i = 0; i < arr.length; i++) {
            if (i == arr.length - 1) {
                sb.append(arr[i]);
            } else {
                sb.append(arr[i]).append(", ");
            }
        }
        sb.append("]");
        System.out.println(sb);
    }
}
```

对于以上代码，拼接类似这样的可迭代的数组，还需要判断索引以确定分隔符“, ”是否添加，繁琐且易出错，于是为了解决这种问题就设计了`java.util.StringJoiner`类，上述代码可以使用它进行改写：

```java
import java.util.StringJoiner;

public class StringDemo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3 };
        StringJoiner sj = new StringJoiner(", ", "[", "]");
        for (int i = 0; i < arr.length; i++) {
            sj.add(arr[i] + "");
        }
        System.out.println(sj);
    }
}
```

概述：

* `StringJoiner`与`StringBuilder`一样，都可以看成是一个容器，创建之后里面的内容是可变的；
* 作用：提高字符串的操作效率，而且代码编辑十分简洁，但是由于是JDK8新特新，实际项目中很少人使用，主要是`StringBuilder`使用习惯了，新生代沿用了下来，并且`String`自身也有一个静态方法`String.join()`用来拼接可迭代对象。

构造方法：

* `public StringJoiner("间隔符号")`：创建一个`StringJoiner`对象，只指定拼接时的间隔符号；
* `public StringJoiner(间隔符号, 开始符号, 结束符号)`：创建一个`StringJoiner`对象，指定拼接时的间隔符号、开始符号、结束符号。

常用方法：

* `public StringJoiner add(String "添加的内容")`：添加数据，并返回对象本身
* `public int length()`
* `public String toString()`

#### 字符串原理

回顾：

* 字符串存储的内存原理：直接复制会复用字符串常量池中的，`new`出来的不会复用，而是开辟一个新的内存空间
* `==`号比较的到底是什么：基本数据类型比较数据值，引用数据类型比较内存地址

字符串拼接的底层原理：

* 等号右边无变量参与

  ```java
  public class StringDemo {
      public static void main(String[] args) {
          String s = "a" + "b" + "c";
          System.out.println(s);
      }
  }
  ```

  这种情况会触发编译器的优化机制，在编译时会将它编译成最终结果“"abc"”。

* 等号右边有变量参与

  ```java
  public class StringDemo {
      public static void main(String[] args) {
          String s1 = "a";
          String s2 = s1 + "b";
          String s3 = s2 + "c";
          System.out.println(s3);
      }
  }
  ```

  <img src="https://gitee.com/triabin/img_bed/raw/master/2025/12/26/00f4bf18c82d44586e2dd1e189d5ebf8-image-20251226154057595.png" alt="image-20251226154057595" align="left"/>
  
  <div style="clear: both;"></div>
  在JDK8以前，会自动使用`StringBuilder`进行拼接，因此在运行类似`String s2 = s1 + "b";`这样一行代码的时候，会创建一个`StringBuilder`对象，然后运行`append`方法将`"b"`拼接到字符串后面，再将`StringBuilder`对象转为`String`对象（通过`new String()`的方式），因此每运行一次这样的拼接以后，都会产生至少一个`String`对象以及在字符串常量池中产生一个拼接目标的字符串常量。这就是直接使用字符串拼接性能低下的原因。
  
  在JDK8中，针对这一情况，对于拼接代码等号右边有变量的情况都会对拼接结果进行一次长度预估，然后创建对应长度的数组，将拼接变量与字符串分别填入数组后再拼接，但是预估以及面对上面这种一个变量就拼接一次的情况，还是会触发多次预估和数组创建，仍浪费时间、内存和性能。

总之，面对多变量字符串拼接的情况，不要直接使用`String`进行拼接，改为使用`StringBuilder`、`StringBuffer`、`StringJoiner`等专门设计的类来进行拼接更为合适。

`StringBuilder`提高效率的原理：所有要拼接的内容都会往`StringBuilder`中存放，不会开辟新的内存空间，节约内存。

`StringBuilder`原码分析：

* 默认创建一个长度为16的字节数组`value`

* 添加的内容长度小于16，直接存

* 添加的内容大于16会扩容（`原来容量 * 2 + 2`）

* 如果扩容后还不够，以实际长度为准进行扩容

* 代码演示：

  ```java
  public class StringBuilderDemo {
      public static void main(String[] args) {
          StringBuilder sb = new StringBuilder();
          System.out.println(sb.capacity()); // 16
          System.out.println(sb.length()); // 0
  
          sb.append("abc");
          System.out.println(sb.capacity()); // 16
          System.out.println(sb.length()); // 3
  
          sb.delete(0, sb.length());
          sb.append("abcdefghijklmnopqrstuvwxyz");
          System.out.println(sb.capacity()); // 34
          System.out.println(sb.length()); // 26
  
          sb.delete(0, sb.length());
          sb.append("abcdefghijklmnopqrstuvwxyz0123456789");
          System.out.println(sb.capacity()); // 36
          System.out.println(sb.length()); // 36
      }
  }
  ```

> 习题：给定两个字符串，A和B。A的旋转操作就是将A最左边的字符移动到最右边，例如，A='abcde'，旋转之后就是'bcdea'，如果在若干次旋转操作之后，A能变成B，返回true，不能则返回false。
>
> 题解：
>
> ```java
> public class Answers {
>     public boolean isRotateMatch(String strA, String strB) {
>         if (strA == null || strB == null) return false;
>         if (strA.length() != strB.length()) return false;
>         if (strA.equals(strB)) return true;
>         for (int i = 0; i < strA.length(); i++) {
>             strA = strA.substring(1) + strA.charAt(0);
>             if (strA.equals(strB)) return true;
>         }
>         return false;
>     }
> }
> ```

## 9、常用API

Java写好的各种功能的Java类，不需要刻意记忆，只需要记得类名和类的作用即可，需要的时候再通过API文档去查询即可。

### 9.1 Math

`java.lang.Math`是一个专门用于数学计算的**工具类**，构造方法私有化，所有类都是静态的，对外使用的成员变量也定义为了常量。（自然对数的基数`E`和圆周率`PI`）

`Math`类的常用方法：

|                     方法名                     |                  说明                  |
| :--------------------------------------------: | :------------------------------------: |
|         `public static int abs(int a)`         |            获取参数的绝对值            |
|     `public static double ceil(double a)`      |                向上取整                |
|     `public static double floor(double a)`     |                向下取整                |
|       `public static int round(float a)`       |                四舍五入                |
|     `public static int max(int a, int b)`      |          获取两个数中的较大值          |
| `public static double pow(double a, double b)` |              返回$a^{b}$               |
|        `public static double random()`         | 返回范围为`[0.0, 1.0)`的`double`随机值 |

使用说明：

* 使用`public static int abs(int a)`时，如果传入-2147483648（`int`类型的最小值），由于`int`型的数值最大值为2147483647，该方法将会失效。如果要避免这样的问题，可以使用`public static int absExact(int a)`代替（JDK15新特性），使用该方法，如果传入了`int`最小值，它将会报错`ArithmeticException`，源码：

  ```java
  public static int absExact(int a) {
      if (a == Integer.MIN_VALUE)
          throw new ArithmeticException(
              "Overflow to represent absolute value of Integer.MIN_VALUE");
      else
          return abs(a);
  }
  ```

* `public static double ceil(double a)`功能为数值大小进一，在项目中一般用于类似文件分块这种场景，例如一个文件传输过程中，打算对文件进行分块传输，每个文件块为128MB，对于要传输的文件，你是无法保证其大小始终是128MB的整数倍的，所以需要对`fileSize / blockSize`的结果进行向上取整。

* 对于`public static int max(int a, int b)`，很自然的提供了一个功能相反的方法`public static int min(int a, int b)`。

* 对于`public static double pow(double a, double b)`的使用，一般利用数学的变换将指数转换为一个大于等于1的正整数传入；对开根号，`Math`类提供了`public static double sqrt(double a)`方法来开平方，`public static double cbrt(double a)`来开立方。

* `public static double random()`方法本质上底层使用的也是`Random`类，可能是为了与其他语言保持一致，也有可能是为了`Math`类的完整性，但是它获取整数范围内的数值比较麻烦，例如获取`[10, 90]`之间的数值：`Math.floor(Math.random() * (90 - 10 + 1)) + 10`，解析，`[0, 1)`乘以`90 - 10 + 1`得到`[0, 81)`，向下取整得到`[0, 80]`，再加10，得到范围`[10, 90]`，所以得到如果要取正数区间`[min, max]`之间的随机整数，公式为`Math.floor(Math.random() * (max - min + 1) + min)`。如果是取`[0, max]`则可简化为`Math.floor(Math.random() * (max + 1))`。如果使用`java.util.Random`类取`[0, max]`则可以直接`random.nextXxx(max)`（`Xxx`为具体的基本数据类型），取`[min, max]`则可以使用公式`random.nextXxx(max - min + 1) + min`，推导原理是一样的。

### 9.2 System

`java.lang.System`也是一个工具类，提供了一些与系统相关的方法。

常用方法：

|                            方法名                            |           说明           |
| :----------------------------------------------------------: | :----------------------: |
|            `public static void exit(int status)`             | 终止当前运行的Java虚拟机 |
|       `public static native long currentTimeMillis()`        | 返回当前系统时间的毫秒值 |
| `public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)` |         数组拷贝         |

使用说明：

* `public static void exit(int status)`，状态码`status`为0说明虚拟机是正常停止，非0（一般传1）说明虚拟机异常停止。

* 返回的是**计算机时间原点**（1970年1月1日 00:00:00）到到当前计算机系统时间总共经过了多少毫秒的值，项目中使用非常非常广泛，多用于计算某块代码执行时间，以打印日志。一般使用形式：`long startTime = System.currentTimeMillis();`，要记录的代码块运行结束位置`log.info("xxx总共耗时{}毫秒", System.currentTimeMillis() - startTime)`。

  > 关于计算机时间原点
  >
  > 1969年8月，贝尔实验室的程序员肯汤普逊利用妻儿离开一个月的机会，开始着手创造了一个全新的革命性的操作系统。使用B编译语言在老旧的PDP-7机器上开发出了Unix的一个版本。随后，汤普逊和同事丹尼斯里奇改进了B语言，开发出了C语言，重写了Unix。
  >
  > 于是，就将1970年1月1日零时作为计算机的时间原点，之后的所有时间戳都是以此为时间原点进行计算。
  >
  > 中国处于东八区，所以获取到的时间原点为1970年1月1日 08:00:00，如果要将时间戳转为人眼查看的时间格式，需要注意时区问题，这个之后时间API再详述。

* `public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`参数说明：

  ① `Object src`：数据源（要拷贝的数组）

  ② `int srcPos`：要拷贝数据源数组的起始索引（要从第几个元素开始拷贝），索引不在源数组范围报数组索引越界异常。

  ③ `Object dest`：拷贝数据的目的地（要拷贝到哪个数组），如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错，如果源数组和目标数组都是引用数据类型，那么子类类型可以赋值个父类类型。

  ④ `int destPos`：拷贝数据目的地数组的起始索引（从目的地数组的第几个元素开始放置拷贝的数据），索引不在目的地数组范围，报数组索引越界异常。

  ⑤ `int length`：拷贝数组的数量（从源数组的srcPos开始，要拷贝多少个元素），一旦超过超过目标数组或者源数组长度，就会报数组索引越界异常`ArrayIndexOutOfBoundsException`。

### 9.3 Runtime

`java.lang.Runtim`类表示当前虚拟机的运行环境，这个类里面的方法不是静态的，并且这个类不能创建，只能通过它提供的`getRuntime()`方法获取。

|                方法名                 |                    说明                     |
| :-----------------------------------: | :-----------------------------------------: |
| `public static Runtime getRuntime()`  |            当前JVM的运行环境对象            |
|    `public void exit(int status)`     |                 停止虚拟机                  |
|  `public int abailableProcessors()`   |               获取CPU的线程数               |
|       `public long maxMemory()`       |  JVM能从系统中获取总内存大小（单位：Byte）  |
|      `public long totalMemory()`      | JVM已经从系统中获取总内存大小（单位：Byte） |
|      `public long freeMemory()`       |        JVM剩余内存大小（单位：Byte）        |
| `public Process exec(String command)` |                运行系统命令                 |

使用说明：

* `public static Runtime getRuntime()`，当前虚拟机运行环境唯一，所以运行环境设计成单例模式，所以将构造函数虚拟化，并在类中创建静态私有化实例，再提供此方法对外暴露使用，确保任意位置获取到的都是同一个虚拟机实例。
* `public void exit(int status)`作用与`System`类中的`exit`方法一致，`System.exit(int status)`其实底层就是这个方法。

### 9.4 Object和Objects

#### Object

`java.lang.Object`是Java中的顶尖父类，所有类都直接或间接地继承于`Object`类。它的方法可以被所有的子类访问，所以它的特性非常重要。

|               方法名                |           说明           |
| :---------------------------------: | :----------------------: |
|          `public Object()`          | 空参构造（没有成员变量） |
|     `public String toString()`      |   返回对象的字符串形式   |
| `public boolean equals(Object obj)` |   比较两个对象是否相等   |
|   `protected Object clone(int a)`   |         对象克隆         |

* 关于构造方法，由于无法给所有对象规定统一的成员变量，它没有成员变量，也就只有空参构造，这也是子类构造方法默认调用`super()`的原因之一，因为如果直接父类是`Object`，那么它是没有成员变量的。

* `public String toString()`，这个方法默认返回的是对象的地址值，地址值对于人（运维人员/程序员）来说，没有多大意义，人真正关心的是它的属性值，因此一般都需要手动重写这个方法。`toString`的应用极其广泛，项目中，几乎所有的类都要重写`toString()`方法，重写的内容为将对象的所有属性转为字符串（通过编辑器生成即可），并且这个方法是JavaSDK或者一些第三方包需要打印对象时的默认调用方法，例如Java的`System.out.println`，第三方日志`log4j2`的日志打印函数，底层都会调用对象的`toString`方法，把对象变成字符串然后再打印。

  ```java
  // 案例：
  public class Student {
      /**
       * 学生姓名
       */
      private String name;
  
      /**
       * 学生年龄
       */
      private int age;
  
      @Override
      public String toString() {
          return "Student{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  '}';
      }
  }
  ```

* `public boolean equals(Object obj)`方法底层比较的是地址值，前文已经提到，地址值对于人来说，是没有多大意义的，因此对于那些主要关注属性值的类，需要重写`equals`方法，例如`java.lang.String`、包装类以及其他主要关注数值的类。项目中不常重写，但是一旦重写，就需要连同`public native int hashCode()`一起重写（也都是代码编辑器生成）。

* `protected Object clone(int a)`，把A对象的属性值完全拷贝给B对象，也叫做对象拷贝、对象复制。关于这个方法的使用，由于方法是`protected`的，所有无法直接调用（我们不可能在`java.lang`包下写代码），需要每个类自己去重写方法，此外，还需要在可以被克隆的JavaBean上实现`java.lang.Cloneable`接口，该接口中没有内容，主要作用是标记此类可被克隆，不实现该接口的类即使重写了`clone`方法，调用的时候也会报错`CloneNotSupportedException`。

深克隆与浅克隆：

* 浅克隆：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来；（`java.lang.Object#clone`就是浅克隆）
* 深克隆：基本数据类型拷贝过来，字符串复用串池中的内容，**引用数据类型会重新创建新的**。

深浅克隆代码演示：

```java
public class CloneDemo {
    public static void main(String[] args) throws IOException {
        CloneBean bean = new CloneBean(1, "cloneDemo", new int[] { 1, 3, 5 });
        CloneBean cloneBean = bean.clone();
        System.out.println("修改克隆对象前原对象：" + bean); // 修改克隆对象前原对象：CloneBean{id=1, name='cloneDemo', scores=[1, 3, 5]}
        cloneBean.id = 2;
        cloneBean.name = "cloneDemo2";
        cloneBean.scores[0] = 2;
        cloneBean.scores[1] = 4;
        cloneBean.scores[2] = 6;
        System.out.println("修改克隆对象后原对象：" + bean); // 修改克隆对象后原对象：CloneBean{id=1, name='cloneDemo', scores=[2, 4, 6]}
    }

    static class CloneBean implements Cloneable {
        int id;
        String name;
        int[] scores;

        @Override
        public String toString() {
            return "CloneBean{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", scores=" + Arrays.toString(scores) +
                    '}';
        }

        public CloneBean(int id, String name, int[] scores) {
            this.id = id;
            this.name = name;
            this.scores = scores;
        }

        @Override
        public CloneBean clone() {
            try {
                return (CloneBean) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new AssertionError();
            }
        }
    }
}
```



:::warning 注意

① 如果在Java接口中，里面没有任何抽象方法以及其他内容，那么这个接口就是一个标记接口。

② 如果要深克隆，可以考虑将对象转为JSON再通过JSON获取新对象。

:::

#### Objects

`java.util.Objects`是一个工具类，提供了一些常用方法。

|                       方法名                       |                           说明                            |
| :------------------------------------------------: | :-------------------------------------------------------: |
| `public static boolean equals(Object a, Object b)` |               先做非空判断，再比较两个对象                |
|     `public static boolean isNull(Object obj)`     | 判断对象是否为`null`，为`null`返回`true`，反之返回`false` |
|    `public static boolean nonNull(Object obj)`     |        判断对象是否为`null`，跟`isNull`的结果相反         |

使用说明：

* `public static boolean equals(Object a, Object b)`，方法的底层会判断`a`是否为空，为空直接返回`false`，不为空就利用`a`调用`equals`方法。

### 9.5 BigInteger和BigDecimal

#### BigInteger

在Java中，整数有四种类型：`byte`、`short`、`int`、`long`，这几种数据类型，最多占用8个字节，尽管能表示的数非常大，但是终归是有数值范围限制，因此Java设计了`java.math.BigInteger`类来解决这种问题。

构造方法：

|                    方法名                    |                  说明                  |
| :------------------------------------------: | :------------------------------------: |
|   `public BigInteger(int num, Random rnd)`   | 获取随机大整数，范围$[0, 2^{num - 1}]$ |
|       `public BigInteger(String val)`        |             获取指定大整数             |
|  `public BigInteger(String val, int radix)`  |          获取指定进制的大整数          |
| `public static BigInteger valueOf(long val)` |      静态方法获取`BigInteger`对象      |

使用说明：

* 构造方法参数中的`String val`必须是整数字符串，否则报错`NumberFormatException`。
* `BigInteger`对象一旦创建，里面存储的值不可变。
* 对于`public BigInteger(String val, int radix)`，其中字符串必须与`radix`指定的进制匹配，否则报错`NumberFormatException`。
* `public static BigInteger valueOf(long val)`，能获取的范围有限，只能获取`long`类型的数值范围内的数。对于常用数字`-16~16`有内部有优化，提前将这些数字的`BigInteger`对象创建好，如果多次获取，不会创建新的。
  ```java
  import java.math.BigInteger;
  
  public class BigIntegerDemo {
      public static void main(String[] args) {
          BigInteger num1 = BigInteger.valueOf(16);
          BigInteger num2 = BigInteger.valueOf(16);
          System.out.println(num1 == num2); // true
  
          BigInteger num3 = BigInteger.valueOf(-17);
          BigInteger num4 = BigInteger.valueOf(-17);
          System.out.println(num3 == num4); // false
          System.out.println(num3.equals(num4)); // true
      }
  }
  ```
* 对象一旦创建，不会发生改变，即使调用加减乘除等方法进行了运算，返回的也是一个新的`BigInteger`对象。

常见成员方法：

|                          方法名                          |                说明                 |
| :------------------------------------------------------: | :---------------------------------: |
|         `public BigInteger add(BigInteger val)`          |                加法                 |
|       `public BigInteger subtract(BigInteger val)`       |                减法                 |
|       `public BigInteger multiply(BigInteger val)`       |                乘法                 |
|        `public BigInteger divide(BigInteger val)`        |                除法                 |
| `public BigInteger[] divideAndRemainder(BigInteger val)` |         除法，获取商和余数          |
|            `public boolean equals(Object x)`             |            比较是否相同             |
|            `public BigInteger(int exponent)`             |                次幂                 |
|       `public BigInteger max/min(BigInteger val)`        |           返回较大/较小值           |
|                 `public int intValue()`                  | 转为`int`类型整数，超出范围数据有误 |

使用说明：

* 加减乘除省略，对于`public BigInteger[] divideAndRemainder(BigInteger val)`返回的数组，索引0是商，1是余数。
* 对于`public BigInteger max/min(BigInteger val)`，返回的就是原对象，并没有创建新的对象。
* `public int invValue(BiigInteger val)`，如果值超出`int`取值范围，数据有误（不报错）。除了`int`类型之外，也可以转为其他数值类型，包括浮点型`xxxValue`，其中`xxx`就是需要的基本数值类型。

`BigInteger`底层存储方式：对于计算机而言，是没有数据类型的概念的，数据类型是编程语言自己规定的。在`BigInteger`中，利用`final int signum;`来表示符号，`signum`为1表示正数，为-1表示负数，为0表示0，然后将要存储的数值转为补码后，再以每32位为一组，再将每组补码转回10进制（32位，即4个字节，刚好是一个`int`型数字），存储在`final int[] mag;`数组中。

`BigInteger`存储上限：根据`BigInteger`的底层存储方式可知，它使用`int`数组存储数据，而数组的索引是有上限的，上限值为`Integer.MAX_VALUE`，即$2^{31} - 1$，`int`型数值的最大值。（不过达到这个数值几乎不太可能了）

#### BigDecimal

计算机中，小数运算不精确的问题：

```java
public class BigDecimalDemo {
    public static void main(String[] args) {
        System.out.println(0.09 + 0.01); // 0.09999999999999999
        System.out.println(0.216 - 0.1); // 0.11599999999999999
        System.out.println(0.226 * 0.01); // 0.0022600000000000003
        System.out.println(0.09 / 0.1); // 0.8999999999999999
    }
}
```

小数的存储：计算机中，数值的运算都是在二进制下进行，`float`和`double`等浮点型数据用于存储小数的比特位是有限的，当十进制的小数转为二进制时，其小数位数很有可能超出浮点型数据类型的存储位数（如下图），超出部分只能舍去。

![image-20260106151801918](https://gitee.com/triabin/img_bed/raw/master/2026/01/06/1c62091efcc0d8b204736358c858f220-image-20260106151801918.png)
<div style="clear: both;"></div>

在计算机项目开发中，有些场景对于数据的精确度有着很高的要求，例如银行、金融以及航空航天等，所以Java设计了`java.math.BigDecimal`类，用于高精度的小数运算以及表示很大的小数。

构造方法的使用说明：
* 对于`public BigDecimal(double val)`，不建议使用这个构造方法，因为`double`在存储阶段就有可能已经出现了谬误（位数超出截取问题），此时再用它来获取到的`BigDecimal`对象，只能是一个不准确的对象，因此和`BigInteger`一样，还是推荐使用`public BigDecimal(String val)`构造方法，更为简单易用。

  ```java
  import java.math.BigDecimal;
  
  public class BigDecimalDemo {
      public static void main(String[] args) {
          BigDecimal num1 = new BigDecimal(0.09);
          BigDecimal num2 = new BigDecimal(0.01);
          System.out.println(num1); // 0.0899999999999999966693309261245303787291049957275390625
          System.out.println(num2); // 0.01000000000000000020816681711721685132943093776702880859375
      }
  }
  ```
  
* 也可以通过静态方法`public static BigDecimal valueOf(long/double val)`获取实例。内存优化：如果传入`long`型，并且数值范围为`[0, 10]`，则可以直接返回提前创建好的对象（缓冲区/缓存），不会创建新对象。

* 如果要表示的数字不大，没有超出`double`的取值范围，建议使用静态方法，如果超出范围，建议使用构造方法。

常见成员方法：

|                            方法名                            |               说明               |
| :----------------------------------------------------------: | :------------------------------: |
|        `public static BigDecimal valueOf(double val)`        |             获取对象             |
|           `public BigDecimal add(BigDecimal val)`            |               加法               |
|         `public BigDecimal subtract(BigDecimal val)`         |               减法               |
|         `public BigDecimal multiply(BigDecimal val)`         |               乘法               |
|         `public BigDecimaol mdivide(BigDecimal val)`         |               除法               |
| `public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)` | 除法，指定保留小数位数和舍入模式 |

方法使用说明：
* `public static BigDecimal valueOf(double val)`，由于传入的不是`long`型数据，即使数值范围在`[0, 10]`，也不会直接返回缓存中的对象，而是先将其转为`String`型，再调用`public BigDecimal(String val)`构造方法。
* `public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)`，在JDK9已经标记为过时，因为考虑到舍入模式不应该定义在`java.math.BigDecimal`类中，于是将其单独定义为一个枚举类`java.math.RoundingMode`（枚举类为一种特殊的类，现在可以暂时理解为它的对象无法手动创建并且都是常量），并重新定义一个舍入模式为枚举对象的方法来完成同样的功能，方法为`public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)`，而关于`RoundingMode`中，也定义了几种舍入模式，常用的还是四舍五入`HALF_UP`。

`java.math.RoundingMode`枚举常量：

|   枚举常量    | 名称 |                             作用                             |
| :-----------: | :--: | :----------------------------------------------------------: |
|     `UP`      |向上舍入|                        向远离零的方向舍入。无论正负，都向数值变大的方向进一位。                        |
|    `DOWN`     |向下舍入|                         向接近零的方向舍入。无论正负，都向数值变小的方向舍弃。                         |
|   `CEILING`   |向正无穷大舍入|                      向正无穷方向舍入。正数时相当于UP，负数时相当于DOWN。                      |
|    `FLOOR`    |向负无穷大舍入|                      向负无穷方向舍入。正数时相当于DOWN，负数时相当于UP。                      |
|   `HALF_UP`   |四舍五入| 最经典的四舍五入。舍弃部分`>= 0.5`时向上(UP)，否则向下(DOWN)。 |
|  `HALF_DOWN`  |五舍六入| 舍弃部分`> 0.5`时向上(UP)，否则向下(DOWN)。0.5被舍弃。 |
|  `HALF_EVEN`  |四舍六入五成双| 银行家舍入法。若舍弃部分左边的数字是奇数，则HALF_UP；若是偶数，则HALF_DOWN。 |
| `UNNECESSARY` |不舍入|   断言操作结果是精确的，无需舍入。若需要舍入，则抛出`ArithmeticException`。   |

`BigDecimal`底层存储方式：由于一些小数的二进制很长很长，如果`BigDecimal`使用和`BigInteger`相同的方式来存储数据的话，操作起来效率较低切浪费内存，所以`BigDecimal`设计了一套自己的存储方案。`BigDeciaml`在创建对象的时候，都会将数值转为字符串，然后再将字符串拆分为一个个字符（包括负号`-`和小数点`.`），然后将这些字符转为ASCII码后，按照顺序存储到`byte`数组中。

`BigDecimal`存储的数值上限：与`BigInteger`一样，也是受限于数组的长度`Integer.MAX`，近乎无限。

### 9.6 正则表达式

在Java中关于正则表达式的应用参见[正则表达式（Java）](../common/正则表达式（Java）)。

### 9.7 时间日期类

> 关于时间的一些地理知识
>
> 以前，以地球0度经线位的时间为标准时间（本初子午线），英国伦敦的格林威（尼）治天文台就在这条线上，因此以前的世界时间也叫格林威治时间（Greenwich Mean Time，即**GMT**）。
>
> 对于地球上的每一个地方来说，太阳直射时为正午12点，地球上的时间需要一个统一的计算标准，而计算的核心就是地球的自转，地球自转一周是24小时，于是将地球从经度方向分为24个不同的时区，本初子午线所在时区为零时区，往西为西时区共12个，与本初子午线每差一个时区时间就早一个小时；往东为东时区也是12个，东西十二区重叠在一起（注意，重叠在一起，不代表时间相同，因为时间实际上是人为规定的），时区与本初子午线每差一个时区时间就往后晚一个小时。中国所使用的时间北京时间就是东八区时间，而东八区的标准时间实际上在上海，因此Linux系统或者一些地方表示中国时间的时候只能选`Asia/Shanghai`。
>
> 由于东西十二区重叠，为了避免该时区内的人日期混乱，于是规定了一条国际日期变更线（日界线），变更线东侧日期减一天，西侧日期加一天。为了避免同一个国家/地区两个时间的尴尬情况，该变更线从180度经线附近延伸出来后多处采用曲折走向避开陆地，并且也经过多次变更。
>
> 然而，实际上地球的自转并不是均匀的，这就会导致出现记录的实际时间与自转时间出现误差的情况，据统计，最大误差长达16分钟。
>
> 2012年1月，取消用了将近130年的格林威治标准时间，标准时间改为使用原子钟提供。原子钟是利用铯原子的震动频率计算出来的时间，作为世界标准时间（**UTC**），铯原子每震动9192631770次等于1秒。

需要了解的前置知识：

* 以前的标准时间为格林威治时间（Greenwich Mean Time，即**GMT**），现在的标准时间为原子钟提供的时间**UTC**。
* 中国处于东八区，时间为标准时间加8小时。
* 1秒＝1000毫秒，1毫秒＝1000微秒，1微秒＝1000纳秒
* 时间原点：`1970-01-01 00:00:00.000`

#### `Date`时间

`java.util.Date`是一个Java写好的JavaBean类，用来描述时间，精确到毫秒。利用空参构造创建对象，默认表示系统当前时间，利用有参构造则表示创建指定时间。

根据以上初步功能再结合之前学过的面向对象的设计，其实可以推测`Date`类的核心设计：定义一个字段来存储当前时间戳，空参构造使用`System.currentTimeMillis()`获取当前时间戳，有参构造则传入一个`long`型的数字。再配合存储时间戳的变量的`getter/setter`即可初步完成对`Date`类的设计与使用。事实上，`java.util.Date`类的设计确实差不多就是这样：

<img src="https://gitee.com/triabin/img_bed/raw/master/2026/01/06/227eb354150a62d7e9648a9b290fcf69-image-20260106172442407.png" alt="image-20260106172442407" style="zoom:80%;" align="left"/>

<div style="clear: both;"></div>

> 通过练习题熟悉这些方法特性的使用：
>
> 需求1：打印时间原点开始一年之后的时间。
>
> 需求2：定义任意两个`Date`对象，比较一下哪个时间在前，哪个时间在后。
>
> ```java
> import java.util.Date;
> import java.util.Random;
> 
> public class DateDemo {
>     public static void main(String[] args) {
>         solution1(); // 时间原点一年以后的时间为：Fri Jan 01 08:00:00 CST 1971
>         solution2();
>     }
> 
>     /**
>      * 题解1
>      */
>     public static void solution1() {
>         Date date = new Date(0L);
> 
>         long time = date.getTime() + 365 * 24 * 60 * 60 * 1000L;
>         date.setTime(time);
>         System.out.println("时间原点一年以后的时间为：" + date);
>     }
> 
>     public static void solution2() {
>         Random random = new Random();
>         long currentTime = System.currentTimeMillis();
>         Date date1 = new Date(random.nextLong(currentTime));
>         Date date2 = new Date(random.nextLong(currentTime));
>         if (date1.getTime() >  date2.getTime()) {
>             System.out.println("在前面的时间为：" + date2);
>             System.out.println("在后面的时间为：" + date1);
>         } else if (date2.getTime() >  date1.getTime()) {
>             System.out.println("在前面的时间为：" + date1);
>             System.out.println("在后面的时间为：" + date2);
>         } else {
>             System.out.println("时间相同：" + date1);
>         }
>     }
> }
> ```

关于`Date`类中的其他方法，不管是静态方法还是成员方法，都比较见名知意，属于一看就知道怎么用的那种，就不详细介绍了。

#### `SimpleDateFormat`格式化时间

从前面的联系中可以看到，默认的`Date`类`toString`方法返回的结果是不利于直接查看的`Fri Jan 01 08:00:00 CST 1971`，对于时间对象的使用，每个国家所需的显示标准是不一样的，而且在开发过程中，也有将字符串转为`Date`对象的需求，于是就设计了`java.text.SimpleDateFormat`来格式化或者解析时间。例，使用`SimpleDateFormat`可以将`Date`对象转为诸如`2017-09-01 08:56:16`、`2020年6月`这样格式的字符串，也可以将对应格式字符串转为`Date`对象。

|                 构造方法                  |                     说明                     |
| :---------------------------------------: | :------------------------------------------: |
|        `public SimpleDateFormat()`        | 构造一个`SimpleDateFormat`对象，使用默认格式 |
| `public SimpleDateFormat(String pattern)` | 构造一个`SimpleDateFormat`对象，使用指定格式 |

|                常用方法                 |            说明            |
| :-------------------------------------: | :------------------------: |
| `public final String format(Date date)` | 格式化（`Date -> String`） |
|   `public Date parse(String source)`    |  解析（`String -> Date`）  |

格式化的时间形式常用的模式对应关系：

* `y`：年，如果使用`yy`，则取后两位，如果是`yyyy`，则是完整的年份
* `M`：月，如果取`MM`，则月份小于10的时候，补0，`M`不补0
* `d`：日，日期在当前月份中的第几天，补0规则同上
* `H`：时，24小时制的时间，补0规则同上，如果是小写的`h`，则采用12小时制，使用12小时制时可以使用`a`来显示`AM/PM`（具体显示上下午的内容取决于系统语言，中文的话显示的是`上午/下午`）
* `m`：分，补0规则同上
* `s`：秒，补0规则同上
* `S`：毫秒，只需要一个`S`，就可以显示三位数的毫秒数，或者也可以使用`SSS`，这样不足位数的时候也会补0
* `E`：星期，会显示系统语言本地对于星期的名称，例如中文的`周几`

以上为开发过程中会用到的几乎全部匹配符了，如果还有其他需求，可以查阅JDK的API文档`java.text.SimpleDateFormat`。以下是关于它的基本使用演示：

```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class SDFDemo {
    public static void main(String[] args) throws ParseException {
        long currentTimeMillis = System.currentTimeMillis();
        System.out.println("当前时间戳：" + currentTimeMillis); // 1610005955415L

        // 创建Date对象
        Date date = new Date(currentTimeMillis);
        // 将其格式化为：yyyy-MM-dd HH:mm:ss
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format = sdf.format(date);
        System.out.println("格式化后的时间：" + format); // 2021-01-07 15:52:35
        // 将格式化后的字符串解析回去
        Date parse = sdf.parse(format);
        System.out.println("解析后的时间戳：" + parse.getTime()); // 1610005955000
    }
}
```

说明：上述时间戳前后不一致的原因是因为格式`yyyy-MM-dd HH:mm:ss`中不包含对毫秒数的格式化，导致了字符串转回日期对象的时候丢失了毫秒数，所以转换回来的时间戳最后三位全部归零。另外，在调用`parse`方法的时候，如果要解析的时间字符串与格式字符串格式不匹配，可能会抛出`ParseException`异常。

:::info Tips

① `SimpleDateFormat`中文系统语言下，默认的匹配模式为Windows系统：`yyyy/M/d aH:mm`，Unix系统：`yyyy/M/d HH:mm`，不过最好不要用这个，不确定性太强；

② 开发过程中最好在项目中规划好常用的几种格式化模式（例如`yyyy-MM-dd HH:mm:ss`、`yyyy/MM/dd`、`yyyy年MM月dd日 HH:mm:ss`等），然后将其作为常量规定好，之后所有人在使用时间格式化的时候都先去常量中找，找不到再考虑自定义或扩充常量，这样既能方便使用，又能统一项目中的时间格式化格式。

:::

#### `Calendar`日历

在有了`Date`类之后，关于日期的使用，又遇到了新的问题，比如，如果我只想给当前日期对象的月份加一，那样并不是简单的给时间戳加上`30 * 24 * 60 * 60 * 1000L`就行了的，还需要判断大小月份、是否为2月等一系列关于日历的复杂问题，于是就设计了`java.util.Calendar`日历类来专门解决这些问题。

`Calendar`代表了系统当前时间的日历对象，可以单独修改、获取时间中的年、月、日。此外，`Calendar`是一个抽象类，不能直接创建对象，只能通过它提供的静态方法`public static Calendar getInstance()`获取子类实例，并且这个静态方法还能通过传入对应的地区或者时区对象获取指定地区的日历实例，不传则获取系统所在地区的日历实例。

`public static Calendar getInstance()`底层实现细节：会根据系统时区来获取不同的日历对象（默认为当前时间），目前（截至JDK21）只有三个选项，分别是佛教日历`BuddhistCalendar`、日本历`JapaneseImperialCalendar`以及格林威治日历`GregorianCalendar`，一般都是返回第三个，会将时间中的纪元、年、月、日、时、分、秒、星期等信息都放到一个数组中。

常用方法：

|                   方法名                   |            说明             |
| :----------------------------------------: | :-------------------------: |
|       `public final Date getTime()`        |        获取日期对象         |
|     `public final setTime(Date date)`      |   给日历对象设置日期对象    |
|      `public long getTimeInMillis()`       |  获取日历日期的时间毫秒值   |
| `public void setTimeInMillis(long millis)` |    给日历设置时间毫秒值     |
|        `public int get(int field)`         |   获取日历中某个字段信息    |
|  `public void set(int field, int value)`   |   修改日历的某个字段信息    |
|  `public void add(int field, int amount)`  | 为某个字段增加/减少指定的值 |

使用说明：

* 关于日历对象中时间的获取与修改，可以通过`Date`对象来操作也可以通过时间戳来操作（即上表中的前四个方法）；

* `public int get(int field)`：对于属性的获取，传参虽然是一个数字（底层使用数组存放数据），但是一般不会使用数字字面量，而是已经在`Calendar`中定义了大量的`int`常量，这些常量名基本都见名知意。

  要关注的点：

    ① 月份的取值范围是`[0, 11]`，0表示1月（坑爹玩意儿😒）；

    ② 星期的数值，1为星期天，7为星期六（老外认为星期天是一周的起点）。

    ③ 常用的属性：`1:Calendar.YEAR`、`2:Calendar.MONTH`、`5:Calendar.DATE/Calendar.DAY_OF_MONTH`（开发者认为`DATE`不够见名知意就改了）、`7:Calendar.DAY_OF_WEEK`

* `public void add(int field, int amount)`，`amount`可以传负数，传入负数代表减。

> 由于时间相关的这三个类功能各异以及比较分散，项目中，一般会创建一个`DateUtils`之类的工具类，里面会整合三个类以及放置时间格式化所需格式常量等，以方便项目中关于时间的各种公共方法调用。
>
> 对于星期和月份的问题，可以定义类似这样的数组`String[] weeks = { "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" };`，然后就能直接将`Calendar`类返回的值与数组索引对应上了。

#### JDK8新增时间相关类

在之前的时间日期类使用中，对于两个时间字符串之间的比较，涉及到解析、以及格式化模式字符串这种魔法值的管理，最终比较还需要使用毫秒值进行比较。还有计算时间间隔也需要转为毫秒值再转为其他单位，操作过于繁琐。并且，对于`Date`对象的修改，如果在多线程情况下操作，还涉及到数据安全问题。于是JDK8中，重新设计了时间类，提供了比较先后、计算时间间隔等方法，并且创建时间类也是通过具体的年月日时分秒等整数类型。此外，为了解决线程安全问题，新设计的时间类创建的对象都是不可变的。

JDK8新增了10个时间相关的类，可以分为四个种类，时间日期类`Date`、格式化类`SimpleDateFormat`、日历类`Calendar`以及工具类。

① **时间日期类**：

* `java.time.ZoneId`：时区
  时区格式：`大洲英文名/城市英文名`，例如`Asia/Shanghai`、`Asia/Taipei`、`Asia/Chongqing`、`America/New_York`等。
  
  |                      方法名                       |           说明           |
  | :-----------------------------------------------: | :----------------------: |
  | `public static Set<String> getAvailableZoneIds()` | 获取Java中支持的所有时区 |
  |      `public static ZoneId systemDefault()`       |     获取系统默认时区     |
  |     `public static ZoneId of(String zoneId)`      |     获取一个指定时区     |
  
  使用说明：
  
  * `public static Set<String> getAvailableZoneIds()`，返回的是一个`java.util.Set`集合类对象，`Set`后续再学习，现在只需要知道他是一个类似于`ArrayList`的类即可，区别就是`ArrayList`元素可以重复而`Set`的元素不可以重复（重复添加无效），并且`Set`查找元素效率一般较高。
  *  `public static ZoneId of(String zoneId)`，如果传入的参数不在Java的支持列表中，则抛出`ZoneRulesException`异常，如果不指定时区ID，则报`DateTimeException`异常。
  
* `java.time.Instant`：时间戳

  |                      方法名                      |                  说明                   |
  | :----------------------------------------------: | :-------------------------------------: |
  |          `public static Instant now()`           | 获取当前时间的`Instant`对象（标准时间） |
  |  `public static Instant ofXxx(long epochMilli)`  |  根据（秒/毫秒/纳秒）获取`Instant`对象  |
  |    `public ZonedDateTime atZone(ZoneId zone)`    |                指定时区                 |
  |   `public boolean isXxx(Instant otherInstant)`   |             判断系列的方法              |
  | `public Instant minusXxx(long millisToSubtract)` |           减少时间系列的方法            |
  | `public Instant plusXxx(long millisToSubtract)`  |           增加时间系列的方法            |

  使用说明：

  * `public static Instant now()`获取到的是一个**不带时区的**标准时间。
  * `public static Instant ofXxx(long epochMilli)`，根据方法名见名知意，`ofEpochMilli(long epochMilli)`为通过毫秒值获取时间戳的方法，`ofEpochSecond(long epochSecond)`为通过秒获取时间戳的方法，`ofEpochSecond(long epochSecond, long nanoAdjustment)`为通过秒和纳秒获取时间戳对象的方法（若只想通过纳秒数获取，确保参数`epochSecond`为0即可）。
  * `public ZonedDateTime atZone(ZoneId zone)`，获取到一个没有时区的时间戳对象之后，调用这个方法可以返回一个带时区的`ZonedDateTime`对象。
  *  `public boolean isXxx(Instant otherInstant)`，与传统的`Date`对象一样，主要有两个方法`isAfter`和`isBefore`，用于判断时间先后的。
  * `minusXxx`和`plusXxx`都有三个方法，分别是纳秒、毫秒和秒，用于增减时间，由于`Instant`对象不可变，因此操作后返回的是一个新的对象。

* `java.time.ZonedDateTime`：带时区的时间

  |                方法名                 |                         说明                          |
  | :-----------------------------------: | :---------------------------------------------------: |
  |  `public static ZonedDateTime now()`  |           获取当前时间的`ZoneDateTime`对象            |
  | `public static ZonedDateTime of(...)` | 重载了多个方法，用于获取指定时间的`ZonedDateTime`对象 |
  | `public ZonedDateTime withXxx(时间)`  |                  修改时间系列的方法                   |
  | `public ZonedDateTime minusXxx(时间)` |                  减少时间系列的方法                   |
  |  `public ZoneDateTime plusXxx(时间)`  |                  增加时间系列的方法                   |

  使用说明：

  * `public static ZonedDateTime of(...)`，参数列表可以传递时分秒和时区以及`LocalDate`系列值以及`Instant`值等来获取指定时间的`ZonedDateTime`对象，总之见名知意即可。
  * `public ZonedDateTime withXxx(时间)`，修改年月日时分秒等一系列的参数，具体看参数列表和`with`后面的单词，都是见名知意的。由于`ZonedDateTime`对象一经创建不可更改，所以修改后会返回一个新的对象。
  * `public ZonedDateTime minusXxx(时间)`与`public ZoneDateTime plusXxx(时间)`一样，具体增减的值也都是看`Xxx`具体是哪个单词。由于`ZonedDateTime`对象一经创建不可更改，所以修改后会返回一个新的对象。

② **日期格式化类**：

* `java.time.format.DateTimeFormatter`：用于时间的格式化和解析

  |                           方法名                            |        说明        |
  | :---------------------------------------------------------: | :----------------: |
  | `public static DateTimeFormatter ofPattern(String pattern)` |    获取格式对象    |
  |                   `public String format`                    | 按照指定方式格式化 |

③ **日历类**：

* `java.time.LocalDate`：年、月、日
* `java.time.LocalTime`：时、分、秒
* `java.time.LocalDateTime`：年、月、日、时、分、秒

三个类常用方法：

|           方法名            |                   说明                   |
| :-------------------------: | :--------------------------------------: |
|  `public static Xxx now()`  |            获取当前时间的对象            |
| `public static Xxx of(...)` |            获取指定时间的对象            |
|       `get`开头的方法       | 获取日历中的年、月、日、时、分、秒等信息 |
|    `isBefore`、`isAfter`    |        比较两个对象代表的时间先后        |
|        `with`开头的         |            修改时间系列的方法            |
|      `plusminus`开头的      |            增减时间系列的方法            |

`LocalDateTime`转为`LocalDate`和`LocalTime`的方法：

|              方法名              |                说明                |
| :------------------------------: | :--------------------------------: |
| `public LocalDate toLocalDate()` | `LocalDateTime`转为`LocalDate`对象 |
| `public LocalDate toLocalTime()` | `LocalDateTime`转为`LocalTime`对象 |

④ **工具类**：

* `java.time.Duration`：时间间隔（秒、纳秒）

  ```java
  public class DurationDemo {
      public static void main(String[] args) {
          // 当前本地年月日
          LocalDateTime now = LocalDateTime.now();
          System.out.println("现在：" + now);
          // 生日
          LocalDateTime birthday = LocalDateTime.of(1998, 5, 2, 0, 28, 53, 822324);
          System.out.println("生日：" + birthday);
          // 计算年龄
          Duration duration = Duration.between(birthday, now);
          System.out.println("Duration: " + duration);
          System.out.println("天数：" + duration.toDays());
          System.out.println("小时数：" + duration.toHours());
          System.out.println("分钟数：" + duration.toMinutes());
          System.out.println("秒数：" + duration.getSeconds());
          System.out.println("毫秒数：" + duration.toMillis());
          System.out.println("纳秒数：" + duration.toNanos());
      }
  }
  ```

  

* `java.time.Period`：时间间隔（年、月、日）

  ```java
  public class PeriodDemo {
      public static void main(String[] args) {
          // 当前本地年月日
          LocalDate today = LocalDate.now();
          System.out.println("今天：" + today);
          // 生日
          LocalDate birthday = LocalDate.of(1998, 5,2);
          System.out.println("生日：" + birthday);
          // 计算年龄
          Period period = Period.between(birthday, today);
          System.out.println("Period: " + period);
          System.out.println("年龄：" + period.getYears());
          System.out.println("月数：" + period.getMonths());
          System.out.println("天数：" + period.getDays());
  
          System.out.println("总月数：" + period.toTotalMonths());
      }
  }
  ```

* `java.time.temporal.ChronoUnit`：时间单位枚举（所有单位），并且提供了计算时间差的方法

  ```java
  public class ChronoUnitDemo {
      public static void main(String[] args) {
          // 当前本地年月日
          LocalDateTime now = LocalDateTime.now();
          System.out.println("现在：" + now);
          // 生日
          LocalDateTime birthday = LocalDateTime.of(1998, 5, 2, 0, 28, 53, 822324);
          System.out.println("生日：" + birthday);
          // 计算时间差
          System.out.println("相差的纪元数：" + ChronoUnit.ERAS.between(birthday, now));
          System.out.println("相差的千年数：" + ChronoUnit.MILLENNIA.between(birthday, now));
          System.out.println("相差的世纪数：" + ChronoUnit.CENTURIES.between(birthday, now));
          System.out.println("相差的十年数：" + ChronoUnit.DECADES.between(birthday, now));
          System.out.println("相差的年数：" + ChronoUnit.YEARS.between(birthday, now));
          System.out.println("相差的月数：" + ChronoUnit.MONTHS.between(birthday, now));
          System.out.println("相差的周数：" + ChronoUnit.WEEKS.between(birthday, now));
          System.out.println("相差的天数：" + ChronoUnit.DAYS.between(birthday, now));
          System.out.println("相差的小时数：" + ChronoUnit.HOURS.between(birthday, now));
          System.out.println("相差的分钟数：" + ChronoUnit.MINUTES.between(birthday, now));
          System.out.println("相差的秒数：" + ChronoUnit.SECONDS.between(birthday, now));
          System.out.println("相差的毫秒数：" + ChronoUnit.MILLIS.between(birthday, now));
          System.out.println("相差的微秒数：" + ChronoUnit.MICROS.between(birthday, now));
          System.out.println("相差的纳秒数：" + ChronoUnit.NANOS.between(birthday, now));
      }
  }
  ```

### 9.8 包装类

![image-20260109142609483](https://gitee.com/triabin/img_bed/raw/master/2026/01/09/0cfbb34ed7dd4ba17d9d92d3c3ed2b10-image-20260109142609483.png)

<div style="clear: both;"></div>

在Java中，万物皆对象，然而八大基本数据类型却是例外，它们的数据存储在栈内存中，不利于集合的存储，也不利于离散堆内存的使用，于是就为每一个基本数据类型设计了一个用来描述它的类，这些类就是包装类（包装类作为基础类，都存放在`java.lang`包下）。

|  byte  |  short  |    int    |  long  |  float  |  double  |  boolean  |    char     |
| :----: | :-----: | :-------: | :----: | :-----: | :------: | :-------: | :---------: |
| `Byte` | `Short` | `Integer` | `Long` | `Float` | `Double` | `Boolean` | `Character` |

可以看得出来，除了`int`和`char`的包装类名字特殊一点外，其余标桩类均为基本数据类型首字母大写即可。以后使用最多的类为`java.lang.Integer`，因此以它来举例讲解即可，其余都大同小异。

获取`Integer`对象的方式（JDK5以前，JDK5做了优化，因此了解即可）：

|                        方法名                        |                    说明                     |
| :--------------------------------------------------: | :-----------------------------------------: |
|             `public Integer(int value)`              |     根据传递的整数创建一个`Integer`对象     |
|              `public Integer(String s)`              |    根据传递的字符串创建一个`Integer`对象    |
|        `public static Integer valueOf(int i)`        |     根据传递的整数创建一个`Integer`对象     |
|      `public static Integer valueOf(String s)`       |    根据传递的字符串创建一个`Integer`对象    |
| `public static Integer valueOf(String s, int radix)` | 根据传递的字符串和进制创建一个`Integer`对象 |

**缓冲区/缓存**：与`BigDecimal`和`BigInteger`一样，`Integer`也有缓冲区的概念，它的缓存范围为`[-128, 127]`，也是调用`valueOf`方法的时候会优先走缓存，如果在这个区间内的值，就直接返回静态代码块中初始化的值。

**自动拆/装箱（JDK5优化）**：之前对于包装类的运算，需要先将其转为基本数据类型，运算结束后再将结果转为包装类，这使得包装类的使用非常麻烦，于是就引入了自动装箱和自动拆箱的概念。

* 自动装箱：把基本数据类型自动变成对应的包装类，例，`Integer i = 10;`等价于`Integer i = Integer.valueOf(10);`。
* 自动拆箱：把包装类自动变成对应的基本数据类型，例，`int i = new Integer(10);`等价于`int i = new Integer(10).intValue();`。

由于自动拆/装箱的引入，JDK5以后，`Integer`和`int`基本可以看成是同一个东西。

`Integer`成员方法：

|                    方法名                    |                 说明                  |
| :------------------------------------------: | :-----------------------------------: |
| `public static String toBinaryString(int i)` |              得到二进制               |
| `public static String toOctalString(int i)`  |              得到八进制               |
|  `public static String toHexString(int i)`   |             得到十六进制              |
|    `public static int parseInt(String s)`    | 将字符串类型的整数转为`int`类型的整数 |

## 10、常见算法

Java语言特性学习到这里，已经可以利用它去学习数据结构与算法了，甚至上[力扣](https://leetcode.cn/)去刷算法题，为了方便后续的学习，建议系统的学习数据结构与算法的知识后再学习后续内容（当然，就算不学习也能看都后续内容），至少了解一下数组与链表、栈与队列、哈希表、树、堆、图等数据结构对于后续的学习会更加轻松，以及更加容易理解“JDK的开发团队为什么这样设计”。数组与链表以及栈与队列等都比较容易理解，基本上都能一句话说清楚，但是哈希表与堆的设计就需要一定的理解了，这对于后续的优先级队列`java.util.PriorityQueue`（涉及到堆）和集合中的`java.util.HashMap`（涉及到树与哈希表以及链表）以及`java.util.HashSet`（涉及到哈希表）的底层实现逻辑的理解都有很重要的作用。

关于数据结构与算法的学习，推荐我见过的最简单易学的一个项目：[krahets/hello-algo](https://github.com/krahets/hello-algo)，可以直接下载他的Java版PDF文档学习。（提示：截至`hello-algo_1.3.0`版本，还没有加入`KMP`算法，该算法是用于字符串匹配的）

### 10.1 复杂度

算法效率评估：在算法的设计中，首先需要找到问题的解法，在这个基础上再找到算法的最优解法，即找到尽可能高效的解法。在能够解决问题的前提下，算法效率就是衡量算法优劣的主要评价指标，它包括两个维度：

* 时间效率：算法运行时间的长短。
* 空间效率：算法占用内存空间的大小。

#### 时间复杂度

时间复杂度并不是要去统计算法的具体运行时间，因为这既不合理也不现实，算法在不同的编程语言、不同的操作系统、不同的运行环境下，最终的运行时间是不一样的，并且代码中具体的操作，例如加减乘除、移位、打印等操作的时间也各不相同，因为很难获悉每种操作的运行时间，这给预估的过程带来了极大的困难，并且如果将算法的复杂度与编程语言/环境/系统绑定，那么复杂度的意义将大大减小。

> 一些常规操作耗时：`+`需要1纳秒，`*`需要10纳秒，打印需要5纳秒。

时间复杂度分析统计的不是算法运行时间，**而是算法运行时间随着数据量变大时的增长趋势**。举例：

```java
// 算法 A 的时间复杂度：常数阶
void algorithm_A(int n) {
	System.out.println(0);
}
// 算法 B 的时间复杂度：线性阶
void algorithm_B(int n) {
    for (int i = 0; i < n; i++) {
    	System.out.println(0);
    }
}
// 算法 C 的时间复杂度：常数阶
void algorithm_C(int n) {
    for (int i = 0; i < 1000000; i++) {
    	System.out.println(0);
    }
}
```

* 算法`A`只有一个打印操作，不管输入的数据`n`是多少，算法都只执行固定的次数即可结束，这样的时间复杂度称为“常数阶”
* 算法`B`中打印操作需要执行`n`次，算法的运行时间随着输入数据`n`的增大呈线性增长，这样的时间复杂度称为“线性阶”
* 算法`C`中打印操作需要执行一百万次，且不管输入的数据`n`是多少，算法都只执行固定的次数`1,000,000`，所以时间复杂度也是“常数阶”

相较于直接统计算法的运行时间，时间复杂度的分析能够摒弃外在的代码运行环境影响，有效地评估算法效率，并且简化了算法的推算过程，简单地将所有计算操作的执行时间都视为相同的“单位时间”（反正都是常数）。

局限性：由于脱离了实际的执行过程，对于算法实际执行效率的把控降低。例如上述算法中，`B`和`C`，尽管`C`的算法复杂度比`B`高，但是当输入数据量`n < 1000000`时，算法`B`的实际执行效率是高于算法`C`的。

给定一个输入大小为`n`的函数：

```java
void algorithm(int n) {
    int a = 1; // +1
    a = a + 1; // +1
    a = a * 2; // +1
    // 循环 n 次
    for (int i = 0; i < n; i++) { // +1（每轮都执行 i ++）
    	System.out.println(0); // +1
    }
}
```

设算法的操作数量是一个关于输入数据大小`n`的函数，记为$T(n)$，则以上函数的操作数量为：
$$
T(n) = 3 + 2n
$$
$T(n)$ 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度也是线性阶。

线性阶的时间复杂度记为$O(n)$，这个数学符号称为大`𝑂`记号（big‑𝑂 notation），表示函数 $𝑇(𝑛)$ 的**渐近上界**（asymptotic upper bound）。时间复杂度分析本质上是计算“操作数量 $𝑇(𝑛)$”的渐近上界，它具有明确的数学定义：若存在正实数 $c$ 和实数 $n_{0}$，使得对于所有的 $n > n_{0}$，均有 $T(n) \leq c \cdot f(n)$，则可认为 $f(n)$ 给出了 $T(n)$ 的一个渐进上界，记为 $T(n) = O(f(n))$。

例如$T(n) = 3 + 2n$，一定存在正实数$c$和实数$n_{0}$使得在$n > n_{0}$区间上，$3 + 2n \leq c \cdot n$，所以$f(n) = n$其实就是$f(n) = 3 + 2n$的一个渐进上界，记为$T(n) = O(n)$。

计算渐进上界就是寻找一个函数$f(n)$，使得当$n$趋于无穷大时，$T(n)$ 和 $f(n)$ 处于相同的增长级别，仅相差一个常数系数$c$。

> 例：
>
> <img src="https://gitee.com/triabin/img_bed/raw/master/2026/01/12/190f1d28155cdb7bf72092581fc4b23d-image-20260112215220833.png" alt="image-20260112215220833" style="zoom:80%;" />
>
> <div style="clear: both;"></div>
>
> 如图，坐标系中，当$n > n_{0}$ 时，始终有 $c \cdot f(n) \geq T(n)$，此时可以认为 $f(n)$ 是 $T(n)$ 的一个渐进上界，记为 $T(n) = O(f(n))$。

**推算方法**：总体分为两步，首先统计操作数量，然后判断渐进上界。

* 第一步，统计操作数量，逐行从上到下统计即可，由于 $c \cdot f(n)$ 中的常数系数c可以取任意大小，因此操作数量 $T(n)$ 中的各种系数、常数项都可以忽略，因此有以下简化技巧：

  ① 忽略 $T(n)$ 中的常数，因为它们都与n无关，所以对时间复杂度不产生影响。

  ② 省略所有系数。例如，循环 $2n$ 次、$5n+1$ 次等，都可以简化记为n次，因为n前面的系数对时间复杂度没有影响。

  ③ 循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用`①`和`②`中的技巧。

* 第二步，判断渐进上界，时间复杂度由 $T(n)$ 中最高阶的项来决定。因为在n趋于无穷大时，最高阶的项将发挥主导作用，其他的项影响都可以忽略。

  以下为不同操作数量对应的时间复杂度：

  | 操作数量$T(n)$       | 时间复杂度$O(f(n))$ |
  | -------------------- | ------------------- |
  | 100000               | $O(1)$              |
  | $3n+2$               | $O(n)$              |
  | $2n^2+3n+2$          | $O(n^2)$            |
  | $n^3+10000n^2$       | $O(n^3)$            |
  | $2^n+10000n^{10000}$ | $O(2^n)$            |

> 例举：给定以下函数，推断其时间复杂度。
>
> ```java
> void algorithm(int n) {
>     int a = 1; // 1
>     a = a + 1; // 1
>     // 5n+1
>     for (int i = 0; i < 5 * n + 1; i++) {
>         System.out.println(0);
>     }
>     // 2n(n+1)
>     for (int i = 0; i < 2 * n; i++) {
>         for (int j = 0; j < n + 1; j++) {
>             System.out.println(0);
>         }
>     }
> }
> ```
>
> ① 统计操作数量
> $$
> \begin{aligned}
> T(n) &= 1 + 1 + (5n + 1) + 2n(n + 1) & \text{统计操作数量}\\
>  &= 2n^2 + 7n + 3 \\
> T(n) &= 2n^2 + 7n & \text{忽略常数} \\
> T(n) &= n^2 + n & \text{省略所有系数}
> \end{aligned}
> $$
> ② 判断渐进上界
> $$
> \begin{aligned}
> T(n) &= n^2 + n & \text{最高项为n平方} \\
> T(n) &= O(n^2) & \text{复杂度为}O(n^2)
> \end{aligned}
> $$

**常见的复杂度类型**：设输入数据大小为n，常见的时间复杂度类型如下图所示（按照从低到高的顺序排列）。

<img src="https://gitee.com/triabin/img_bed/raw/master/2026/01/12/57215b1b62ca846236cf2c804394b3d5-image-20260112224757386.png" alt="image-20260112224757386" style="zoom:80%;" />

<div style="clear: both;"></div>

$$
\begin{aligned}
O(1) < O(logn) < O(n) < O(n \cdot logn) < O(n^2) < O(2^n) < O(n!) \\
常数阶 < 对数阶 < 线性阶 < 线性对数阶 < 平方阶 < 指数阶 < 阶乘阶
\end{aligned}
$$

:::warning 说明

① 由于对数可以在不影响复杂度的前提下换底（数学关系：$O(log_mn) = O(\frac{log_kn}{log_km}) = O(log_kn)$），所以通常会直接省略底数，直接将对数阶记为 $O(logn)$。 

② 时间复杂度只代表了算法的一种增长趋势，并不表示算法的实际运算次数函数，例如二分法法查找数据的复杂度为对数阶，但是要查找的数据可以第一次比较就找到了，也有可能最后一次比较才找到，只是如果多次运行，取其平均值接近对数阶而已，因此算法的复杂度还有最差、最佳、平均复杂度三个指标。

:::

#### 空间复杂度

空间复杂度的推算方法与时间复杂度大致相同，只需将统计对象从“操作数量”转为“使用空间大小”。

而与时间复杂度不同的是，我们通常只关注最差空间复杂度。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。

**常见类型**：设输入数据大小为n，常见的空间复杂度类型如下图所示（按照从低到高的顺序排列）。

![image-20260112230604480](https://gitee.com/triabin/img_bed/raw/master/2026/01/12/df56706818d76aacc234c0b8a1b29eea-image-20260112230604480.png)

<div style="clear: both;"></div>

$$
\begin{aligned}
O(1) < O(logn) < O(n) < O(n^2) < O(2^n) \\
常数阶 < 对数阶 < 线性阶 < 平方阶 < 指数阶
\end{aligned}
$$


**权衡时间与空间**：理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优，然而在实际情况中，同时优化时间复杂度和空间复杂度通常非常困难。**降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然。** 我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”，反之则称为“以时间换空间”。选择哪种思路取决于我们更看重哪个方面。**在大多数情况下（尤其现如今硬件成本更低的市场情况），时间比空间更宝贵，因此“以空间换时间”通常是更常用的策略。**当然，在数据量很大的情况下，控制空间复杂度也非常重要。

#### 迭代与递归

在算法中，重复执行某个任务是很常见的，它与复杂度息息相关，从前面时间和空间复杂度的计算来看，主要计算的就是重复执行的地方，其余步骤均算作常数阶，所以必须要掌握编程中常见的用于重复执行某个任务的基本控制结构——迭代、递归。

迭代其实在之前学习循环控制语句的时候已经使用过了，至于递归则是一种特殊的循环，本质是在方法体中调用本方法，这是一个非常非常重要的编程思想，不管是遍历不知结构的JSON对象还是前端中页面结构的Node节点，都非常实用。

关于迭代（iteration），它是一种重复执行某个任务的控制结构，在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。详见[3.3 循环结构](#33-循环结构)，这一节主要介绍递归。

**递归**（recursion）是一种算法策略，通过函数调用自身来解决问题，它分为两个阶段：

* 递，程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到**终止条件**。
* 归，触发终止条件后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

递归代码主要包含三个元素：

* 终止条件：用于决定什么时候由“递”转“归”。
* 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。
* 返回结果：对应“归”，将当前递归层级的结果返回至上一层。

例，计算`1+2+3+...+n`：

```java
int recur(int n) {
    // 终止条件
    if (n == 1) {
        return 1;
    }
    // 递：递归调用
    int res = recur(n - 1);
    // 归：返回结果
    return n + res;
}
```

从方法体来看，方法一直调用自己，每次在方法体内调用自己的时候都传入更小的参数`n-1`，直到`n = 1`，触发终止条件，开始一层一层的返回计算结果。当然这个求和方法也可以使用迭代来达成相同的效果，但是它们却是代表了两种完全不同的思考和解决问题的范式。

```java
// 使用迭代改写上述求和方法
int iterSum(int n) {
    int sum = 0;
    for (int i = 0; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```

**迭代与求和的区别**：

* 解决问题的思路上，迭代是”自下而上“地解决问题，从最基础的步骤开始，然后不断重复累加这些步骤，直到任务完成，例如上述求和方法，不断地从0累加到n，得到求和结果；递归则是“自上而下”地解决问题，将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式，接下来将子问题分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的），例如上述的递归求和，求`0~n`的和可以分解为求`n + (0 ~ n-1)`的和，`0~n-1`的和又可以分解为求`(n-1) + (0 ~ n-2)`的和，如此不断重复，直到求`0~1`的和为1，开始逐层返回计算结果。
* 内存上，递归通常比迭代更加耗费内存空间，因为递归会不断调用自身，在触及终止条件之前，所有的方法都在栈空间中不断堆积，而跌的所占用的内存通常在第一次循环结束时就已经确定并且不会再在迭代体内增加，因此在使用递归时明确终止条件非常非常重要，否则容易栈溢出。因为递归调用方法的额开销也导致了递归通常比迭代的时间效率更低，所以一般能用迭代就尽量用迭代，递归多用于一些注重子问题分析的情景，例如树、图、分治、回溯等，代码结构简洁清晰。

::: info Tips

关于递归的使用，目前主要用在遍历一些不确定深度的数据结构上，例如给定一个JSON对象，你不确定它有哪些属性，属性是JSONObject还是JSONArray还是别的数据类型，但是对于JSONObject和JSONArray又需要同样的处理方式，这时候既不知道这个对象“有多深”，又需要确保整个对象的每个字段都需要遍历到，就很适合使用递归而不是迭代了。

:::

### 10.2 查找算法

基本查找：本质其实就是暴力查找，即按照顺序逐步遍历所有元素（没什么好说的），时间复杂度为$O(n)$。

二分/折半查找：是对有序的线性数据进行的查找，每次查找都将查找范围缩小一半，直到找到目标值或查找范围为空，时间复杂度为$O(logn)$。以下为一般步骤（以从小到大的有序数组为例）：

* 定义`left`和`right`表示查找范围的左右边界，起始值分别为0和数组长度-1；
* 计算$mid = \frac{left + right}{2}$，将索引为`mid`的元素与目标值进行比较；
* 如果相等，则找到目标值，搜索结束；
* 如果小于目标值，则代表目标值在`mid`右侧，将`left`设为`mid + 1`，继续上述操作；
* 如果大于目标值，则代表目标值在`mid`左侧，将`right`设为`mid - 1`，继续上述操作；
* 如果`left`已经大于`right`（`left = right`的时候也要继续查找），还未找到目标值，则代表查找值不在数组中，搜索结束。

```java
// 二分法查找代码演示
public int binarySearch(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
```

二分查找法的局限性：

* 数据必须是有序的，如果元数据是无需的，将其排序后再查找只能确定目标值是否存在，而找不到它在原数据中的位置；
* 如果有重复元素，二分法找到的也不一定是第一个匹配的元素，有可能找到后面的元素。

插值查找：对于那些取值分布比较均匀的有序数组，在使用二分查找的时候中间值可以不用每次都取$mid = \frac{left + right}{2}$，而是可以通过目标值`key`和数组最大最小值进行初步估计，从而快速缩小查找范围，插值公式为：
$$
mid = min + \frac{key - arr[min]}{arr[max] - arr[min]} \cdot (max - min)
$$


> 注意：如果数据分布均匀，通常情况下，插值查找的时间复杂度能达到 $O(loglogn)$，但是如果在取值分布不均匀的数据中使用，插值查找效率可能会低于二分查找，并且插值查找最差时间复杂度为$O(n)$，即每次插值都没提前命中目标，直到遍历完整个数组。

斐波那契查找：对于二分法查找中的这个`mid`（查找点）的取值，除了插值，还有一种稳定的取值方法，取黄金分割点来分割查找范围，即 $mid = min + 黄金分割点左边边长度 - 1$。

二分法、插值法核斐波那契法比较：

|      特性      |       二分法查找（Binary Search）        |              插值查找法（Interpolation Search）              |        斐波那契查找（Fibonacci Search）        |
| :------------: | :--------------------------------------: | :----------------------------------------------------------: | :--------------------------------------------: |
|    核心原理    |     总是从待查找范围的正中间开始比较     |   根据目标值在查找范围内的相对位置，按比例预测其可能所在点   |  利用斐波那契数列（黄金分割比）来分割查找范围  |
|   查找点公式   |     $mid = \frac {left + right}{2}$      | $mid = min + \frac{key - arr[min]}{arr[max] - arr[min]} \cdot (max - min)$ | $mid = left + F(k-1) - 1$ （F为斐波那契数列）  |
| 平均时间复杂度 |                $O(logn)$                 |                如果数据均匀分布：$O(loglogn)$                |                   $O(logn)$                    |
| 最坏时间复杂度 |                $O(logn)$                 |                            $O(n)$                            |                   $O(logn)$                    |
|  数据分布要求  |           不敏感，只要有序即可           |          高度敏感，要求数据均匀分布才能达到最佳性能          |              不敏感，只要有序即可              |
|      优点      |       稳定性强，通用性强，易于实现       |             在数据量大且分布均匀时，平均性能出色             | 分割操作只涉及加减法，在某些环境下效率可能更高 |
|      缺点      | 查找点选择固定，在均匀数据中可能不是最快 |             护具分布不均时性能可能远低于二分查找             |      实现相对复杂，需要预处理斐波那契数列      |

分块查找：在实际的数据中，完全无序和完全有序的数据都比较少见，并且一些数据需要**多次查找**，于是就为此设计分块查找算法。将数据分为多块（block），每一个块中的数据是无序的，但是块与块之间是有序的，这样之后每次查找某个元素的时候先确定它在哪一个块，然后在到指定块中挨个查找即可。具体实现：

* 一般分为 `数字个数开根号` 个块，例如，16个数字分为4块左右。

* 为块设计一个对象来记录块信息：

  ```java
  class Block {
      private int startIndex;
      private int endIndex;
      private int max;
      // ...
  }
  ```

* 分块并存储块就相当于建立了索引表，然后将索引表和目标值以及目标数组传入并查找即可

> 说明：虽然分块查找单次搜索的时间复杂度很差（肯定超过了$O(n)$），并且实现也比较复杂（分块和查找），但是如果对同一数据进行多次查找，那么总体的时间复杂度是要远高于 $O(n)$ 的，因为分块操作实际上只需要分一次，之后可以反复使用。
>
> 基于分块查找的这种思想，之后还演化出了哈希查找，这里就不详述了。

### 10.3 排序算法

详见[十大排序算法（Java实现） ](../common/十大经典排序算法)

### 10.4 常见算法的API-Arrays

`java.util.Arrays`类为JDK为数组专门设计的一个工具类，因此该类无法创建对象，主要提供一些静态方法对数组进行操作。（Java提供的工具类一般都是叫做`Xxxs`，以`s`结尾，例如集合的工具类`java.util.Collections`，而不是`XxxUtils`，当然，这并不绝对）

常用方法：

|                            方法名                            |           说明           |
| :----------------------------------------------------------: | :----------------------: |
|            `public static String toString(数组)`             |  把数组拼接成一个字符串  |
|      `public static int binarySearch(数组, 目标元素值)`      |      二分法查找元素      |
|       `public static int[] copyOf(原数组, 新数组长度)`       |         拷贝数组         |
| `public static int[] copyOfRange(原数组, 起始索引, 结束索引)` |   拷贝数组（指定范围）   |
|            `public static void fill(数组, 元素)`             |         填充数组         |
|               `public static void sort(数组)`                | 按照默认方式进行数组排序 |
|          `public static void sort(数组, 排序规则)`           |    按照指定的规则排序    |

使用说明：

* `public static String toString(数组)`，没什么好说的，只是为各种数据类型重载了该方法，引用数据类型则是调用其自身`toString`方法。

* `public static int binarySearch(数组, 目标元素值)`，对于数组的要求不仅仅是有序，还要求是升序。另外，如果目标元素存在，则返回对应索引，不存在，则返回 `-目标元素插入点-1`，目标元素插入点即是如果数组中存在该元素，该元素应该放置的位置（升序），而之所以要用负的插入点再减1，是因为如果插入点为0，返回一个`-0`就有问题，于是就将其减1。

* `public static int[] copyOf(原数组, 新数组长度)`，底层调用的是`System.arraycopy`，如果新数组长度小于老数组长度，将会按照顺序部分拷贝，如果大于老数组长度，多于位置元素将使用默认初始化值。

* `public static int[] copyOfRange(原数组, 起始索引, 结束索引)`，拷贝的范围为`[from, to)`，包头不包尾，包左不包右。

* `public static void fill(数组, 元素)`，将数组中的所有元素覆盖填充为指定的元素值。

* `public static void sort(数组)`，默认情况下，给基本数据类型进行升序排序，底层使用的是快速排序。

* `public static void sort(数组, 排序规则)`，只能给引用数据类型的数组进行排序，基本数据类型使用包装类。排序规则是一个`Comparator`接口，底层利用插入排序和二分查找法进行排序，默认把0索引的数据当做是有序的序列，1索引以后部分认为是无序的序列。操作步骤：

  ① 遍历无序序列（1索引以后的部分）中的每一个元素（假设为A），对每一个元素进行插入排序处理；

  ② 将A元素往有序序列中进行插入，在插入的时候，利用二分查找确定A元素插入点；

  ③ 将A元素与插入点的元素进行比较，比较规则就是`Comparator`接口中的`int compare(T o1, T o2)`方法（该方法方法体由我们自定义，参数`o1`为A，参数`o2`为有序序列中的元素）；

  ④ 如果返回负数，则A继续跟插入点前面的数据进行比较； 如果返回正数，则A继续跟插入点后面的数据进行比较；如果返回0，也拿着A跟后面的数据进行比较，直到能确定A的最终位置为止。评判标准是：负数表示当前要插入的元素是小的，放在前面，正数表示当前要插入的元素是大的，放在后面，为0表示当前要插入的元素等于当前元素，要放在后面（所以返回0时才要继续往后比较）。

  **简单记忆:** `o1-o2`为升序，`o2-o1`为降序。

:::warning 注意

`Arrays`中有一个方法使用非常广泛——`public static <T> List<T> asList(T... a)`，作用是将数组转为`List`，但是一定一定要注意，该方法方法体虽然是`return new ArrayList<>(a);`，但是这里的`ArrayList`不是`java.util.ArrayList`，而是`Arrays`内部自己定义的一个私有静态类，这个类的集合对象不能被修改，因此如果有类似的需求，请务必写成`List<Xxx> list = new ArrayList<>(Arrays.asList(...));`这样的形式（使用还挺广泛的）。

:::

## 11、集合

数组的弊端：

* 长度一旦确定，不管索引位置上是否需要存放数据都需要占用内存空间，并且长度一旦固定就不可变；
* 只能使用连续的内存区域，对于那些离散的、分布在物理内存各个位置的空间无法很充分的使用；
* 一个数组只能存放一种数据类型（当然，这应该算优点）。

集合与数组区别：

* 数组可以存基本数据类型和引用数据类型，集合只能存储引用数据类型；
* 数组长度固定，集合长度可变

### 11.1 Java中集合的体系结构

![image-20260115173710728](https://gitee.com/triabin/img_bed/raw/master/2026/01/15/df5e93e64ebfc88cf64daa79bcd782ed-image-20260115173710728.png)

<div style="clear: both;"></div>

Java中有很多种集合，但是总体上可以分为两类，以`java.util.Collection`接口为首的单列集合和以`java.util.Map`接口为首的双列集合。

单列集合：每次添加元素只有一个元素，或者说加入的数据只有“一列”

双列集合：每次添加元素都是一个键值对，加入的数据有“两列”

### 11.2 Collection系列集合

以下为`java.util.Collection`接口在JDK中的实际继承关系图：

<img src="https://yanglukuan.github.io/images/arrayList/Collections.png" alt="Java集合框架"/>

<div style="clear: both;"></div>

但是我们暂时需要学的只有两大类，一个是`java.util.List`接口下的，一个是`java.util.Set`接口下的：

![image-20260115184028417](https://gitee.com/triabin/img_bed/raw/master/2026/01/15/52aa605442605e7ad204fb998b2f5480-image-20260115184028417.png)

<div style="clear: both;"></div>

`List`系列集合：添加的元素有序、可重复、有索引，当然这里的有序指的是存放顺序，其中`Vector`基本已经弃用。

`Set`系列集合：添加的元素无序、不可重复、没有索引。

`Collection`是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。常见方法：

|            方法名            |               说明               |
| :--------------------------: | :------------------------------: |
|  `public boolean add(E e)`   |   把指定的对象添加到当前集合中   |
|    `public void clear()`     |       清空集合中所有的元素       |
| `public boolean remove(E e)` |   把给定的对象在当前集合中删除   |
| `public boolean contains()`  | 判断当前集合中是否包含给定的对象 |
|  `public boolean isEmpty()`  |       判断当前集合是否为空       |
|     `public int size()`      | 返回集合中元素的个数/集合的长度  |

使用说明：

* `public boolean add(E e)`，在`List`集合中，这个方法始终返回`true`，因为它是允许重复的，如果是`Set`集合，当重复添加时，因为不允许重复，会导致添加元素失败。
* `public boolean remove(E e)`，因为是`Collection`中定义的通用方法，而`Set`集合中没有索引，所以只能通过元素进行删除，返回一个`boolean`类型的值，不存在的时候会删除失败。
* `public boolean contains()`，底层依赖`equals()`方法进行比较，如果是自定义的对象，注意重写`equals`方法。

`Collection`的遍历方式：从`Collection`继承关系中可以看到，它实现了`Iterable`接口，因此它可以通过迭代器遍历，此外还有增强for循环、Lambda表达式等遍历方式。（普通for循环只有`List`系列集合能使用，`Set`系列集合没有索引无法使用）

* 迭代器遍历：迭代器在Java中的类是`java.util.Iterator`，迭代器是集合专用的遍历方式，它不依赖索引。由于`Collection`继承了`Iterable`接口，因此它的所有实现类都必须重写`Iterator<T> iterator();`方法，调用该方法即可返回`Iterator`对象，默认指向当前集合的0索引。`Iterator`中常用的方法：

  |          方法名称          |                             说明                             |
  | :------------------------: | :----------------------------------------------------------: |
  | `public boolean hasNext()` | 判断当前位置是否有元素，有元素返回`true`，没有元素返回`false` |
  |     `public E next()`      |       获取当前位置的元素，并将迭代器对象移向下一个位置       |
  |   `public void remove()`   |        利用迭代器，删除集合中当前迭代器指针指向的元素        |

  使用说明：`Iterator`接口的实现类中，使用字段`cursor`记录迭代器当前指向的索引，`lastRet`记录上次取值的索引，每当调用`next()`方法的时候，将`cursor`对应的索引值取出，`cursor`的值赋值给`lastRet`，再将`cursor`加1，有了这些逻辑，当调用`hasNext()`方法的时候，直接判断`cursor`是否等于集合的长度即可，如果相等则代表已经没有下一位了，不能再调用`next`，不相等则还有下一位元素，可以直接调用`next`方法返回该索引的值。

  注意事项：

  * 当指针到达末尾，再调用`next`方法，则报`NoSuchElementException`异常
  * 迭代器遍历完毕，指针不会复位，如果想再次遍历，只能使用集合对象再次调用`iterator`方法创建一个新的迭代器对象
  * 迭代器遍历时，不能调用集合自身的`remove`方法删除元素，但是可以调用迭代器对象的`remove`方法删除元素，该方法会去修改结合对象中的参数，避免报`ConcurrentModificationException`异常，当然，也不能添加元素。
  * 在循环中，最好调用一次`next`方法，不然遇到边界就会触发`NoSuchElementException`异常
  * 关于`modCount`，该字段主要用来记录集合变化次数（相当于版本号），在集合中，每`add/remove`一次，这个变量的值都会自增。在迭代器中，创建迭代器对象时，会传入并记录这个值，每次`next`都会检查一遍当前集合中的`modCount`与传入时的值是否相等，不等就抛出并发修改异常，这也是不能再迭代过程中调用集合自身的增删方法的原因

* 增强for循环：底层其实就是一个迭代器，增强for循环其实就是为了简化迭代器书写的（JDK5新增），所有的单列集合和数组都能使用增强for循环来遍历，格式为`for (元素数据类型 变量名 : 数组/集合对象) { ... }`

  注意事项：

  * 与迭代器一样，也不能在遍历期间调用集合自身`remove`方法对其进行修改或者添加元素
  * 增强for循环中的变量名只是一个形参，给形参重新赋值不影响集合中的元素，当然，如果是修改形参指向的对象中的属性肯定有效

  > IDEA快速生成for循环代码模板：
  >
  > ① `fori + 回车（在弹窗出来的时候回车）`，快速进入`for (int i = 占位; i < 占位; i++) {}`的代码模板，占位位置填完后回车即可进入下一个占位位置，不填写则是有默认值就使用默认值，没有默认值就空着（关于IDEA代码模板的编写，以后有空再详述）；
  >
  > ② `数组/单列集合对象.for + 回车`，快速进入增强for循环代码模板。

* Lambda表达式：JDK8引入Lambda表达式时，提供的一种更简洁直接的遍历方式，主要依托于`Iterable`接口中新增的`default void forEach(Consumer<? super T> action)`方法，该方法通过一个`Consumer`接口，接收一个用于处理可迭代对象中每一个元素的方法即可完成遍历。

三种遍历方式演示：

```java
public class CollectionDemo {
    public static void main(String[] args) {
        Collection<Integer> list = new ArrayList<>(Arrays.asList(18, 2, 8, 50, 30, 22, 41, 44, 17, 12));

        // 1. 迭代器遍历
        System.out.print("迭代器遍历：");
        Iterator<Integer> iterator = list.iterator();
        while (iterator.hasNext()) {
            Integer item = iterator.next();
            System.out.print(item + " ");
        }
        System.out.println();

        // 2. 增强for循环遍历
        System.out.print("增强for循环遍历：");
        for (Integer item : list) {
            System.out.print(item + " ");
        }
        System.out.println();

        // 3. Lambda表达式遍历
        System.out.print("Lambda表达式遍历：");
        list.forEach(item -> System.out.print(item + " "));
        System.out.println();
    }
}
```

### 11.3 List系列集合

List集合特有的方法：由于`List`有索引，因此除了`Collection`中继承而来的方法外，它还多了许多索引相关的特有方法。

|                方法名称                 |                  说明                  |
| :-------------------------------------: | :------------------------------------: |
| `public void add(int index, E element)` |   在此集合中的指定位置插入指定的元素   |
|      `public E remove(int index)`       |       删除指定索引处的元素并返回       |
|  `public E set(int index, E element)`   | 修改指定索引处的元素，返回被修改的元素 |
|        `public E get(int index)`        |          返回指定索引处的元素          |

使用说明：

* `public void add(int index, E element)`，将元素插入指定位置，原来元素依次后移一位索引。
* `public E remove(int index)`，如果是`Integer`类型的集合，调用`remove`方法时如果调用的是`Collection`中的`remove`方法，需要注意需要手动装箱。（调用方法的时候，如果出现了重载现象，优先调用实参跟形参类型一致的那个方法）

List集合的遍历方法：除了`Collection`中的三种遍历方法，`List`集合还有另外两种遍历方式，普通for循环和列表迭代器。

* 普通for循环主要依托于`List`的`get(int index)`方法和`size()`方法。
* 列表迭代器`java.util.ListIterator`，继承`Iterator`，相比普通迭代器，它多出了获取索引和向前移动指针的以及修改元素的方法。

List相关的数据结构：在学习List系列集合的具体实现之前需要先了解和其相关的几种数据结构，主要是线性数据结构栈、队列、数组和链表。关于数据结构的学习其实只需要知道数据结构“长什么样子”、如何添加和删除数据即可。

* 栈`stack`：后进先出，先进后出，先存入其中的数据最后被取出来，JVM内存中的栈空间使用的就是这种结构。
  * 数据进入栈模型过程称为压/进栈
  * 数据离开栈模型过程成为弹/出栈
  * 最顶部元素称为栈顶元素
  * 最底部元素称为栈底元素
* 队列`queue`：先进先出，后进后出，存入顺序与取出顺序相同
  * 存入数据：入队列
  * 取出数据：出队列
* 数组`array`：相同类型的元素存储在连续的内存空间中，通过索引（实际上是数组对象地址的偏移量）访问元素
  * 查询速度快，查询数据通过地址值和索引定位，查询任意数据耗时相同（移位极快）
  * 删除效率低：要将原始数据删除，同时后面每个数据前移
* 链表`linked list `：每个元素都是一个节点，节点之间通过“引用”相连接，引用记录了下一个节点的内存地址（迭代器对象其实本质就是一个链表）
  * 第一个节点叫做头结点，最后节点叫做尾节点
  * 与数组相反，由于其数据结构特性，链表查询效率低（需要遍历），增删效率高（修改节点指向即可）
  * 特殊的链表：双向链表、环形链表（首尾相连）
  * 相较于数组，链表不需要连续的内存区间，可以将内存中离散的内存区域使用起来

#### ArrayList

结合JDK API文档中关于这个类的构造方法和类方法列表，可以初步了解该类的使用：

| 构造方法和方法描述                                           |
| ------------------------------------------------------------ |
| `ArrayList()`  构造一个初始容量为十的空列表。                |
| `ArrayList(Collection<? extends E> c)`  构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 |
| `ArrayList(int initialCapacity)`  构造具有指定初始容量的空列表。 |

> 泛型：可以限定集合中要存储的数据类型，格式为在类名后面使用`<E>`，尖括号中的`E`就是要存储的数据类型，并且这个泛型只能是引用数据类型，基本数据类型只能用它们的包装类型。

```java
public class CollectionDemo {
    public static void main(String[] args) {
        // ArrayList<String> list = new ArrayList<String>(); // JDK7以前
        ArrayList<String> list = new ArrayList<>(); // JDK7以后
        
        System.out.println(list); // []
        // 由于这个类底层已经做了一些处理（实现了toString()方法），打印对象不是地址值，而是集合中存储的数据内容，并且在展示时会使用中括号包裹。
    }
}
```

成员方法：

| 返回值类型        | 方法名和方法描述                                             |
| ----------------- | ------------------------------------------------------------ |
| `boolean`         | `add(E e)`  将指定的元素追加到此列表的末尾。                 |
| `void`            | `add(int index, E element)`  在此列表中的指定位置插入指定的元素。 |
| `boolean`         | `addAll(Collection<? extends E> c)`  按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 |
| `boolean`         | `addAll(int index,  Collection<? extends E> c)`  将指定集合中的所有元素插入到此列表中，从指定的位置开始。 |
| `void`            | `clear()`  从列表中删除所有元素。                            |
| `Object`          | `clone()`  返回此 `ArrayList`实例的浅拷贝。                  |
| `boolean`         | `contains(Object o)`  如果此列表包含指定的元素，则返回 `true` 。 |
| `void`            | `ensureCapacity(int minCapacity)`  如果需要，增加此 `ArrayList`实例的容量，以确保它可以至少保存最小容量参数指定的元素数。 |
| `void`            | `forEach(Consumer<? super E> action)`  对 `Iterable`的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。 |
| `E`               | `get(int index)`  返回此列表中指定位置的元素。               |
| `int`             | `indexOf(Object o)`  返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 |
| `boolean`         | `isEmpty()`  如果此列表不包含元素，则返回 `true` 。          |
| `Iterator<E>`     | `iterator()`  以正确的顺序返回该列表中的元素的迭代器。       |
| `int`             | `lastIndexOf(Object o)`  返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。 |
| `ListIterator<E>` | `listIterator()`  返回列表中的列表迭代器（按适当的顺序）。   |
| `ListIterator<E>` | `listIterator(int index)`  从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 |
| `E`               | `remove(int index)`  删除该列表中指定位置的元素。            |
| `boolean`         | `remove(Object o)`  从列表中删除指定元素的第一个出现（如果存在）。 |
| `boolean`         | `removeAll(Collection<?> c)`  从此列表中删除指定集合中包含的所有元素。 |
| `boolean`         | `removeIf(Predicate<? super E> filter)`  删除满足给定谓词的此集合的所有元素。 |
| `protected void`  | `removeRange(int fromIndex,  int toIndex)`  从这个列表中删除所有索引在 `fromIndex` （含）和  `toIndex`之间的元素。 |
| `void`            | `replaceAll(UnaryOperator<E> operator)`  将该列表的每个元素替换为将该运算符应用于该元素的结果。 |
| `boolean`         | `retainAll(Collection<?> c)`  仅保留此列表中包含在指定集合中的元素。 |
| `E`               | `set(int index, E element)`  用指定的元素替换此列表中指定位置的元素。 |
| `int`             | `size()`  返回此列表中的元素数。                             |
| `void`            | `sort(Comparator<? super E> c)`  使用提供的 `Comparator`对此列表进行排序以比较元素。 |
| `Spliterator<E>`  | `spliterator()`  在此列表中的元素上创建late-binding和故障快速Spliterator。 |
| `List<E>`         | `subList(int fromIndex,  int toIndex)`  返回此列表中指定的 `fromIndex` （包括）和  `toIndex`之间的独占视图。 |
| `Object[]`        | `toArray()`  以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 |
| `<T> T[]`         | `toArray(T[] a)`  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;  返回的数组的运行时类型是指定数组的运行时类型。 |
| `void`            | `trimToSize()`  修改这个 `ArrayList`实例的容量是列表的当前大小。 |

可以看到，`ArrayList`的成员方法非常多，但是总的来说，（对于这些用于存储多条数据的数据结构）其成员方法可以归咎与四类，分别是增、删、改、查，将这四类方法学会使用后，其余方法可以在使用到的时候再去查看方法注释即可（并且，这类方法连名字都大同小异）。

演示说明代码：

```java
/*
     boolean add(E e)       增
     
     boolean remove(E e)    删
     E remove(int index)
     
     E set(int index, E e)  改
     
     E get(int index)       查
     int size()             获取长度
 */
public class CollectionDemo {
    public static void main(String[] args) {
        // 1、创建一个集合
        ArrayList<String> list = new ArrayList<>();
        
        // 2、添加元素
        boolean addRes = list.add("aaa");
        System.out.println(addRes); // true，这个返回值一般不使用
        System.out.println(list);
        list.add("ccc");
        list.add("aaa");
        list.add("bbb");
        
        // 3、删除元素
        boolean delRes = list.remove("aaa");
        System.out.println(delRes);
        System.out.println(list); // 第一个“"aaa"”元素被删除
        System.out.println(list.remove("ddd")); // false，元素不存在，删除失败
        // ArrayList是有索引的，与数组一样，索引也是从0开始
        String delEle = list.remove(0);
        System.out.println(delEle); // ccc
        System.out.println(list);
        
        // 4、修改元素
        String setRes = list.set(1, "BBB");
        System.out.println(setRes); // bbb，它会将被覆盖的值返回
        System.out.println(list);
        
        // 5、查询
        String getRes = list.get(0);
        System.out.println(getRes); // aaa
        // 遍历
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
}
```

> 一旦访问到`ArrayList`中不存在的索引，也会报索引越界异常`java.lang.IndexOutOfBoundsException`。

`ArrayList`底层原理：

* 利用空参构造创建集合，会在底层创建一个默认长度为0的数组`elementData`，初始化成员变量`size`为0。
* 添加第一个元素时，底层会创建一个新的长度为10的数组，并在数组的`size++`位置存入第一个元素（`size`既表示下一个元素在数组中的索引，也表示集合长度）。
* 存满时，数组将扩容1.5倍（创建新数组，拷贝旧数据）。
* 如果一次添加多个元素并且1.5倍还放不下，则新建的数组长度以实际为准。
* 如果利用有参构造方法`public ArrayList(int initialCapacity)`创建集合，则是直接先创建长度为`initialCapacity`数组，可以有效避免中间的扩容操作，节约性能。
* 如果利用有参构造方法`public ArrayList(Collection<? extends E> c)`创建集合，则是将传入的集合`c`转为数组，再赋给`elementData`。

扩容源码分析：

* 调用空参`grow()`，空参中调用有参`grow(size + 1)`；

* `size + 1`作为最小需要扩容的空间，如果老容量不满足条件`oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA`，则表示第一次扩容，直接扩容为`new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]`即可，其中`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`表示空参构造创建时初始化的默认空数组；

* 如果满足条件`oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA`，则调用`int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, oldCapacity >> 1);`，然后利用`Arrays.copyOf(elementData, newCapacity)`复制老数据。其中`newLength`方法体为：

  ```java
  public static int newLength(int oldLength, int minGrowth, int prefGrowth) {
      // preconditions not checked because of inlining
      // assert oldLength >= 0
      // assert minGrowth > 0
  
      int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow
      if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {
          return prefLength;
      } else {
          // put code cold in a separate method
          return hugeLength(oldLength, minGrowth);
      }
  }
  ```

  其中，`int prefLength = oldLength + Math.max(minGrowth, prefGrowth);`表示扩容量为最小需要扩容容量和默认扩容容量中的较大值。而传参中的`oldCapacity >> 1`表示`oldCapacity`的一半，这也是默认扩容1.5倍的原因。

#### LinkedList

`java.util.LinkedList`底层是一个双向链表，查询慢，增删快，但是如果操作的是首尾元素，速度也是极快的，因此`LinkedList`本身多了很多直接操作首尾元素的特有API：

|          特有方法           |               说明               |
| :-------------------------: | :------------------------------: |
| `public void addFirst(E e)` |    在该列表开头插入指定的元素    |
| `public void addLast(E e)`  |  将指定的元素追加到此列表的末尾  |
|    `public E getFirst()`    |     返回此列表中的第一个元素     |
|    `public E getLast()`     |    返回此列表中的最后一个元素    |
|  `public E removeFirst()`   |  从此列表中删除并返回第一个元素  |
|   `public E removeLast()`   | 从此列表中删除并返回最后一个元素 |

当然，这些API了解即可，用得较少，有`Collection`和`List`中的那些API已经基本够用了。

由于`LinkedList`是一个双向链表，因此它的每个节点主要有三个部分，即节点自身数据`E item`、下一个节点的地址`Node<E> next`和前一个节点的地址`Node<E> prev`。

底层原理：

* 维护了三个成员变量，`transient int size = 0;`、`transient Node<E> first;`、`transient Node<E> last;`用来存储链表大小、头结点和尾节点。（`transient`关键字修饰的成员变量不会被序列化，既不会随着网络传输，包括数据库的IO。`Node`为`LinkedList`私有化内部类）
* 调用`add`方法时，底层调用了`linkLast`方法，直接操作尾节点的`next`指向要添加的元素以及将要添加元素创建节点的`prev`指向尾节点`final Node<E> newNode = new Node(last, e, null);`，然后修改尾节点为新创建的节点`last = newNode;`。
* 此外，底层也有相应的`linkBefore`方法来操作头结点。

### 11.4 泛型

泛型：是JDK5引入的特性，可以在编译阶段约束操作的数据类型，并进行检查，格式为`<数据类型>`。

注意：泛型只支持引用数据类型。

在引入泛型之前，集合中可以加入任意类型数据，导致了在使用集合时还需要强转数据，否则无法使用存入的实际数据类型的特有方法，只能使用`Object`中的方法。但是每次强转既麻烦又不安全。

泛型的好处：

* 统一数据类型
* 把运行时的问题提前到编译时，避免了强制类型转换可能出现的异常

扩展知识点：Java中泛型是伪泛型，前面提到的集合底层原理时，其中的`elementData`数组实际上就是`Ojbect`数组，只不过在取的时候进行了强转`return (E) elementData[index];`，之所以这样设计，最初也是为了向上兼容，因为当时已经有很多Java项目在运行，所以需要兼容旧的代码。

泛型使用细节：

* 泛型中不能写基本数据类型
* 指定泛型的具体类型后，传递数据时，可以传入该类型或者其子类型
* 如果不写泛型，类型默认是Object

泛型的的使用：泛型可以在很多地方进行定义，它可以定义在类后面（泛型类）、方法上面（泛型方法）和接口后面（泛型接口）。

#### 泛型类

使用场景：当一个类中，有变量的数据类型不确定时，就可以定义带有泛型的类，格式为`修饰符 class 类名<类型1, 类型2, ...> {}`，例如前文中的`ArrayList`其源码为`public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {`，当创建`ArrayList`对象的时候，`E`代表的类型才被确定，这里的`E`可以理解为一个变量或者说占位符，但是这个变量不是用来记录数据的，而是用来记录类型的。

类后面声明的泛型，在整个类中都可使用。

> 常用泛型变量：
>
> * `T`：Type，无意义的泛型类型最常用
> * `E`：Element，一般用来表示元素类型
> * `K`：key，一般用来表示键值对中的键
> * `V`：value，一般用来表示值

应用举例：定义一个网络响应的类。

```java
package com.triabin.ideasy_server.common.dto;

import lombok.Getter;

/**
 * 类描述：前后端交互响应类
 * @author Triabin
 * @date 2021-07-14 13:46:20
 */
@Getter
public class Response<T> {

    /**
     * 响应码，说明：响应码最好使用Integer，因为null和0的含义不一样
     */
    private Integer code;

    /**
     * 提示信息
     */
    private String msg;

    /**
     * 响应携带数据
     */
    private T data;

    public Response(Integer code, String msg, T data) {
        this.code = code;
        this.msg = msg;
        this.data = data;
    }

    public static <T> Response<T> success() {
        return new Response<>(200, "success", null);
    }

    public static <T> Response<T> success(T data) {
        return new Response<>(200, "success", data);
    }

    public static <T> Response<T> success(String msg, T data) {
        return new Response<>(200, msg, data);
    }

    public static <T> Response<T> fail() {
        return new Response<>(400, "fail", null);
    }

    public static <T> Response<T> fail(String msg) {
        return new Response<>(400, msg, null);
    }

    public static <T> Response<T> error() {
        return new Response<>(500, "error", null);
    }

    public static <T> Response<T> error(String msg) {
        return new Response<>(500, msg, null);
    }

    public Integer getCode() {
        return code;
    }

    public Response<T> setCode(Integer code) {
        this.code = code;
        return this;
    }

    public String getMsg() {
        return msg;
    }

    public Response<T> setMsg(String msg) {
        this.msg = msg;
        return this;
    }

    public T getData() {
        return data;
    }

    public Response<T> setData(T data) {
        this.data = data;
        return this;
    }
}
```

#### 泛型方法

方法中，参数列表中如果有参数的数据类型不确定，如果在泛型类中并且不确定的类型恰好是类上的泛型，则可以直接使用泛型类的泛型，如果不在泛型类的类型列表中，则可以在方法上声明泛型，格式为`修饰符 <类型1，类型2, ...> 返回值类型 方法名(类型, 变量名) { ... }`。

方法上面声明的泛型，只在方法中可以使用。

定义一个静态方法`getList`，用来通过数组直接获取`ArrayList`对象。

```java
import java.util.ArrayList;
import java.util.Arrays;

public class ListUtils {
    private ListUtils() {}
    
    @SafeVarargs
    public static <E> ArrayList<E> getList(E... elements) {
        return new ArrayList<>(Arrays.asList(elements));
    }
}
```

```java
// 使用：
public class GenericsDemo {
    public static void main(String[] args) {
        List<Integer> list = ListUtils.getList(1, 2, 3, 4, 5, 6, 7, 8);
        System.out.println(list); // [1, 2, 3, 4, 5, 6, 7, 8]
    }
}
```

> `(E… elements)`：表示可变参数，即只要是`E`类型的参数，你写多少个都行，最终数据都存入指定的变量`elements`中，数据类型为数组。

#### 泛型接口

接口中有不确定的类型时，就可以使用泛型接口，格式为`修饰符 interface 接口名<类型1, 类型2, ...> {}`。对于泛型接口的声明其实与泛型类的声明相差不大，对于泛型接口更重要的是如何去使用一个带泛型的接口：

* 实现类给出具体类型：`public class Clazz implements GenericsInterface<具体类型> {...}`，实现类中就直接使用具体类型，不再使用泛型。
* 实现类延续泛型，创建对象时再确定：`public class Clazz<泛型列表> implements GenericsInterface<泛型列表> {...}`，就和普通泛型类使用一样了。

#### 泛型的继承和通配符

泛型不具备继承性，但是数据具备继承性。

当一个方法`public static void method(List<Perent> list) `，参数列表中存在参数`List<Perent> list`，如果想要传入其子类集合`List<Son> list`，方法是不允许的，但是如果利用泛型将方法定义为`public static <E> void method(List<E> list)`，方法则变成了可以传入任意类型的集合，而不是**只传入自身以及和自身有继承关系的类**，于是就引入了泛型的通配符来`?`，`?`表示不确定的类型，它可以对类型进行限定：

* `? extends E`，表示可以传递`E`或者`E`所有的子孙类；
* `? super E`，表示可以传递`E`或者`E`所有的父类类型。

例如上述`public static void method(List<Perent> list)`方法的问题可利用通配符和限定符解决：`public static void method(List<? extends Perent> list)`。

> 注意：限定符`extends`和`super`不仅是通配符`?`可以用，普通的泛型也可以用。

### 11.5 Set系列集合

Set系列集合特性：

* 无序：存取顺序不一致
* 不重复：可以去重
* 无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引获取元素

Set序列集合实现类及特点：

* HashSet：无序、不重复、无索引
* LinkedHashSet：有序、不重复、无索引
* TreeSet：可排序、不重复、无索引

> Set接口中的方法基本上与Collection的API一致，所以基本上没有特有方法。

#### 相关数据结构

在学习`Set`系列集合之前，需要先了解`Set`系列集合涉及到的非线性数据结构——树，包括二叉树、二叉查找树、平衡二叉树和红黑树的概念。

**二叉树**`binary tree`：是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。

![image-20260120162950349](https://gitee.com/triabin/img_bed/raw/master/2026/01/20/6695e84fc4959976b0cc230e8b47603c-image-20260120162950349.png)

<div style="clear: both;"></div>

二叉树节点内部结构：父节点地址、值、左子节点地址、右子节点地址。

二叉树常见术语：

* 根节点`root node`：位于二叉树顶层的节点，没有父节点
* 叶节点`leaf node`：，没有子节点的节点，其两个指针均指向`null`
* 边`edge`：连接两个节点的线段，即节点引用（指针）
* （节点所在的）层`level`：从顶至底递增，根节点所在层为1
* 度`degree`：节点的子节点数量，二叉树中，度的取值范围为0、1、2
* 二叉树的高度`height`：从根节点到最远叶节点所经过的边的数量
* 节点的深度`depth`：从根节点到该节点所经过的边的数量
* 节点的高度`height`：从距离该节点最远的叶节点到该节点所经过的边的数量

二叉树的遍历（代码实现略）：

* 前序遍历：从根节点开始，按照当前节点，左子结点，右子节点的顺序遍历
* 中序遍历：从最左边的子节点开始，然后按照左子结点，当前节点，右子节点的顺序遍历（最常用）
* 后序遍历：从最左边的子节点开始，然后按照左子结点，右子节点，当前节点的顺序遍历
* 层序遍历：从根节点开始，一层一层的遍历

> 说明
>
> ① 关于前中后序遍历，只需要记住当前节点位置即可记住特性，即当前节点在前面就是前序遍历，在中间就是中序遍历，在后面就是后序遍历，不存在从右往左这种反人类遍历。
>
> ② 中序遍历最常用，在二叉查找树中，按照中序遍历的顺序遍历出来的数据刚好从小到大。

二叉树的弊端：内部数据没有要求，没有任何规律可言，不利于查找。

**二叉查找树:** 又称二叉排序树、二叉搜索树，满足任意节点左子节点小于当前节点，右子节点大于当前节点的二叉树就是二叉查找树。

* 添加数据规则：小的存左边，大的存右边，一样的不存。添加过程为从根节点比较，没有根节点就将自己作为根节点，比当前节点小就存入左子结点，比当前节点大就存入右子节点，如果左（右）子节点上已经有元素，就继续比较，直到存储成功为止。
* 查找规则：根据添加数据的规则查找即可。
* 弊端：如果遇到特殊数据，二叉查找树有退化成链表的可能，例如如果按顺序添加从小到大排列的数字，那么到最后就变成了只有右子树的二叉搜索树，即完全退化成了链表。

**二叉平衡树:** 任意节点左右子树高度差不超过1的二叉搜索树。

平衡二叉树保持平衡的方式——旋转机制：

* 触发时机：当添加一个节点后，该树不再是一颗平衡二叉树。

* 确定支点：从添加节点开始，不断往父节点找不平衡的节点（不满足平衡二叉树条件的点）。

* 左旋：以不平衡的点作为支点，将原来的右子节点晋升到支点所在位置，把支点左旋降级，变成晋升节点的左子结点；如果支点右子节点有自己的左子结点，那么旋转后，要将原右子节点的左子结点转给降级到左子结点的支点作为其右子节点（这个被转让的左子结点原先在支点右侧，一定比它大，所以作为右子节点刚好合适也不会占用其左子结点位置）。

  案例：

  ![image-20260122134906508](https://gitee.com/triabin/img_bed/raw/master/2026/01/22/5b07d2acda93cef2b6e22aa3b064e662-image-20260122134906508.png)

  <div style="clear: both;"></div>

  如上图案例（左）：当添加节点`12`后，向上逐级检查，到节点`10`，发现该节点左侧高度为0，右侧高度为2，不再符合平衡二叉树条件，对其以`10`为支点进行左旋，将其右节点`11`晋升到支点位置，支点左旋降级为晋升节点`11`的左节点。

  特殊情况（上图案例右）：当添加节点`12`后，向上逐级检查，发现根节点`7`不再满足平衡二叉树条件，于是以`7`为支点进行左旋，将右节点`10`晋升到`7`的位置，支点`7`左旋降级为`10`的左节点，但是`10`原先是有左子结点的，于是将`10`原先左子结点转给降级后的`7`作为右子节点。

* 右旋：和左旋相反即可。

平衡二叉树触发旋转的四种情况：

* 左左：当根节点左子树的左子树有节点插入，导致二叉树不平衡。`一次右旋解决`

  <img src="https://gitee.com/triabin/img_bed/raw/master/2026/01/22/8e4dbed4c28c8466f05d944d4200dfa9-image-20260122140055782.png" alt="image-20260122140055782" align="left" />

  <div style="clear: both;"></div>

* 左右：当根节点左子树的右子树有节点插入，导致二叉树不平衡。`先局部左旋，再整体右旋`

  <img src="https://gitee.com/triabin/img_bed/raw/master/2026/01/22/f59193a59b04c4a07f8102455bfb09b7-image-20260122140223496.png" alt="image-20260122140223496" align="left" />

  <div style="clear: both;"></div>

* 右右：当根节点右子树的右子树有节点插入，导致二叉树不平衡。`一次左旋解决`

  <img src="https://gitee.com/triabin/img_bed/raw/master/2026/01/22/b0c5dfe7fa8220e3bf069818017ddb00-image-20260122140912639.png" align="left"/>

  <div style="clear: both;"></div>

* 右左：当根节点右子树的左子树有节点插入，导致二叉树不平衡。`先局部右旋，再整体左旋`

  <img src="https://gitee.com/triabin/img_bed/raw/master/2026/01/22/51f2688ab07a19fb6221c3c645ae9295-image-20260122141140511.png" alt="image-20260122141140511" align="left" />

  <div style="clear: both;"></div>

**红黑树:** 红黑树是一种自平衡的二叉查找树，刚出现时称为“平衡二叉B树”，后改为红黑树。是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色，每一个节点可以是红或黑，红黑树不是高度平衡的，它的平衡是通过“红黑规则”进行实现的。

![image-20260122141734283](https://gitee.com/triabin/img_bed/raw/master/2026/01/22/00348b157d3cf4494200157c6ff784d0-image-20260122141734283.png)

<div style="clear: both;"></div>

平衡二叉树弊端：当左右子树高度差超过1时就进行旋转，旋转操作过于频繁，性能消耗大。

红黑树改进：是一个二叉查找树，但不是高度平衡的二叉查找树，需要触发特有的**红黑规则**才会触发旋转。

红黑规则：

* 每一个节点都是红色或者黑色（相较于二叉树节点，红黑树节点多一个颜色属性）
* 根节点必须是黑色
* 如果一个节点没有子节点或父节点，则该节点相应的子/父节点指针属性值为`Nil`，这些`Nil`视为叶节点，每个叶节点（`Nil`）是黑色的
* 如果某一个节点是红色，那么它的子节点必须是黑色，不能出现两个红色节点相连的情况
* 对每一个节点，从该节点到其所有后代节点的简单路径上，均包含相同数目的黑色节点

<span id="red-black-rule">红黑树添加节点的规则（节点颜色默认为红，效率高，因为能有效减少颜色调整次数）</span>：

![image-20260122143858822](https://gitee.com/triabin/img_bed/raw/master/2026/01/22/eab426cc58c19419033820382de4583a-image-20260122143858822.png)

<div style="clear: both;"></div>

这套处理方案的使用，使得红黑树的增删改查性能都很好，因为其跟多的是修改节点颜色（修改属性值而已），旋转操作相对平衡二叉树少得多。

#### HashSet

`java.util.HashSet`，由于它没有特有的API，所以只需要了解学习其底层原理即可：`HashSet`集合底层采用哈希表存储数据，哈希表是一种对于增删改查数据性能都较好的结构。

哈希表的组成：

* JDK8之前：数组+链表
* JDK8开始：数组+链表+红黑树

哈希表`hash table`：又称散列表，是通过哈希函数计算出对象的哈希值（单向），将对象与一个唯一确定的数值建立对应关系并存储的一种数据结构。举例：如果将存入集合对象计算出哈希值后利用哈希值作为数组索引，然后直接将对象存入数组，这样就相当于给对象创建了一个哈希表。

哈希值：对象的整数表现形式。

* 根据`hashCode`方法算出来的`int`类型的整数
* 该方法定义在`java.lang.Object`类中，所有对象都可以调用，默认使用地址值进行计算
* 一般情况下，会重写`hashCode`方法，利用对象内部的属性值计算哈希值

对象的哈希值特点：

* 如果没有重写`hashCode`方法，不同对象计算出的哈希值是不同的
* 如果已经重写`hashCode`方法，不同的对象只要属性相同，计算出的哈希值就是一样的
* 在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能是一样的（哈希碰撞）

基于哈希表的特性，在实际的使用中（例如Java中`java.util.HashSet`类的设计），需要考虑哈希算法（计算哈希值的函数）、哈希表容量`capacity`、触发扩容的负载因子`loadThres`以及扩容倍数等属性的设计。（关于哈希表的系统学习，还是建议移步[krahets/hello-algo](https://github.com/krahets/hello-algo)的第六章 哈希表）

`HashSet`底层原理：

* 创建一个默认长度为16，默认加载因子为0.75的数组，数组名为`table`
* 根据元素的哈希值和数组长度，计算出应存入的数组索引位置`int index = (数组长度 - 1) & 哈希值;`
* 判断对应索引位置是否为空， 如果为空直接存入
* 如果不为空（发生哈希冲突），则表示有元素，此时调用存入对象的`equals`方法比较属性值
* 如果属性值也相同，则不存入数组
* 如果属性值不同，则存入数组，形成链表。JDK8以前，新元素存入数组，老元素挂在新元素下面；JDK8以后，新元素直接挂在老元素下面
* 如果该位置本来就已经是链表，则挨个调用`equals`进行比较，都返回`false`才会添加
* 如果添加后`table`中的元素达到`16 x 0.75 = 12`的时候，数组就会扩容2倍
* 当链表长度大于8且数组长度大于等于64，当前链表就转为红黑树（JDK8 later）

注意：

* JDK8以后，当链表长度**超过8**，而且数组长度**大于等于64**时，自动转为红黑树
* 如果集合中存储的是自定义对象，必须要重写`equals`和`hashCode`方法（这也是前文说自定义对象几乎都要重写这两个方法的原因），这两个方法是去重的核心

基于上面这一套机制，所以`HashSet`才有无序、无索引、不可重复等特点。

#### LinkedHashSet

`java.util.LinkedHashSet`，是`HashSet`子类，与`HashSet`的区别就是它的存取是有序的，这里的有序指的是存储和取出元素的顺序一致。

原理：底层数据结构依然是哈希表，只是每个元素又额外多了一个双链表的机制记录存储的顺序。

#### TreeSet

`java.util.TreeSet`，与普通Set集合相比，它是可排序的，一般按照元素的默认规则从小到大排序，也可以通过构造方法传入排序所需的`java.util.Comparator`接口实现排序。

之所以默认是从小到大，是因为`TreeSet`集合底层是基于红黑树的数据结构实现排序的，增删改查性能都比较好。

`TreeSet`集合默认的排序规则：

* 对于数值类型：`Integer`、`Double`，默认按照从小到大的顺序排序
* 对于字符、字符串类型，按照字符在ASCII码表中的数字升序排序，如果是字符，直接比较即可，如果是字符串，则每个字符逐一比较，直到比出大小为止（后面不管有什么能容都不再比较）

`TreeSet`的两种比较方式：

* `java.util.Comparable`接口的使用（默认/自然排序）：可以将要比较的类直接实现该接口，重写其`compareTo()`方法，然后直接存入`TreeSet`中即可自然排序。

  ```java
  public class Student implements Comparable<Student> {
      private String name;
      private int age;
  
      public Student() {
      }
  
      public Student(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public String getName() {
          return name;
      }
  
      public Student setName(String name) {
          this.name = name;
          return this;
      }
  
      public int getAge() {
          return age;
      }
  
      public Student setAge(int age) {
          this.age = age;
          return this;
      }
  
      @Override
      public int compareTo(Student o) {
          // 按照年龄升序排序
          return this.getAge() - o.getAge();
      }
  }
  ```

  将该类存入`TreeSet`中时，运行`compareTo`方法进行比较，其中，`this`表示当前要添加的元素，`o`表示已经在红黑树中存在的元素。对于返回值，如果是负数，就认为要添加的元素是小的，存入节点左边；如果是正数，认为要添加的元素是大的，存入节点右边；如果是0，认为要添加的元素已经存在，直接舍弃不存。

* `java.util.Comparator`接口的使用（比较器排序）：可以在创建`TreeSet`对象的时候，传入比较器`Compartor`指定比较规则。（这样对于要比较的对象没有侵入性且更加灵活）

  ```java
  import java.util.Comparator;
  import java.util.Set;
  import java.util.TreeSet;
  
  public class TreeSetDemo {
      public static void main(String[] args) {
          Set<Student> set = new TreeSet<>(Comparator.comparing(Student::getAge));
      }
  }
  ```

  这样也能达到和上面实现`Comparable`接口同样的效果，`comparing`方法会返回一个指定比较方法的`Comparator`接口。

> `HashSet`底层其实是创建了一个`HashMap`，只不过所有的`key`都指向同一个`value`，对于`HashMap`的见后续双列集合内容。

### 11.6 双列集合

双列集合的特点：

* 双列集合一次需要存一对数据，分别为键和值
* 键不能重复，值可以重复
* 键和值是一一对应的，每一个键只能找到自己对应的值
* `键+值`这个整体称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”

Java中双列集合的体系结构：

![image-20260122220409237](https://gitee.com/triabin/img_bed/raw/master/2026/01/22/a953d0367be3d7af941f81160ec85bd1-image-20260122220409237.png)

<div style="clear: both;"></div>

#### Map接口

`java.util.Map`是双列集合的顶层接口，它的功能是全部双列集合都可以继承使用的。

以下为`Map`接口最常见的几个API：

|               方法名称                |                 说明                 |
| :-----------------------------------: | :----------------------------------: |
|        `V put(K key, V value)`        |               添加元素               |
|        `V remove(Object key)`         |         根据键删除键值对元素         |
|            `void clear()`             |         移除所有的键值对元素         |
|   `boolean containsKey(Object key)`   |       判断集合是否包含指定的键       |
| `boolean containsValue(Object value)` |       判断集合是否包含指定的值       |
|          `boolean isEmpty()`          |           判断集合是否为空           |
|             `int size()`              | 集合的长度，也就是集合中键值对的个数 |

使用说明：

* `V put(K key, V value)`，添加/覆盖元素，如果键不存在，那么直接把键值对添加到Map集合中，方法返回`null`；如果键存在，则会把原有对象覆盖，然后返回被覆盖的值。
* `V remove(Object key)`，返回被删除的键值对中的值，不存在的键则返回`null`

> 说明：这几个方法都是以后在双列集合中使用最频繁的方法。

**`Map`遍历方式:** 键找值，键值对，Lambda表达式。Lambda底层其实用的也是键值对遍历。

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class MapDemo {
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>();
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key4", "value4");
        System.out.println("原生打印：" + map);

        // 键找值遍历
        Set<String> keys = map.keySet();
        List<String> kvList = new ArrayList<>(map.size());
        for (String key : keys) {
            kvList.add(key + "=" + map.get(key));
        }
        System.out.printf("键找值遍历：{%s}%n", String.join(", ", kvList));

        // 键值对遍历
        Set<Entry<String,String>> entries = map.entrySet();
        List<String> entryList = new ArrayList<>(entries.size());
        for (Entry<String, String> entry : entries) {
            entryList.add(entry.getKey() + "=" + entry.getValue());
        }
        System.out.printf("键值对遍历：{%s}%n", String.join(", ", entryList));

        // Lambda表达式遍历
        List<String> lambdaList = new ArrayList<>(map.size());
        map.forEach((key, value) -> lambdaList.add(key + "=" + value));
        System.out.printf("Lambda遍历：{%s}%n", String.join(", ", lambdaList));
    }
}
```

#### HashMap

`java.util.HashMap`是`Map`的一个实现类，没有额外需要学习的特有方法，直接使用`Map`里面的方法就可以了，特点是有键决定的（无序、不重复、无索引），`HashMap`跟`HashSet`底层原理是一模一样的，都是哈希表结构。

`HashMap`底层与`HashSet`一样，也是首先创建长度为16的数组，负载因子也是0.75（`HashSet`底层其实是创建一个`HashMap`，只不过所有键都指向同一个值）。但是在`HashMap`中，存入数组中的是`java.util.Map.Entry`对象，并且计算哈希值的时候只用键来计算，跟值无关。另外，关于哈希冲突时的处理（包括调用键的`equals`方法结果也是`true`的情况），如果键相同，则覆盖值，而不是像`HashSet`一样不添加。

:::warning 注意

基于哈希表在Java中的底层这种运用原理，如果要使用引用类型作为`HashMap`的键（虽然实际项目中我从来没见过这么干，但是我见过这样的面试题），那么一定一定要重写定好对应类型的`equals`和`hashCode`方法。

:::

**源码解析:** （`java.util.HashMap`类）

> 源码解析前置语法知识
>
> ① 对于类似语句`(tab = table) == null`这样的写法，回显运行括号中的语句，对于赋值语句的返回值可以直接视为被赋值的变量值，所以该语句可以拆解为`tab = table; tab == null;`，这样的写法是被允许的，当然这种写法基本只在源码中使用，项目中使用容易被同事打😓（可读性太差）。
>
> ② 对于本来就在类中的成员变量为什么方法体中总要再创建一个局部变量来存放成员变量的值，这是因为成员变量是存放在堆空间中的，而这些方法在运行时方法体存放在栈空间中，为了讲究效率，就在栈空间中定义了一个局部变量来存储这些成员变量对应的地址值，避免从堆空间获取。这点时间与性能的节省对于企业中的大部分项目来说不算什么，但是这个是JDK的源码设计，应用过于广泛，积少成多影响还是不小，所以Java源码中经常这么做，但是项目中却很少见。

* 要了解`HashMap`类的基本原理，需要了解其为了数据的增删改查以及存储定义的部分变量和内部类：

  ① 存储数据的`Entry`接口实现类`static class Node<K,V> implements Map.Entry<K,V>`

  ```java
  static class Node<K,V> implements Map.Entry<K,V> {
      /** 键的哈希值 */
      final int hash;
      /** 键 */
      final K key;
      /** 值 */
      V value;
      /** 如果是链表，这是下一个节点的地址 */
      Node<K,V> next;
  }
  ```

  ② 当链表转为红黑树时，红黑树的存储节点类`static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V>`，它是`HashMap.Node`的子孙类，相比`HashMap.Node`，它多了以下变量：

  ```java
  static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
      /** 父节点地址 */
      TreeNode<K,V> parent;  // red-black tree links
      /** 左子结点地址 */
      TreeNode<K,V> left;
      /** 右子节点地址 */
      TreeNode<K,V> right;
      /** 暂不关注 */
      TreeNode<K,V> prev;    // needed to unlink next upon deletion
      /** 节点颜色（是否为红色） */
      boolean red;
  }
  ```

  ③ 存储数据的数组`Node<K, V>[] table`，默认大小由常量`static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;`决定，即16。

  ④ 负载因子`float loadFactor`，当`table`存入数据占用达到自身长度的这个比例之后触发扩容，默认值为常量`static final float DEFAULT_LOAD_FACTOR = 0.75f;`。

  ⑤ 集合当前大小`int size`。

  ⑥ 阈值`int threshold`，通过负载因子和当前存储数据的数组长度计算出的下次出发扩容时的容量。

  ⑦ 其他常量：集合最大容量`static final int MAXIMUM_CAPACITY = 1 << 30;`（$2^{64}$），链表转为红黑树的链表长度阈值`static final int TREEIFY_THRESHOLD = 8;`，红黑树转为链表的阈值`static final int UNTREEIFY_THRESHOLD = 6;`，链表转为红黑树的最小容量要求`static final int MIN_TREEIFY_CAPACITY = 64;`，记录集合操作次数的变量`transient int modCount;`。

* 空参构造方法创建`HashMap`，此时只会给负载因子赋默认值，不执行其他操作（有参构造容后再议），注意直到此时，`table`仍然为`null`。

* 之后执行`put`方法，添加元素。执行`put`方法，该方法体只有一行`return putVal(hash(key), key, value, false, true);`，其中`static final int hash(Object key)`方法作用是通过`key`计算哈希值，原理涉及到数学上的原理运算。以下为`putVale`方法源码：

  ```java
  // putVal方法源码：
  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                     boolean evict) {
      Node<K,V>[] tab; Node<K,V> p; int n, i;
      if ((tab = table) == null || (n = tab.length) == 0)
          n = (tab = resize()).length;
      if ((p = tab[i = (n - 1) & hash]) == null)
          tab[i] = newNode(hash, key, value, null);
      else {
          Node<K,V> e; K k;
          if (p.hash == hash &&
              ((k = p.key) == key || (key != null && key.equals(k))))
              e = p;
          else if (p instanceof TreeNode)
              e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
          else {
              for (int binCount = 0; ; ++binCount) {
                  if ((e = p.next) == null) {
                      p.next = newNode(hash, key, value, null);
                      if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                          treeifyBin(tab, hash);
                      break;
                  }
                  if (e.hash == hash &&
                      ((k = e.key) == key || (key != null && key.equals(k))))
                      break;
                  p = e;
              }
          }
          if (e != null) { // existing mapping for key
              V oldValue = e.value;
              if (!onlyIfAbsent || oldValue == null)
                  e.value = value;
              afterNodeAccess(e);
              return oldValue;
          }
      }
      ++modCount;
      if (++size > threshold)
          resize();
      afterNodeInsertion(evict);
      return null;
  }
  ```

  `final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)`方法参数解析：

  ​	`hash` - 哈希值

  ​	`key` - 传入的键

  ​	`value` - 传入的值

  ​	`onlyIfAbsent` - （如果键重复）是否覆盖值，`only if absent`意为“仅在（键对应的值）缺失的”情况下才覆盖，`put`方法中默认给传了`false`

  ​	`evict` - 略（这里用不上）

  由源码课件条件众多，但是总的来说主要为三种情况，即`table`未创建或长度为0、键重复、键不重复。

  ① `table == null`

  * 第一个判断条件`(tab = table) == null || (n = tab.length) == 0`满足，所以进入`resize()`方法
  * 在`resize()`方法中，由于当前`table`尚未初始化，从其中逻辑可以看出最终会将其初始化为一个长度为`DEFAULT_INITIAL_CAPACITY`的数组，并给`threshold`赋值为`DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY`
  * 这个方法执行完后，第二个条件`if ((p = tab[i = (n - 1) & hash]) == null)`也肯定满足了，因为此时数组中任意位置都是`null`，所以此时`table`数组在通过哈希值计算出来的索引位置的值被直接赋值
  * 因为此次添加数据没有发生覆盖操作，所以直接返回`null`

  ② `table != null && 键重复`，元素覆盖

  * `putVal`方法前两个条件都不满足，直接进入`else`（尽管条件不满足，但是`p = tab[i = (n - 1) & hash]`是一定会被执行的）
  * 因为键重复，所以`else`中的第一个`if`条件肯定满足，所以需要覆盖原来的值，所以后面的内容都是为了能否覆盖原来键对应得值（`e = p`）
  * `if (e != null)`中的内容概括下来就是覆盖原先`Node`对象中的值并返回那个被覆盖的值`oldValue`（全程不涉及到`resize`）

  ③ `table != null && 键不重复`，此时挂在下面形成链表或者红黑树

  * 直接进入最外层流程控制语句的`else`中，这次第一个`if`的条件也不满足
  * 如果获取到的`p`是红黑树的对象`TreeNode`，那么就走红黑树的`put`逻辑（调用`putTreeVal`方法）
  * 否则走链表的逻辑，利用`for (int binCount = 0; ; ++binCount)`这个死循环遍历链表
  * 如果数据插入链表末尾后链表长度超出`TREEIFY_THRESHOLD - 1`（`if (binCount >= TREEIFY_THRESHOLD - 1)`），那么就需要将链表转为红黑树（调用`treeifyBin`方法）
  * 添加完成后，判断是否需要扩容`if (++size > threshold)`

* 有参构造，在了解了以上原理之后，有参构造基本都可以见文知意了。分别可以传入初始化容量、负载因子以及通过现有的`Map`接口的其他实现类直接创建。其中，可以传入初始容量的好处跟之前的`HashSet`以及`ArrayList`等一致，也是能避免不必要的扩容，节省性能，这个在项目中也还算常用。至于负载因子，一般来说越大越能充分利用空间，但是会增加哈希冲突发生的可能性；越小越能避免哈希冲突，但是又会占用更多的内存空间，JDK的开发大佬们通过各种运算已经计算出了0.75这个较为合适的值，基本上在项目中是不会去修改这个参数的（至少我从来没见过）。

#### LinkedHashMap

`java.util.LinkedHashMap`是`HashMap`的子类，类似`LinkedHashSet`，它的特点也是有序（由键决定）、不重复、无索引。这里的有序指的是保证存储和取出的元素顺序一致，从类名可以看出，其底层数据结构依然是哈希表，这是每个键值对元素又额外的多了一个双向链表的机制记录存储的顺序。

#### TreeMap

`java.util.TreeMap`跟`TreeSet`底层原理一样，都是红黑树结构，特点是不可重复、无索引、（键）可排序，默认按照键的从小到大顺序排列，也可以自己规定键的排序规则。

排序规则：

* 实现`Comparable`接口，指定比较规则
* 创建集合时传入`Comparator`比较器对象，指定比较规则

**源码解析:** （`java.util.TreeMap`类）

* 为了数据的增删改查以及存储定义的部分变量和内部类：

  ① `TreeMap`存储数据的基本类`static final class Entry<K,V> implements Map.Entry<K,V>`（是一个内部类）

  ```java
  static final class Entry<K,V> implements Map.Entry<K,V> {
      /** 键 */
      K key;
      /** 值 */
      V value;
      /** 左子结点地址 */
      Entry<K,V> left;
      /** 右子节点 */
      Entry<K,V> right;
      /** 父节点 */
      Entry<K,V> parent;
      /** 红黑树节点颜色 */
      boolean color = BLACK;
  }
  ```

  >  关于节点颜色，这里之所以默认为黑色，是因为当`put`的时候还会调整其颜色，所以没有使用红黑树默认的红色。

  ② 成员变量：排序用的比较器`private final Comparator<? super K> comparator;`（如果创建`TreeMap`的时候未指定，那么就为空，排序使用存入键的默认排序方式自然排序），红黑树根节点`private transient Entry<K,V> root;`，存储键值对数量`private transient int size = 0;`

* 对于`TreeMap`对象的创建，如果使用空参构造，则`comparator`值为`null`，如果传入`Comparator`接口实现类则直接赋值给`comparator`变量，其余构造方法略

* 之后执行`put`方法，添加元素，该方法方法体也只有一行`return put(key, value, true);`，同样另外定义了一个私有的`put`方法来入值，以下为其源码：

  ```java
  private V put(K key, V value, boolean replaceOld) {
      Entry<K,V> t = root;
      if (t == null) {
          addEntryToEmptyMap(key, value);
          return null;
      }
      int cmp;
      Entry<K,V> parent;
      // split comparator and comparable paths
      Comparator<? super K> cpr = comparator;
      if (cpr != null) {
          do {
              parent = t;
              cmp = cpr.compare(key, t.key);
              if (cmp < 0)
                  t = t.left;
              else if (cmp > 0)
                  t = t.right;
              else {
                  V oldValue = t.value;
                  if (replaceOld || oldValue == null) {
                      t.value = value;
                  }
                  return oldValue;
              }
          } while (t != null);
      } else {
          Objects.requireNonNull(key);
          @SuppressWarnings("unchecked")
          Comparable<? super K> k = (Comparable<? super K>) key;
          do {
              parent = t;
              cmp = k.compareTo(t.key);
              if (cmp < 0)
                  t = t.left;
              else if (cmp > 0)
                  t = t.right;
              else {
                  V oldValue = t.value;
                  if (replaceOld || oldValue == null) {
                      t.value = value;
                  }
                  return oldValue;
              }
          } while (t != null);
      }
      addEntry(key, value, parent, cmp < 0);
      return null;
  }
  ```

  `private V put(K key, V value, boolean replaceOld)`方法参数列表解析：

  ​	`key` - 键

  ​	`value` - 值

  ​	`replaceOld` - （如果键重复）是否替换旧值（注意与`onlyIfAbsent`区分，二者意思相反，所以`HashMap`才默认传入`false`，这里在相同目的的情况下默认需要传入`true`）

  `TreeMap`主要源码相对于`HashMap`来说，较为简单，主要明晰以下几个点即可：

  ① 首先是第一次添加元素时调用`addEntryToEmptyMap`方法时比较大小是本次添加的元素的键自己跟自己比；

  ② `comparator`主要为了获取`comparTo`的结果，如果没有传入`Comparator`实现类对象，那么就需要存入的键自身实现`Comparable`接口，否则在`else`中执行强转` Comparable<? super K> k = (Comparable<? super K>) key;`的时候就会包报错；

  ③ 对于`if`和`else`中的代码，其实逻辑都一样，主要就是为了确定本次添加的`key`的父节点以及是添加在左还是右，当然如果发现键冲突（`comparTo`结果为0），那么会直接覆盖并返回被覆盖的旧值结束方法；

  ④ 对于最终调用的`addEntry`方法，添加玩节点后会调用`fixAfterInsertion`方法，该方法会按照之前的[红黑树添加节点规则](#red-black-rule)调整各个节点颜色，`fixAfterInsertion`方法中的第一行就是将颜色设置为红色。

  ```java
  private void fixAfterInsertion(Entry<K,V> x) {
      // 首先将红黑树节点颜色设置为红色（符合红黑树默认颜色规则）
      x.color = RED;
  
      // 按照红黑树规则进行调整
  
      // parentOf：获取父节点，所以parentOf(parentOf(x))为获取组父节点
      // leftOf：获取左子结点
      while (x != null && x != root && x.parent.color == RED) {
          // 判断当前节点的父节点是组父节点的左子结点还是右子节点
          // 目的：为了获取当前节点的叔叔节点
          if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
              // 符合条件，则表示当前节点的父节点是组父节点的左子结点，那么rightOf获取到的就是当前节点的叔叔节点
              Entry<K,V> y = rightOf(parentOf(parentOf(x)));
              if (colorOf(y) == RED) {
                  // 叔叔节点为红色处理方案：
  
                  // 把父节点设置为黑色
                  setColor(parentOf(x), BLACK);
                  // 把叔叔节点设置为褐色
                  setColor(y, BLACK);
                  // 把祖父节点设置为红色
                  setColor(parentOf(parentOf(x)), RED);
                  // 把爷爷节点设置为当前节点，继续判断
                  x = parentOf(parentOf(x));
              } else {
                  // 叔叔节点为黑色处理方案：
  
                  // 表示判断当前节点是否为父节点的右子节点
                  if (x == rightOf(parentOf(x))) {
                      // 将父节点当做当前节点
                      x = parentOf(x);
                      // 然后左旋，之后再继续判断
                      rotateLeft(x);
                  }
                  // 由于左旋之后就会满足当前节点是父节点的左子结点这一条件，可以继续该条件的操作
  
                  // 将父节点设置为黑色
                  setColor(parentOf(x), BLACK);
                  // 将祖父节点设置为红色
                  setColor(parentOf(parentOf(x)), RED);
                  // 再以组父节点为支点右旋
                  rotateRight(parentOf(parentOf(x)));
              }
          } else {
              // 不符合条件，则表示当前节点的父节点是组父节点的右子结点，那么lefttOf获取到的就是当前节点的叔叔节点
              Entry<K,V> y = leftOf(parentOf(parentOf(x)));
              if (colorOf(y) == RED) {
                  setColor(parentOf(x), BLACK);
                  setColor(y, BLACK);
                  setColor(parentOf(parentOf(x)), RED);
                  x = parentOf(parentOf(x));
              } else {
                  if (x == leftOf(parentOf(x))) {
                      x = parentOf(x);
                      rotateRight(x);
                  }
                  setColor(parentOf(x), BLACK);
                  setColor(parentOf(parentOf(x)), RED);
                  rotateLeft(parentOf(parentOf(x)));
              }
          }
      }
      // 最终无论如何确保根节点为黑色
      root.color = BLACK;
  }
  ```


### 11.7 集合工具类Collections

`java.util.Collections`是集合的工具类，主要提供一些集合相关的静态方法。

`Collections`中常用的API：

|                           方法名称                           |              说明               |
| :----------------------------------------------------------: | :-----------------------------: |
| `public static <T> boolean addAll(Collection<T> c, T... elements)` |          批量添加元素           |
|          `public static void shuffle(List<?> list)`          |    打乱`List`集合元素的顺序     |
|         `public static <T> void sort(List<T> list)`          |              排序               |
| `public static <T> void sort(list<T> list, Compartor<T> c)`  |     根据指定的规则进行排序      |
|  `public static <T> int binarySearch(List<T> list, T key)`   |        以二分法查找元素         |
|   `public static <T> void copy(List<T> dest, List<T> src)`   |        拷贝集合中的元素         |
|      `public static <T> int fill(List<T> list, T obj)`       |     使用指定的元素填充集合      |
|     `public static <T> void max/min(Collection<T> coll)`     | 根据默认的自然排序获取最大/小值 |
|    `public static void swap(List<?> list, int i, int j)`     |    交换集合中指定位置的元素     |

### 11.8 不可变集合

不可变集合：即不可修改元素的集合（主要指增删以及修改元素指向的地址，不包括元素自身的属性修改），例如前文提到过的`Arrays.asList`方法返回的`List`就是不可变的。

使用场景：

* 如果某个数据不能被修改，把它防御性的拷贝到不可变集合中是一种对数据很好的保护方式。
* 当集合被不可用的库调用时，不可变形式是安全的。

创建不可变的集合：在`List`、`Set`、`Map`接口中，都存在静态的`of`方法，可以获取一个不可变的集合。

|                  方法名称                   |                 说明                 |
| :-----------------------------------------: | :----------------------------------: |
|   `static <E> List<E> of(E... elements)`    | 创建一个具有指定元素的`List`集合对象 |
|    `static <E> Set<E> of(E... elements)`    | 创建一个具有指定元素的`Set`集合对象  |
| `static <K, V> Map<K, V> of(E... elements)` | 创建一个具有指定元素的`Map`集合对象  |

注意：这个集合不能添加、删除或是修改元素。

使用说明：

* 创建的集合并不是不能调用增删改方法，而是调用后会报错`UnsupportedOperationException`。
* `static <E> Set<E> of(E... elements)`的参数必须保证唯一性，否则也会报错。
* `static <K, V> Map<K, V> of(E... elements)`的参数为成对出现，并且由于无法定义可变参数，所以最多可以输入10个键值对，并且也要确保键不能重复。

`Map`不可变集合如果键值对超过10个，的解决方案：

```java
public class CollDemo {
    public static void main(String[] args) {
        // 创建一个普通的Map集合并存入超过10组键值对
        Map<String, String> map = new HashMap<>();
        map.put("a", "1");
        map.put("b", "2");
        map.put("c", "3");
        map.put("d", "4");
        map.put("e", "5");
        map.put("f", "6");
        map.put("g", "7");
        map.put("h", "8");
        map.put("i", "9");
        map.put("j", "10");
        map.put("k", "11");
        map.put("l", "12");

        // 获取Entry对象
        // Set<Map.Entry<String, String>> entries = map.entrySet();
        // 将其转为一个数组
        // 说明：toArray方法在底层会比较集合的长度跟数组长度
        // 如果集合长度＞数组长度，则根据实际数据个数重新创建数组
        // 如果集合长度≤数组长度，则直接使用，数组超出部分为默认初始化值
        // Map.Entry[] entriesArr = entries.toArray(new Map.Entry[0]);
        // 获取不可变集合
        // Map immMap = Map.ofEntries(entriesArr);
        // 以上步骤简写为
        Map<Object, Object> immutableMap = Map.ofEntries(map.entrySet().toArray(new Map.Entry[0]));
        
        // 等到了JDK10，将以上步骤收录进了copyOf方法，并且确保了泛型不丢失
        Map<String, String> immuMap = Map.copyOf(map);
    }
}
```

## 12、Stream流

## 13、异常

## 14、File

## 15、IO流

## 16、多线程&JUC

## 17、网络编程

## 18、反射
